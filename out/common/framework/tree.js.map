{"version":3,"sources":["../../../src/common/framework/tree.ts"],"names":["compareQueries","Ordering","TestQueryMultiCase","TestQuerySingleCase","TestQueryMultiFile","TestQueryMultiTest","stringifySingleParam","assert","TestTree","constructor","root","iterateCollapsedQueries","iterateSubtreeCollapsedQueries","iterateLeaves","iterateSubtreeLeaves","toString","subtreeToString","subtree","child","children","collapsible","query","name","tree","indent","s","JSON","stringify","description","undefined","loadTreeForQuery","loader","queryToLoad","subqueriesToExpand","suite","specs","listing","subqueriesToExpandEntries","Array","from","entries","seenSubqueriesToExpand","length","fill","isCollapsible","subquery","every","i","toExpand","ordering","Equal","StrictSubset","foundCase","subtreeL0","makeTreeForSuite","entry","file","readme","trim","queryL1","orderingL1","Unordered","readmeSubtree","addSubtreeForDirPath","spec","importSpecFile","subtreeL1","addSubtreeForFilePath","t","g","iterate","queryL3","id","test","params","orderingL3","StrictSuperset","subtreeL2","addSubtreeForTestPath","addLeafForCase","sq","seen","Map","subqueryFile","part","push","getOrInsertSubtree","checkCollapsible","filePathParts","subqueryTest","subqueryParams","k","v","Object","testPathParts","insertLeaf","key","parent","createSubtree","get","set","leaf","run","rec","has"],"mappings":"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","sourcesContent":["import { TestFileLoader } from './file_loader.js';\nimport { TestCaseRecorder } from './logging/test_case_recorder.js';\nimport { CaseParamsRW } from './params_utils.js';\nimport { compareQueries, Ordering } from './query/compare.js';\nimport {\n  TestQuery,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n} from './query/query.js';\nimport { stringifySingleParam } from './query/stringify_params.js';\nimport { RunCase, RunFn } from './test_group.js';\nimport { assert } from './util/util.js';\n\n// `loadTreeForQuery()` loads a TestTree for a given queryToLoad.\n// The resulting tree is a linked-list all the way from `suite:*` to queryToLoad,\n// and under queryToLoad is a tree containing every case matched by queryToLoad.\n//\n// `subqueriesToExpand` influences the `collapsible` flag on nodes in the resulting tree.\n// A node is considered \"collapsible\" if none of the subqueriesToExpand is a StrictSubset\n// of that node.\n//\n// In WebKit/Blink-style web_tests, an expectation file marks individual cts.html \"variants\" as\n// \"Failure\", \"Crash\", etc.\n// By passing in the list of expectations as the subqueriesToExpand, we can programmatically\n// subdivide the cts.html \"variants\" list to be able to implement arbitrarily-fine suppressions\n// (instead of having to suppress entire test files, which would lose a lot of coverage).\n//\n// `iterateCollapsedQueries()` produces the list of queries for the variants list.\n//\n// Though somewhat complicated, this system has important benefits:\n//   - Avoids having to suppress entire test files, which would cause large test coverage loss.\n//   - Minimizes the number of page loads needed for fine-grained suppressions.\n//     (In the naive case, we could do one page load per test case - but the test suite would\n//     take impossibly long to run.)\n//   - Enables developers to put any number of tests in one file as appropriate, without worrying\n//     about expectation granularity.\n\nexport interface TestSubtree<T extends TestQuery = TestQuery> {\n  readonly query: T;\n  readonly children: Map<string, TestTreeNode>;\n  readonly collapsible: boolean;\n  description?: string;\n}\n\nexport interface TestTreeLeaf {\n  readonly query: TestQuerySingleCase;\n  readonly run: RunFn;\n}\n\nexport type TestTreeNode = TestSubtree | TestTreeLeaf;\n\nexport class TestTree {\n  readonly root: TestSubtree;\n\n  constructor(root: TestSubtree) {\n    this.root = root;\n  }\n\n  iterateCollapsedQueries(): IterableIterator<TestQuery> {\n    return TestTree.iterateSubtreeCollapsedQueries(this.root);\n  }\n\n  iterateLeaves(): IterableIterator<TestTreeLeaf> {\n    return TestTree.iterateSubtreeLeaves(this.root);\n  }\n\n  toString(): string {\n    return TestTree.subtreeToString('(root)', this.root, '');\n  }\n\n  static *iterateSubtreeCollapsedQueries(subtree: TestSubtree): IterableIterator<TestQuery> {\n    for (const [, child] of subtree.children) {\n      if ('children' in child && !child.collapsible) {\n        yield* TestTree.iterateSubtreeCollapsedQueries(child);\n      } else {\n        yield child.query;\n      }\n    }\n  }\n\n  static *iterateSubtreeLeaves(subtree: TestSubtree): IterableIterator<TestTreeLeaf> {\n    for (const [, child] of subtree.children) {\n      if ('children' in child) {\n        yield* TestTree.iterateSubtreeLeaves(child);\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  static subtreeToString(name: string, tree: TestTreeNode, indent: string): string {\n    const collapsible = 'run' in tree ? '>' : tree.collapsible ? '+' : '-';\n    let s =\n      indent +\n      `${collapsible} ${JSON.stringify(name)} => ` +\n      `${tree.query}        ${JSON.stringify(tree.query)}`;\n    if ('children' in tree) {\n      if (tree.description !== undefined) {\n        s += indent + `\\n    | ${JSON.stringify(tree.description)}`;\n      }\n\n      for (const [name, child] of tree.children) {\n        s += '\\n' + TestTree.subtreeToString(name, child, indent + '  ');\n      }\n    }\n    return s;\n  }\n}\n\n// TODO: Consider having subqueriesToExpand actually impact the depth-order of params in the tree.\nexport async function loadTreeForQuery(\n  loader: TestFileLoader,\n  queryToLoad: TestQuery,\n  subqueriesToExpand: TestQuery[]\n): Promise<TestTree> {\n  const suite = queryToLoad.suite;\n  const specs = await loader.listing(suite);\n\n  const subqueriesToExpandEntries = Array.from(subqueriesToExpand.entries());\n  const seenSubqueriesToExpand: boolean[] = new Array(subqueriesToExpand.length);\n  seenSubqueriesToExpand.fill(false);\n\n  const isCollapsible = (subquery: TestQuery) =>\n    subqueriesToExpandEntries.every(([i, toExpand]) => {\n      const ordering = compareQueries(toExpand, subquery);\n\n      // If toExpand == subquery, no expansion is needed (but it's still \"seen\").\n      if (ordering === Ordering.Equal) seenSubqueriesToExpand[i] = true;\n      return ordering !== Ordering.StrictSubset;\n    });\n\n  // L0 = suite-level, e.g. suite:*\n  // L1 =  file-level, e.g. suite:a,b:*\n  // L2 =  test-level, e.g. suite:a,b:c,d:*\n  // L3 =  case-level, e.g. suite:a,b:c,d:\n  let foundCase = false;\n  // L0 is suite:*\n  const subtreeL0 = makeTreeForSuite(suite);\n  isCollapsible(subtreeL0.query); // mark seenSubqueriesToExpand\n  for (const entry of specs) {\n    if (entry.file.length === 0 && 'readme' in entry) {\n      // Suite-level readme.\n      assert(subtreeL0.description === undefined);\n      subtreeL0.description = entry.readme.trim();\n      continue;\n    }\n\n    {\n      const queryL1 = new TestQueryMultiFile(suite, entry.file);\n      const orderingL1 = compareQueries(queryL1, queryToLoad);\n      if (orderingL1 === Ordering.Unordered) {\n        // File path is not matched by this query.\n        continue;\n      }\n    }\n\n    if ('readme' in entry) {\n      // Entry is a README that is an ancestor or descendant of the query.\n      // (It's included for display in the standalone runner.)\n\n      // readmeSubtree is suite:a,b,*\n      // (This is always going to dedup with a file path, if there are any test spec files under\n      // the directory that has the README).\n      const readmeSubtree: TestSubtree<TestQueryMultiFile> = addSubtreeForDirPath(\n        subtreeL0,\n        entry.file\n      );\n      assert(readmeSubtree.description === undefined);\n      readmeSubtree.description = entry.readme.trim();\n      continue;\n    }\n    // Entry is a spec file.\n\n    const spec = await loader.importSpecFile(queryToLoad.suite, entry.file);\n    const description = spec.description.trim();\n    // subtreeL1 is suite:a,b:*\n    const subtreeL1: TestSubtree<TestQueryMultiTest> = addSubtreeForFilePath(\n      subtreeL0,\n      entry.file,\n      description,\n      isCollapsible\n    );\n\n    // TODO: If tree generation gets too slow, avoid actually iterating the cases in a file\n    // if there's no need to (based on the subqueriesToExpand).\n    for (const t of spec.g.iterate()) {\n      {\n        const queryL3 = new TestQuerySingleCase(suite, entry.file, t.id.test, t.id.params);\n        const orderingL3 = compareQueries(queryL3, queryToLoad);\n        if (orderingL3 === Ordering.Unordered || orderingL3 === Ordering.StrictSuperset) {\n          // Case is not matched by this query.\n          continue;\n        }\n      }\n\n      // subtreeL2 is suite:a,b:c,d:*\n      const subtreeL2: TestSubtree<TestQueryMultiCase> = addSubtreeForTestPath(\n        subtreeL1,\n        t.id.test,\n        isCollapsible\n      );\n\n      // Leaf for case is suite:a,b:c,d:x=1;y=2\n      addLeafForCase(subtreeL2, t, isCollapsible);\n\n      foundCase = true;\n    }\n  }\n  const tree = new TestTree(subtreeL0);\n\n  for (const [i, sq] of subqueriesToExpandEntries) {\n    const seen = seenSubqueriesToExpand[i];\n    assert(\n      seen,\n      `subqueriesToExpand entry did not match anything \\\n(can happen due to overlap with another subquery): ${sq.toString()}`\n    );\n  }\n  assert(foundCase, 'Query does not match any cases');\n\n  // TODO: Contains lots of single-child subtrees. Consider cleaning those up (as postprocess?).\n  return tree;\n}\n\nfunction makeTreeForSuite(suite: string): TestSubtree<TestQueryMultiFile> {\n  return {\n    query: new TestQueryMultiFile(suite, []),\n    children: new Map(),\n    collapsible: false,\n  };\n}\n\nfunction addSubtreeForDirPath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[]\n): TestSubtree<TestQueryMultiFile> {\n  const subqueryFile: string[] = [];\n  // To start, tree is suite:*\n  // This loop goes from that -> suite:a,* -> suite:a,b,*\n  for (const part of file) {\n    subqueryFile.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiFile(tree.query.suite, subqueryFile);\n      return { query, collapsible: false };\n    });\n  }\n  return tree;\n}\n\nfunction addSubtreeForFilePath(\n  tree: TestSubtree<TestQueryMultiFile>,\n  file: string[],\n  description: string,\n  checkCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiTest> {\n  // To start, tree is suite:*\n  // This goes from that -> suite:a,* -> suite:a,b,*\n  tree = addSubtreeForDirPath(tree, file);\n  // This goes from that -> suite:a,b:*\n  const subtree = getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiTest(tree.query.suite, tree.query.filePathParts, []);\n    return { query, description, collapsible: checkCollapsible(query) };\n  });\n  return subtree;\n}\n\nfunction addSubtreeForTestPath(\n  tree: TestSubtree<TestQueryMultiTest>,\n  test: readonly string[],\n  isCollapsible: (sq: TestQuery) => boolean\n): TestSubtree<TestQueryMultiCase> {\n  const subqueryTest: string[] = [];\n  // To start, tree is suite:a,b:*\n  // This loop goes from that -> suite:a,b:c,* -> suite:a,b:c,d,*\n  for (const part of test) {\n    subqueryTest.push(part);\n    tree = getOrInsertSubtree(part, tree, () => {\n      const query = new TestQueryMultiTest(\n        tree.query.suite,\n        tree.query.filePathParts,\n        subqueryTest\n      );\n      return { query, collapsible: isCollapsible(query) };\n    });\n  }\n  // This goes from that -> suite:a,b:c,d:*\n  return getOrInsertSubtree('', tree, () => {\n    const query = new TestQueryMultiCase(\n      tree.query.suite,\n      tree.query.filePathParts,\n      subqueryTest,\n      {}\n    );\n    return { query, collapsible: isCollapsible(query) };\n  });\n}\n\nfunction addLeafForCase(\n  tree: TestSubtree<TestQueryMultiTest>,\n  t: RunCase,\n  checkCollapsible: (sq: TestQuery) => boolean\n): void {\n  const query = tree.query;\n  let name: string = '';\n  const subqueryParams: CaseParamsRW = {};\n\n  // To start, tree is suite:a,b:c,d:*\n  // This loop goes from that -> suite:a,b:c,d:x=1;* -> suite:a,b:c,d:x=1;y=2;*\n  for (const [k, v] of Object.entries(t.id.params)) {\n    name = stringifySingleParam(k, v);\n    subqueryParams[k] = v;\n\n    tree = getOrInsertSubtree(name, tree, () => {\n      const subquery = new TestQueryMultiCase(\n        query.suite,\n        query.filePathParts,\n        query.testPathParts,\n        subqueryParams\n      );\n      return { query: subquery, collapsible: checkCollapsible(subquery) };\n    });\n  }\n\n  // This goes from that -> suite:a,b:c,d:x=1;y=2\n  const subquery = new TestQuerySingleCase(\n    query.suite,\n    query.filePathParts,\n    query.testPathParts,\n    subqueryParams\n  );\n  checkCollapsible(subquery); // mark seenSubqueriesToExpand\n  insertLeaf(tree, subquery, t);\n}\n\nfunction getOrInsertSubtree<T extends TestQuery>(\n  key: string,\n  parent: TestSubtree,\n  createSubtree: () => Omit<TestSubtree<T>, 'children'>\n): TestSubtree<T> {\n  let v: TestSubtree<T>;\n  const child = parent.children.get(key);\n  if (child !== undefined) {\n    assert('children' in child); // Make sure cached subtree is not actually a leaf\n    v = child as TestSubtree<T>;\n  } else {\n    v = { ...createSubtree(), children: new Map() };\n    parent.children.set(key, v);\n  }\n  return v;\n}\n\nfunction insertLeaf(parent: TestSubtree, query: TestQuerySingleCase, t: RunCase) {\n  const key = '';\n  const leaf: TestTreeLeaf = {\n    query,\n    run: (rec: TestCaseRecorder) => t.run(rec),\n  };\n  assert(!parent.children.has(key));\n  parent.children.set(key, leaf);\n}\n"],"file":"tree.js"}