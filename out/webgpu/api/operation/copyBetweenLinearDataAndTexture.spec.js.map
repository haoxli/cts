{"version":3,"sources":["../../../../src/webgpu/api/operation/copyBetweenLinearDataAndTexture.spec.ts"],"names":["description","params","poptions","makeTestGroup","assert","unreachable","kSizedTextureFormatInfo","kSizedTextureFormats","GPUTest","align","bytesInACompleteRow","dataBytesForCopy","getTextureCopyLayout","kMethodsToTest","initMethod","checkMethod","CopyBetweenLinearDataAndTextureTest","getTexelOffsetInBytes","textureDataLayout","format","texel","origin","x","y","z","offset","bytesPerRow","rowsPerImage","info","blockHeight","blockWidth","bytesPerImage","bytesPerBlock","iterateBlockRows","size","width","height","depth","generateData","byteSize","start","arr","Uint8Array","i","undefDataLayoutIfNeeded","changeBeforePass","undefined","undefOrArrayCopyViewIfNeeded","texture","origin_x","origin_y","origin_z","mipLevel","arrayCopySizeIfNeeded","copyTextureToBufferWithAppliedArguments","buffer","appliedCopyView","appliedDataLayout","appliedCheckSize","encoder","device","createCommandEncoder","copyTextureToBuffer","queue","submit","finish","uploadLinearTextureDataToTextureSubBox","textureCopyView","copySize","partialData","method","appliedCopySize","writeTexture","createBuffer","mappedAtCreation","byteLength","usage","GPUBufferUsage","COPY_SRC","getMappedRange","set","unmap","copyBufferToTexture","copyPartialTextureToBufferAndCheckContents","checkSize","expected","expectedDataLayout","bufferSize","bufferData","COPY_DST","updateLinearTextureDataSubBox","expectContents","copyWholeTextureToNewBuffer","resultDataLayout","mipSize","copyFromArrayToArray","src","srcOffset","dst","dstOffset","subarray","sourceDataLayout","destination","source","sourceOffset","destinationOffset","rowLength","copyWholeTextureToBufferAndCheckContentsWithUpdatedData","fullTextureCopyLayout","texturePartialDataLayout","fullData","begin","end","createAlignedCopyForMapRead","eventualAsyncExpectation","mapAsync","GPUMapMode","READ","actual","destroy","uploadTextureAndVerifyCopy","dataSize","textureSize","dimension","createTexture","mipLevelCount","GPUTextureUsage","data","formatCanBeTested","copyDst","copySrc","g","test","cases","combine","filter","subcases","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","copyHeightInBlocks","copyDepth","fn","t","selectDeviceOrSkipTestCase","extension","bytesPerRowAlignment","copyWidth","copyHeight","minDataSize","valid","Math","max","offsetInBlocks","dataPaddingInBytes","unless","p","copySizeValueInBlocks","originValueInBlocks","textureSizePaddingValueInBlocks","coordinateToTest","generateTestTextureSizes","_mipSizeInBlocks","widthAtThisLevel","heightAtThisLevel","widthAtPrevLevel","heightAtPrevLevel","modifiedWidth","modifiedHeight","modifyWidth","modifyHeight","copySizeInBlocks","originInBlocks","expand"],"mappings":"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","sourcesContent":["export const description = `writeTexture + copyBufferToTexture + copyTextureToBuffer operation tests.\n\n* copy_with_various_rows_per_image_and_bytes_per_row: test that copying data with various bytesPerRow (including { ==, > } bytesInACompleteRow) and\\\n rowsPerImage (including { ==, > } copyExtent.height) values and minimum required bytes in copy works for every format. Also covers special code paths:\n  - bufferSize - offset < bytesPerImage * copyExtent.depth\n  - when bytesPerRow is not a multiple of 512 and copyExtent.depth > 1: copyExtent.depth % 2 == { 0, 1 }\n  - bytesPerRow == bytesInACompleteCopyImage\n\n* copy_with_various_offsets_and_data_sizes: test that copying data with various offset (including { ==, > } 0 and is/isn't power of 2) values and additional\\\n data paddings works for every format with 2d and 2d-array textures. Also covers special code paths:\n  - offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n  - offset > bytesInACompleteCopyImage\n\n* copy_with_various_origins_and_copy_extents: test that copying slices of a texture works with various origin (including { origin.x, origin.y, origin.z }\\\n { ==, > } 0 and is/isn't power of 2) and copyExtent (including { copyExtent.x, copyExtent.y, copyExtent.z } { ==, > } 0 and is/isn't power of 2) values\\\n (also including {origin._ + copyExtent._ { ==, < } the subresource size of textureCopyView) works for all formats. origin and copyExtent values are passed\\\n as [number, number, number] instead of GPUExtent3DDict.\n\n* copy_various_mip_levels: test that copying various mip levels works for all formats. Also covers special code paths:\n  - the physical size of the subresouce is not equal to the logical size\n  - bufferSize - offset < bytesPerImage * copyExtent.depth and copyExtent needs to be clamped\n\n* copy_with_no_image_or_slice_padding_and_undefined_values: test that when copying a single row we can set any bytesPerRow value and when copying a single\\\n slice we can set rowsPerImage to 0. Also test setting offset, rowsPerImage, mipLevel, origin, origin.{x,y,z} to undefined.\n\n* TODO:\n  - add another initMethod which renders the texture\n  - test copyT2B with buffer size not divisible by 4 (not done because expectContents 4-byte alignment)\n  - add tests for 1d / 3d textures\n`;\n\nimport { params, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../common/framework/util/util.js';\nimport {\n  kSizedTextureFormatInfo,\n  SizedTextureFormat,\n  kSizedTextureFormats,\n} from '../../capability_info.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { align } from '../../util/math.js';\nimport { bytesInACompleteRow, dataBytesForCopy } from '../../util/texture/image_copy.js';\nimport { getTextureCopyLayout, TextureCopyLayout } from '../../util/texture/layout.js';\n\ninterface TextureCopyViewWithRequiredOrigin {\n  texture: GPUTexture;\n  mipLevel: number | undefined;\n  origin: Required<GPUOrigin3DDict>;\n}\n\n/** Describes the function used to copy the initial data into the texture. */\ntype InitMethod = 'WriteTexture' | 'CopyB2T';\n/**\n * - PartialCopyT2B: do CopyT2B to check that the part of the texture we copied to with InitMethod\n *   matches the data we were copying and that we don't overwrite any data in the target buffer that\n *   we're not supposed to - that's primarily for testing CopyT2B functionality.\n * - FullCopyT2B: do CopyT2B on the whole texture and check wether the part we copied to matches\n *   the data we were copying and that the nothing else was modified - that's primarily for testing\n *   WriteTexture and CopyB2T.\n */\ntype CheckMethod = 'PartialCopyT2B' | 'FullCopyT2B';\n\n/**\n * This describes in what form the arguments will be passed to WriteTexture/CopyB2T/CopyT2B. If\n * undefined, then default values are passed as undefined instead of default values. If arrays, then\n * `GPUOrigin3D` and `GPUExtent3D` are passed as `[number, number, number]`. *\n */\ntype ChangeBeforePass = 'none' | 'undefined' | 'arrays';\n\n/** Each combination of methods assume that the ones before it were tested and work correctly. */\nconst kMethodsToTest = [\n  // We make sure that CopyT2B works when copying the whole texture for renderable formats:\n  // TODO\n  // Then we make sure that WriteTexture works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyB2T works for all formats:\n  { initMethod: 'CopyB2T', checkMethod: 'FullCopyT2B' },\n  // Then we make sure that CopyT2B works for all formats:\n  { initMethod: 'WriteTexture', checkMethod: 'PartialCopyT2B' },\n] as const;\n\nclass CopyBetweenLinearDataAndTextureTest extends GPUTest {\n  /** Offset for a particular texel in the linear texture data */\n  getTexelOffsetInBytes(\n    textureDataLayout: Required<GPUTextureDataLayout>,\n    format: SizedTextureFormat,\n    texel: Required<GPUOrigin3DDict>,\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n  ): number {\n    const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n    const info = kSizedTextureFormatInfo[format];\n\n    assert(texel.x >= origin.x && texel.y >= origin.y && texel.z >= origin.z);\n    assert(rowsPerImage % info.blockHeight === 0);\n    assert(texel.x % info.blockWidth === 0);\n    assert(texel.y % info.blockHeight === 0);\n    assert(origin.x % info.blockWidth === 0);\n    assert(origin.y % info.blockHeight === 0);\n\n    const bytesPerImage = (rowsPerImage / info.blockHeight) * bytesPerRow;\n\n    return (\n      offset +\n      (texel.z - origin.z) * bytesPerImage +\n      ((texel.y - origin.y) / info.blockHeight) * bytesPerRow +\n      ((texel.x - origin.x) / info.blockWidth) * info.bytesPerBlock\n    );\n  }\n\n  *iterateBlockRows(\n    size: GPUExtent3DDict,\n    origin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat\n  ): Generator<Required<GPUOrigin3DDict>> {\n    if (size.width === 0 || size.height === 0 || size.depth === 0) {\n      // do not iterate anything for an empty region\n      return;\n    }\n    const info = kSizedTextureFormatInfo[format];\n    assert(size.height % info.blockHeight === 0);\n    for (let y = 0; y < size.height / info.blockHeight; ++y) {\n      for (let z = 0; z < size.depth; ++z) {\n        yield {\n          x: origin.x,\n          y: origin.y + y * info.blockHeight,\n          z: origin.z + z,\n        };\n      }\n    }\n  }\n\n  generateData(byteSize: number, start: number = 0): Uint8Array {\n    const arr = new Uint8Array(byteSize);\n    for (let i = 0; i < byteSize; ++i) {\n      arr[i] = (i ** 3 + i + start) % 251;\n    }\n    return arr;\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUTextureDataLayout` instead of actual\n   * values where possible. Passing arguments as values and not as objects so that they are passed\n   * by copy and not by reference.\n   */\n  undefDataLayoutIfNeeded(\n    offset: number | undefined,\n    rowsPerImage: number | undefined,\n    bytesPerRow: number,\n    changeBeforePass: ChangeBeforePass\n  ): GPUTextureDataLayout {\n    if (changeBeforePass === 'undefined') {\n      if (offset === 0) {\n        offset = undefined;\n      }\n      if (rowsPerImage === 0) {\n        rowsPerImage = undefined;\n      }\n    }\n    return { offset, bytesPerRow, rowsPerImage };\n  }\n\n  /**\n   * This is used for testing passing undefined members of `GPUTextureCopyView` instead of actual\n   * values where possible and also for testing passing the origin as `[number, number, number]`.\n   * Passing arguments as values and not as objects so that they are passed by copy and not by\n   * reference.\n   */\n  undefOrArrayCopyViewIfNeeded(\n    texture: GPUTexture,\n    origin_x: number | undefined,\n    origin_y: number | undefined,\n    origin_z: number | undefined,\n    mipLevel: number | undefined,\n    changeBeforePass: ChangeBeforePass\n  ): GPUTextureCopyView {\n    let origin: GPUOrigin3D | undefined = { x: origin_x, y: origin_y, z: origin_z };\n\n    if (changeBeforePass === 'undefined') {\n      if (origin_x === 0 && origin_y === 0 && origin_z === 0) {\n        origin = undefined;\n      } else {\n        if (origin_x === 0) {\n          origin_x = undefined;\n        }\n        if (origin_y === 0) {\n          origin_y = undefined;\n        }\n        if (origin_z === 0) {\n          origin_z = undefined;\n        }\n        origin = { x: origin_x, y: origin_y, z: origin_z };\n      }\n\n      if (mipLevel === 0) {\n        mipLevel = undefined;\n      }\n    }\n\n    if (changeBeforePass === 'arrays') {\n      origin = [origin_x!, origin_y!, origin_z!];\n    }\n\n    return { texture, origin, mipLevel };\n  }\n\n  /**\n   * This is used for testing passing `GPUExtent3D` as `[number, number, number]` instead of\n   * `GPUExtent3DDict`. Passing arguments as values and not as objects so that they are passed by\n   * copy and not by reference.\n   */\n  arrayCopySizeIfNeeded(\n    width: number,\n    height: number,\n    depth: number,\n    changeBeforePass: ChangeBeforePass\n  ): GPUExtent3D {\n    if (changeBeforePass === 'arrays') {\n      return [width, height, depth];\n    } else {\n      return { width, height, depth };\n    }\n  }\n\n  /** Run a CopyT2B command with appropriate arguments corresponding to `ChangeBeforePass` */\n  copyTextureToBufferWithAppliedArguments(\n    buffer: GPUBuffer,\n    { offset, rowsPerImage, bytesPerRow }: Required<GPUTextureDataLayout>,\n    { width, height, depth }: GPUExtent3DDict,\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { x, y, z } = origin;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCheckSize = this.arrayCopySizeIfNeeded(width, height, depth, changeBeforePass);\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      appliedCopyView,\n      { buffer, ...appliedDataLayout },\n      appliedCheckSize\n    );\n    this.device.queue.submit([encoder.finish()]);\n  }\n\n  /** Put data into a part of the texture with an appropriate method. */\n  uploadLinearTextureDataToTextureSubBox(\n    textureCopyView: TextureCopyViewWithRequiredOrigin,\n    textureDataLayout: GPUImageDataLayout & { bytesPerRow: number },\n    copySize: GPUExtent3DDict,\n    partialData: Uint8Array,\n    method: InitMethod,\n    changeBeforePass: ChangeBeforePass\n  ): void {\n    const { texture, mipLevel, origin } = textureCopyView;\n    const { offset, rowsPerImage, bytesPerRow } = textureDataLayout;\n    const { x, y, z } = origin;\n    const { width, height, depth } = copySize;\n\n    const appliedCopyView = this.undefOrArrayCopyViewIfNeeded(\n      texture,\n      x,\n      y,\n      z,\n      mipLevel,\n      changeBeforePass\n    );\n    const appliedDataLayout = this.undefDataLayoutIfNeeded(\n      offset,\n      rowsPerImage,\n      bytesPerRow,\n      changeBeforePass\n    );\n    const appliedCopySize = this.arrayCopySizeIfNeeded(width, height, depth, changeBeforePass);\n\n    switch (method) {\n      case 'WriteTexture': {\n        this.device.queue.writeTexture(\n          appliedCopyView,\n          partialData,\n          appliedDataLayout,\n          appliedCopySize\n        );\n\n        break;\n      }\n      case 'CopyB2T': {\n        const buffer = this.device.createBuffer({\n          mappedAtCreation: true,\n          size: align(partialData.byteLength, 4),\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n        new Uint8Array(buffer.getMappedRange()).set(partialData);\n        buffer.unmap();\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture(\n          { buffer, ...appliedDataLayout },\n          appliedCopyView,\n          appliedCopySize\n        );\n        this.device.queue.submit([encoder.finish()]);\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  /**\n   * We check an appropriate part of the texture against the given data.\n   * Used directly with PartialCopyT2B check method (for a subpart of the texture)\n   * and by `copyWholeTextureToBufferAndCheckContentsWithUpdatedData` with FullCopyT2B check method\n   * (for the whole texture). We also ensure that CopyT2B doesn't overwrite bytes it's not supposed\n   * to if validateOtherBytesInBuffer is set to true.\n   */\n  copyPartialTextureToBufferAndCheckContents(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    checkSize: GPUExtent3DDict,\n    format: SizedTextureFormat,\n    expected: Uint8Array,\n    expectedDataLayout: Required<GPUTextureDataLayout>,\n    changeBeforePass: ChangeBeforePass = 'none'\n  ): void {\n    // The alignment is necessary because we need to copy and map data from this buffer.\n    const bufferSize = align(expected.byteLength, 4);\n    // The start value ensures generated data here doesn't match the expected data.\n    const bufferData = this.generateData(bufferSize, 17);\n\n    const buffer = this.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    new Uint8Array(buffer.getMappedRange()).set(bufferData);\n    buffer.unmap();\n\n    this.copyTextureToBufferWithAppliedArguments(\n      buffer,\n      expectedDataLayout,\n      checkSize,\n      { texture, mipLevel, origin },\n      changeBeforePass\n    );\n\n    this.updateLinearTextureDataSubBox(\n      expectedDataLayout,\n      expectedDataLayout,\n      checkSize,\n      origin,\n      format,\n      bufferData,\n      expected\n    );\n\n    this.expectContents(buffer, bufferData);\n  }\n\n  /**\n   * Copies the whole texture into linear data stored in a buffer for further checks.\n   *\n   * Used for `copyWholeTextureToBufferAndCheckContentsWithUpdatedData`.\n   */\n  copyWholeTextureToNewBuffer(\n    { texture, mipLevel }: { texture: GPUTexture; mipLevel: number | undefined },\n    resultDataLayout: TextureCopyLayout\n  ): GPUBuffer {\n    const { mipSize, byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n    const buffer = this.device.createBuffer({\n      size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(\n      { texture, mipLevel },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    return buffer;\n  }\n\n  copyFromArrayToArray(\n    src: Uint8Array,\n    srcOffset: number,\n    dst: Uint8Array,\n    dstOffset: number,\n    size: number\n  ): void {\n    dst.set(src.subarray(srcOffset, srcOffset + size), dstOffset);\n  }\n\n  /**\n   * Takes the data returned by `copyWholeTextureToNewBuffer` and updates it after a copy operation\n   * on the texture by emulating the copy behaviour here directly.\n   */\n  updateLinearTextureDataSubBox(\n    { bytesPerRow, rowsPerImage }: { bytesPerRow: number; rowsPerImage: number },\n    sourceDataLayout: Required<GPUTextureDataLayout>,\n    copySize: GPUExtent3DDict,\n    origin: Required<GPUOrigin3DDict>,\n    format: SizedTextureFormat,\n    destination: Uint8Array,\n    source: Uint8Array\n  ): void {\n    for (const texel of this.iterateBlockRows(copySize, origin, format)) {\n      const sourceOffset = this.getTexelOffsetInBytes(sourceDataLayout, format, texel, origin);\n      const destinationOffset = this.getTexelOffsetInBytes(\n        { bytesPerRow, rowsPerImage, offset: 0 },\n        format,\n        texel\n      );\n      const rowLength = bytesInACompleteRow(copySize.width, format);\n      this.copyFromArrayToArray(source, sourceOffset, destination, destinationOffset, rowLength);\n    }\n  }\n\n  /**\n   * Used for checking whether the whole texture was updated correctly by\n   * `uploadLinearTextureDataToTextureSubpart`. Takes fullData returned by\n   * `copyWholeTextureToNewBuffer` before the copy operation which is the original texture data,\n   * then updates it with `updateLinearTextureDataSubpart` and checks the texture against the\n   * updated data after the copy operation.\n   */\n  copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n    { texture, mipLevel, origin }: TextureCopyViewWithRequiredOrigin,\n    fullTextureCopyLayout: TextureCopyLayout,\n    texturePartialDataLayout: Required<GPUTextureDataLayout>,\n    copySize: GPUExtent3DDict,\n    format: SizedTextureFormat,\n    fullData: GPUBuffer,\n    partialData: Uint8Array\n  ): void {\n    const { mipSize, bytesPerRow, rowsPerImage, byteLength } = fullTextureCopyLayout;\n    const { dst, begin, end } = this.createAlignedCopyForMapRead(fullData, byteLength, 0);\n\n    // We add an eventual async expectation which will update the full data and then add\n    // other eventual async expectations to ensure it will be correct.\n    this.eventualAsyncExpectation(async () => {\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new Uint8Array(dst.getMappedRange()).subarray(begin, end);\n      this.updateLinearTextureDataSubBox(\n        fullTextureCopyLayout,\n        texturePartialDataLayout,\n        copySize,\n        origin,\n        format,\n        actual,\n        partialData\n      );\n      this.copyPartialTextureToBufferAndCheckContents(\n        { texture, mipLevel, origin: { x: 0, y: 0, z: 0 } },\n        { width: mipSize[0], height: mipSize[1], depth: mipSize[2] },\n        format,\n        actual,\n        { bytesPerRow, rowsPerImage, offset: 0 }\n      );\n      dst.destroy();\n    });\n  }\n\n  /**\n   * Tests copy between linear data and texture by creating a texture, putting some data into it\n   * with WriteTexture/CopyB2T, then getting data for the whole texture/for a part of it back and\n   * comparing it with the expectation.\n   */\n  uploadTextureAndVerifyCopy({\n    textureDataLayout,\n    copySize,\n    dataSize,\n    mipLevel = 0,\n    origin = { x: 0, y: 0, z: 0 },\n    textureSize,\n    format,\n    dimension = '2d',\n    initMethod,\n    checkMethod,\n    changeBeforePass = 'none',\n  }: {\n    textureDataLayout: Required<GPUTextureDataLayout>;\n    copySize: GPUExtent3DDict;\n    dataSize: number;\n    mipLevel?: number;\n    origin?: Required<GPUOrigin3DDict>;\n    textureSize: [number, number, number];\n    format: SizedTextureFormat;\n    dimension?: GPUTextureDimension;\n    initMethod: InitMethod;\n    checkMethod: CheckMethod;\n    changeBeforePass?: ChangeBeforePass;\n  }): void {\n    const texture = this.device.createTexture({\n      size: textureSize,\n      format,\n      dimension,\n      mipLevelCount: mipLevel + 1,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const data = this.generateData(dataSize);\n\n    switch (checkMethod) {\n      case 'PartialCopyT2B': {\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyPartialTextureToBufferAndCheckContents(\n          { texture, mipLevel, origin },\n          copySize,\n          format,\n          data,\n          textureDataLayout,\n          changeBeforePass\n        );\n\n        break;\n      }\n      case 'FullCopyT2B': {\n        const fullTextureCopyLayout = getTextureCopyLayout(format, dimension, textureSize, {\n          mipLevel,\n        });\n\n        const fullData = this.copyWholeTextureToNewBuffer(\n          { texture, mipLevel },\n          fullTextureCopyLayout\n        );\n\n        this.uploadLinearTextureDataToTextureSubBox(\n          { texture, mipLevel, origin },\n          textureDataLayout,\n          copySize,\n          data,\n          initMethod,\n          changeBeforePass\n        );\n\n        this.copyWholeTextureToBufferAndCheckContentsWithUpdatedData(\n          { texture, mipLevel, origin },\n          fullTextureCopyLayout,\n          textureDataLayout,\n          copySize,\n          format,\n          fullData,\n          data\n        );\n\n        break;\n      }\n      default:\n        unreachable();\n    }\n  }\n}\n\n/**\n * This is a helper function used for filtering test parameters\n *\n * TODO: Modify this after introducing tests with rendering.\n */\nfunction formatCanBeTested({ format }: { format: SizedTextureFormat }): boolean {\n  return kSizedTextureFormatInfo[format].copyDst && kSizedTextureFormatInfo[format].copySrc;\n}\n\nexport const g = makeTestGroup(CopyBetweenLinearDataAndTextureTest);\n\n// Test that copying data with various bytesPerRow and rowsPerImage values and minimum required\n// bytes in copy works for every format.\n// Covers a special code path for Metal:\n//    bufferSize - offset < bytesPerImage * copyExtent.depth\n// Covers a special code path for D3D12:\n//    when bytesPerRow is not a multiple of 512 and copyExtent.depth > 1: copyExtent.depth % 2 == { 0, 1 }\n//    bytesPerRow == bytesInACompleteCopyImage */\ng.test('copy_with_various_rows_per_image_and_bytes_per_row')\n  .cases(\n    params()\n      .combine(kMethodsToTest)\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .subcases(() =>\n    params()\n      .combine([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combine([\n        // In the two cases below, for (WriteTexture, PartialCopyB2T) and (CopyB2T, FullCopyT2B)\n        // sets of methods we will have bytesPerRow = 256 and copyDepth % 2 == { 0, 1 }\n        // respectively. This covers a special code path for D3D12.\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 2 }, // standard copy\n\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0 }, // empty copy because of depth\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 3, copyDepth: 5 }, // copyWidth = 1\n\n        // The two cases below cover another special code path for D3D12.\n        //   - For (WriteTexture, FullCopyT2B) with r8unorm:\n        //         bytesPerRow = 15 = 3 * 5 = bytesInACompleteCopyImage.\n        { copyWidthInBlocks: 32, copyHeightInBlocks: 1, copyDepth: 8 }, // copyHeight = 1\n        //   - For (CopyB2T, FullCopyT2B) and (WriteTexture, PartialCopyT2B) with r8unorm:\n        //         bytesPerRow = 256 = 8 * 32 = bytesInACompleteCopyImage.\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1 }, // copyDepth = 1\n\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1 }, // copyHeight = 1 and copyDepth = 1\n      ])\n  )\n  .fn(async t => {\n    const {\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    // For CopyB2T and CopyT2B we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment =\n      initMethod === 'WriteTexture' && checkMethod === 'FullCopyT2B' ? 1 : 256;\n\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const copySize = { width: copyWidth, height: copyHeight, depth: copyDepth };\n\n    const { minDataSize, valid } = dataBytesForCopy(\n      { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      { method: initMethod }\n    );\n    assert(valid);\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize: minDataSize,\n      textureSize: [\n        Math.max(copyWidth, info.blockWidth),\n        Math.max(copyHeight, info.blockHeight),\n        Math.max(copyDepth, 1),\n      ] /* making sure the texture is non-empty */,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\n// Test that copying data with various offset values and additional data paddings\n// works for every format with 2d and 2d-array textures.\n// Covers two special code paths for D3D12:\n//     offset + bytesInCopyExtentPerRow { ==, > } bytesPerRow\n//     offset > bytesInACompleteCopyImage\ng.test('copy_with_various_offsets_and_data_sizes')\n  .cases(\n    params()\n      .combine(kMethodsToTest)\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .subcases(\n    () =>\n      params()\n        .combine([\n          { offsetInBlocks: 0, dataPaddingInBytes: 0 }, // no offset and no padding\n          { offsetInBlocks: 1, dataPaddingInBytes: 0 }, // offset = 1\n          { offsetInBlocks: 2, dataPaddingInBytes: 0 }, // offset = 2\n          { offsetInBlocks: 15, dataPaddingInBytes: 0 }, // offset = 15\n          { offsetInBlocks: 16, dataPaddingInBytes: 0 }, // offset = 16\n          { offsetInBlocks: 242, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 242 + 12 = 256 = bytesPerRow\n          { offsetInBlocks: 243, dataPaddingInBytes: 0 }, // for rgba8unorm format: offset + bytesInCopyExtentPerRow = 243 + 12 > 256 = bytesPerRow\n          { offsetInBlocks: 768, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 768 = 3 * 256 = bytesInACompleteCopyImage\n          { offsetInBlocks: 769, dataPaddingInBytes: 0 }, // for copyDepth = 1, blockWidth = 1 and bytesPerBlock = 1: offset = 769 > 768 = bytesInACompleteCopyImage\n          { offsetInBlocks: 0, dataPaddingInBytes: 1 }, // dataPaddingInBytes > 0\n          { offsetInBlocks: 1, dataPaddingInBytes: 8 }, // offset > 0 and dataPaddingInBytes > 0\n        ])\n        .combine(poptions('copyDepth', [1, 2])) // 2d and 2d-array textures\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      dataPaddingInBytes,\n      copyDepth,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const copySize = {\n      width: 3 * info.blockWidth,\n      height: 3 * info.blockHeight,\n      depth: copyDepth,\n    };\n    const rowsPerImage = copySize.height;\n    const bytesPerRow = 256;\n\n    const { minDataSize, valid } = dataBytesForCopy(\n      { offset, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      { method: initMethod }\n    );\n    assert(valid);\n\n    const dataSize = offset + minDataSize + dataPaddingInBytes;\n\n    // We're copying a (3 x 3 x copyDepth) (in texel blocks) part of a (4 x 4 x copyDepth)\n    // (in texel blocks) texture with no origin.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      textureSize: [4 * info.blockWidth, 4 * info.blockHeight, copyDepth],\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\n// Test that copying slices of a texture works with various origin and copyExtent values\n// for all formats. We pass origin and copyExtent as [number, number, number].\ng.test('copy_with_various_origins_and_copy_extents')\n  .cases(\n    params()\n      .combine(kMethodsToTest)\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('originValueInBlocks', [0, 7, 8]))\n      .combine(poptions('copySizeValueInBlocks', [0, 7, 8]))\n      .combine(poptions('textureSizePaddingValueInBlocks', [0, 7, 8]))\n      .unless(\n        p =>\n          // we can't create an empty texture\n          p.copySizeValueInBlocks + p.originValueInBlocks + p.textureSizePaddingValueInBlocks === 0\n      )\n      .combine(poptions('coordinateToTest', ['width', 'height', 'depth'] as const))\n  )\n  .fn(async t => {\n    const {\n      coordinateToTest,\n      originValueInBlocks,\n      copySizeValueInBlocks,\n      textureSizePaddingValueInBlocks,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    const origin: Required<GPUOrigin3DDict> = { x: info.blockWidth, y: info.blockHeight, z: 1 };\n    const copySize = { width: 2 * info.blockWidth, height: 2 * info.blockHeight, depth: 2 };\n    const textureSize: [number, number, number] = [3 * info.blockWidth, 3 * info.blockHeight, 3];\n\n    switch (coordinateToTest) {\n      case 'width': {\n        origin.x = originValueInBlocks * info.blockWidth;\n        copySize.width = copySizeValueInBlocks * info.blockWidth;\n        textureSize[0] =\n          origin.x + copySize.width + textureSizePaddingValueInBlocks * info.blockWidth;\n        break;\n      }\n      case 'height': {\n        origin.y = originValueInBlocks * info.blockHeight;\n        copySize.height = copySizeValueInBlocks * info.blockHeight;\n        textureSize[1] =\n          origin.y + copySize.height + textureSizePaddingValueInBlocks * info.blockHeight;\n        break;\n      }\n      case 'depth': {\n        origin.z = originValueInBlocks;\n        copySize.depth = copySizeValueInBlocks;\n        textureSize[2] = origin.z + copySize.depth + textureSizePaddingValueInBlocks;\n        break;\n      }\n    }\n\n    const rowsPerImage = copySize.height;\n    const bytesPerRow = align(copySize.width, 256);\n    const { minDataSize: dataSize, valid } = dataBytesForCopy(\n      { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      { method: initMethod }\n    );\n    assert(valid);\n\n    // For testing width: we copy a (_ x 2 x 2) (in texel blocks) part of a (_ x 3 x 3)\n    // (in texel blocks) texture with origin (_, 1, 1) (in texel blocks).\n    // Similarly for other coordinates.\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'arrays',\n    });\n  });\n\n/**\n * Generates textureSizes which correspond to the same physicalSizeAtMipLevel including virtual\n * sizes at mip level different from the physical ones.\n */\nfunction* generateTestTextureSizes({\n  format,\n  mipLevel,\n  _mipSizeInBlocks,\n}: {\n  format: SizedTextureFormat;\n  mipLevel: number;\n  _mipSizeInBlocks: GPUExtent3DDict;\n}): Generator<{ textureSize: [number, number, number] }> {\n  const info = kSizedTextureFormatInfo[format];\n\n  const widthAtThisLevel = _mipSizeInBlocks.width * info.blockWidth;\n  const heightAtThisLevel = _mipSizeInBlocks.height * info.blockHeight;\n  const textureSize: [number, number, number] = [\n    widthAtThisLevel << mipLevel,\n    heightAtThisLevel << mipLevel,\n    _mipSizeInBlocks.depth,\n  ];\n  yield {\n    textureSize,\n  };\n\n  // We choose width and height of the texture so that the values are divisible by blockWidth and\n  // blockHeight respectively and so that the virtual size at mip level corresponds to the same\n  // physical size.\n  // Virtual size at mip level with modified width has width = (physical size width) - (blockWidth / 2).\n  // Virtual size at mip level with modified height has height = (physical size height) - (blockHeight / 2).\n  const widthAtPrevLevel = widthAtThisLevel << 1;\n  const heightAtPrevLevel = heightAtThisLevel << 1;\n  assert(mipLevel > 0);\n  assert(widthAtPrevLevel >= info.blockWidth && heightAtPrevLevel >= info.blockHeight);\n  const modifiedWidth = (widthAtPrevLevel - info.blockWidth) << (mipLevel - 1);\n  const modifiedHeight = (heightAtPrevLevel - info.blockHeight) << (mipLevel - 1);\n\n  const modifyWidth = info.blockWidth > 1 && modifiedWidth !== textureSize[0];\n  const modifyHeight = info.blockHeight > 1 && modifiedHeight !== textureSize[1];\n\n  if (modifyWidth) {\n    yield {\n      textureSize: [modifiedWidth, textureSize[1], textureSize[2]],\n    };\n  }\n  if (modifyHeight) {\n    yield {\n      textureSize: [textureSize[0], modifiedHeight, textureSize[2]],\n    };\n  }\n  if (modifyWidth && modifyHeight) {\n    yield {\n      textureSize: [modifiedWidth, modifiedHeight, textureSize[2]],\n    };\n  }\n}\n\n// Test that copying various mip levels works.\n// Covers two special code paths:\n//   - the physical size of the subresouce is not equal to the logical size\n//   - bufferSize - offset < bytesPerImage * copyExtent.depth and copyExtent needs to be clamped for all block formats */\ng.test('copy_various_mip_levels')\n  .cases(\n    params()\n      .combine(kMethodsToTest)\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCanBeTested)\n  )\n  .subcases(p =>\n    params()\n      .combine([\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d texture */\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 1 },\n          originInBlocks: { x: 3, y: 2, z: 0 },\n          _mipSizeInBlocks: { width: 8, height: 6, depth: 1 },\n          mipLevel: 1,\n        },\n        // origin + copySize = texturePhysicalSizeAtMipLevel for all coordinates, 2d-array texture\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 8, height: 6, depth: 3 },\n          mipLevel: 2,\n        },\n        // origin.x + copySize.width = texturePhysicalSizeAtMipLevel.width\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 8, height: 7, depth: 4 },\n          mipLevel: 3,\n        },\n        // origin.y + copySize.height = texturePhysicalSizeAtMipLevel.height\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 6, depth: 4 },\n          mipLevel: 4,\n        },\n        // origin.z + copySize.depth = texturePhysicalSizeAtMipLevel.depth\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 7, depth: 3 },\n          mipLevel: 5,\n        },\n        // origin + copySize < texturePhysicalSizeAtMipLevel for all coordinates\n        {\n          copySizeInBlocks: { width: 5, height: 4, depth: 2 },\n          originInBlocks: { x: 3, y: 2, z: 1 },\n          _mipSizeInBlocks: { width: 9, height: 7, depth: 4 },\n          mipLevel: 6,\n        },\n      ])\n      .expand(({ mipLevel, _mipSizeInBlocks }) =>\n        generateTestTextureSizes({ mipLevel, _mipSizeInBlocks, format: p.format })\n      )\n  )\n  .fn(async t => {\n    const {\n      copySizeInBlocks,\n      originInBlocks,\n      textureSize,\n      mipLevel,\n      format,\n      initMethod,\n      checkMethod,\n    } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    const origin = {\n      x: originInBlocks.x * info.blockWidth,\n      y: originInBlocks.y * info.blockHeight,\n      z: originInBlocks.z,\n    };\n    const copySize = {\n      width: copySizeInBlocks.width * info.blockWidth,\n      height: copySizeInBlocks.height * info.blockHeight,\n      depth: copySizeInBlocks.depth,\n    };\n\n    const rowsPerImage = copySize.height + info.blockHeight;\n    const bytesPerRow = align(copySize.width, 256);\n    const { minDataSize: dataSize, valid } = dataBytesForCopy(\n      { offset: 0, bytesPerRow, rowsPerImage },\n      format,\n      copySize,\n      { method: initMethod }\n    );\n    assert(valid);\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize,\n      origin,\n      mipLevel,\n      textureSize,\n      format,\n      initMethod,\n      checkMethod,\n    });\n  });\n\n// Test that when copying a single row we can set any bytesPerRow value and when copying a single\n// slice we can set rowsPerImage to 0. Origin, offset, mipLevel and rowsPerImage values will be set\n// to undefined when appropriate.\ng.test('copy_with_no_image_or_slice_padding_and_undefined_values')\n  .cases(kMethodsToTest)\n  .subcases(() =>\n    params().combine([\n      // copying one row: bytesPerRow and rowsPerImage can be set to 0\n      {\n        bytesPerRow: 0,\n        rowsPerImage: 0,\n        copySize: { width: 3, height: 1, depth: 1 },\n        origin: { x: 0, y: 0, z: 0 },\n      },\n      // copying one row: bytesPerRow can be < bytesInACompleteRow = 400\n      {\n        bytesPerRow: 256,\n        rowsPerImage: 0,\n        copySize: { width: 100, height: 1, depth: 1 },\n        origin: { x: 0, y: 0, z: 0 },\n      },\n      // copying one slice: rowsPerImage = 0 will be set to undefined\n      {\n        bytesPerRow: 256,\n        rowsPerImage: 0,\n        copySize: { width: 3, height: 3, depth: 1 },\n        origin: { x: 0, y: 0, z: 0 },\n      },\n      // copying one slice: rowsPerImage = 2 is valid\n      {\n        bytesPerRow: 256,\n        rowsPerImage: 2,\n        copySize: { width: 3, height: 3, depth: 1 },\n        origin: { x: 0, y: 0, z: 0 },\n      },\n      // origin.x = 0 will be set to undefined\n      {\n        bytesPerRow: 0,\n        rowsPerImage: 0,\n        copySize: { width: 1, height: 1, depth: 1 },\n        origin: { x: 0, y: 1, z: 1 },\n      },\n      // origin.y = 0 will be set to undefined\n      {\n        bytesPerRow: 0,\n        rowsPerImage: 0,\n        copySize: { width: 1, height: 1, depth: 1 },\n        origin: { x: 1, y: 0, z: 1 },\n      },\n      // origin.z = 0 will be set to undefined\n      {\n        bytesPerRow: 0,\n        rowsPerImage: 0,\n        copySize: { width: 1, height: 1, depth: 1 },\n        origin: { x: 1, y: 1, z: 0 },\n      },\n    ])\n  )\n  .fn(async t => {\n    const { bytesPerRow, rowsPerImage, copySize, origin, initMethod, checkMethod } = t.params;\n\n    t.uploadTextureAndVerifyCopy({\n      textureDataLayout: { offset: 0, bytesPerRow, rowsPerImage },\n      copySize,\n      dataSize: 100 * 3 * 4,\n      textureSize: [100, 3, 2],\n      origin,\n      format: 'rgba8unorm',\n      initMethod,\n      checkMethod,\n      changeBeforePass: 'undefined',\n    });\n  });\n"],"file":"copyBetweenLinearDataAndTexture.spec.js"}