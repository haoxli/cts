{"version":3,"sources":["../../../../../src/webgpu/api/operation/buffers/map_oom.spec.ts"],"names":["description","poptions","params","pbool","makeTestGroup","kBufferUsages","GPUTest","MAX_ALIGNED_SAFE_INTEGER","Number","MAX_SAFE_INTEGER","oomAndSizeParams","combine","expand","oom","g","test","desc","cases","subcases","fn","t","write","size","buffer","expectGPUError","device","createBuffer","usage","GPUBufferUsage","MAP_WRITE","MAP_READ","promise","mapAsync","GPUMapMode","WRITE","READ","shouldReject","shouldThrow","getMappedRange","unmap","arraybuffer","expect","byteLength","mappedAtCreation","f","mapping","undefined"],"mappings":"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","sourcesContent":["export const description =\n  'Test out-of-memory conditions creating large mappable/mappedAtCreation buffers.';\n\nimport { poptions, params, pbool } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\n// A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n// (Note this is likely to exceed limitations other than just the system's\n// physical memory - so test cases are also needed to try to trigger \"true\" OOM.)\nconst MAX_ALIGNED_SAFE_INTEGER = Number.MAX_SAFE_INTEGER - 7;\n\nconst oomAndSizeParams = params()\n  .combine(pbool('oom'))\n  .expand(({ oom }) => {\n    if (oom) {\n      return poptions('size', [\n        MAX_ALIGNED_SAFE_INTEGER,\n        0x2000000000, // 128 GB\n      ]);\n    } else {\n      return poptions('size', [16]);\n    }\n  });\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('mapAsync')\n  .desc(\n    `Test creating a large mappable buffer should produce an out-of-memory error if allocation fails.\n  - The resulting buffer is an error buffer, so mapAsync rejects and produces a validation error.\n  - Calling getMappedRange should throw an OperationError because the buffer is not in the mapped state.\n  - unmap() throws an OperationError if mapping failed, and otherwise should detach the ArrayBuffer.\n`\n  )\n  .cases(oomAndSizeParams)\n  .subcases(() => params().combine(pbool('write')))\n  .fn(async t => {\n    const { oom, write, size } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () =>\n        t.device.createBuffer({\n          size,\n          usage: write ? GPUBufferUsage.MAP_WRITE : GPUBufferUsage.MAP_READ,\n        }),\n      oom\n    );\n    const promise = t.expectGPUError(\n      'validation', // Should be a validation error since the buffer is invalid.\n      () => buffer.mapAsync(write ? GPUMapMode.WRITE : GPUMapMode.READ),\n      oom\n    );\n\n    if (oom) {\n      // Should also reject in addition to the validation error.\n      t.shouldReject('OperationError', promise);\n\n      // Should throw an OperationError because the buffer is not mapped.\n      // Note: not a RangeError because the state of the buffer is checked first.\n      t.shouldThrow('OperationError', () => {\n        buffer.getMappedRange();\n      });\n\n      // Should throw an OperationError because the buffer is already unmapped.\n      t.shouldThrow('OperationError', () => {\n        buffer.unmap();\n      });\n    } else {\n      await promise;\n      const arraybuffer = buffer.getMappedRange();\n      t.expect(arraybuffer.byteLength === size);\n      buffer.unmap();\n      t.expect(arraybuffer.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n\ng.test('mappedAtCreation,full_getMappedRange')\n  .desc(\n    `Test creating a very large buffer mappedAtCreation buffer should produce\nan out-of-memory error if allocation fails.\n  - Because the buffer can be immediately mapped, getMappedRange does not throw an OperationError. It throws a RangeError because such a\n    large ArrayBuffer cannot be created.\n  - unmap() should not throw.\n  `\n  )\n  .cases(oomAndSizeParams)\n  .subcases(() => params().combine(poptions('usage', kBufferUsages)))\n  .fn(async t => {\n    const { oom, usage, size } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () => t.device.createBuffer({ mappedAtCreation: true, size, usage }),\n      oom\n    );\n\n    const f = () => buffer.getMappedRange();\n\n    let mapping: ArrayBuffer | undefined = undefined;\n    if (oom) {\n      t.shouldThrow('RangeError', f);\n    } else {\n      mapping = f();\n    }\n    buffer.unmap();\n    if (mapping !== undefined) {\n      t.expect(mapping.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n\ng.test('mappedAtCreation,smaller_getMappedRange')\n  .desc(\n    `Test creating a very large mappedAtCreation buffer should produce\nan out-of-memory error if allocation fails.\n  - Because the buffer can be immediately mapped, getMappedRange does not throw an OperationError. Calling it on a small range of the buffer successfully returns an ArrayBuffer.\n  - unmap() should detach the ArrayBuffer.\n  `\n  )\n  .cases(oomAndSizeParams)\n  .subcases(() => poptions('usage', kBufferUsages))\n  .fn(async t => {\n    const { usage, size } = t.params;\n\n    const buffer = t.expectGPUError('out-of-memory', () =>\n      t.device.createBuffer({ mappedAtCreation: true, size, usage })\n    );\n\n    // Smaller range inside a too-big mapping\n    const mapping = buffer.getMappedRange(0, 16);\n    t.expect(mapping.byteLength === 16);\n    buffer.unmap();\n    t.expect(mapping.byteLength === 0, 'Mapping should be detached');\n  });\n"],"file":"map_oom.spec.js"}