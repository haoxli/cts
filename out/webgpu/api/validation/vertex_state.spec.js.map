{"version":3,"sources":["../../../../src/webgpu/api/validation/vertex_state.spec.ts"],"names":["description","params","pbool","poptions","makeTestGroup","ValidationTest","MAX_VERTEX_ATTRIBUTES","MAX_VERTEX_BUFFER_END","MAX_VERTEX_BUFFER_ARRAY_STRIDE","MAX_VERTEX_BUFFERS","SIZEOF_FLOAT","Float32Array","BYTES_PER_ELEMENT","VERTEX_SHADER_CODE_WITH_NO_INPUT","clone","descriptor","JSON","parse","stringify","F","getDescriptor","vertexState","vertexShaderCode","vertexStage","module","device","createShaderModule","code","entryPoint","fragmentStage","primitiveTopology","colorStates","format","testVertexState","success","vertexShader","expectValidationError","createRenderPipeline","g","test","desc","subcases","combine","fn","t","count","lastEmpty","vertexBuffers","i","push","attributes","arrayStride","offset","shaderLocation","attribCount","attribsPerBuffer","attribsAdded","targetCount","Math","min","length","vertexBufferIndex","extraAttributes","testShaderLocation","testAttributeAtStart","currentLocation","testAttribute","unshift","badVertexState","goodVertexState","overlappingVertexState","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["export const description = `\nvertexState validation tests.\n\nTODO: implement the combinations tests below.\n\nTODO Test location= declarations in the shader.\n\nTest each declaration in the shader must have an attribute with that shaderLocation:\n - For each shaderLocation TBD:\n  - For buffersIndex = 0 1, limit-1\n   - For attribute index = 0, 1, 4\n    - Create a vertexState with/without the attribute with that shader location at buffer[bufferIndex].attribs[attribIndex]\n     - Check error IFF vertexState doesn't have the shaderLocation\n\nTest each declaration must have a format compatible with the attribute:\n - For each vertex format\n  - For each type of shader declaration\n   - Check error IFF shader declaration not compatible with the attribute's format.\n\nOne-off test that many attributes can overlap.\n\nAll tests below are for a vertex buffer index 0, 1, limit-1.\n\nTest the shaderLocation must be unique:\n - For attribute 0, 1, limit - 1.\n  - For target attribute value 0, 1, limit -1, limit.\n\nTest check that the end attribute must be contained in the stride:\n - For stride = 0 (special case), 4, 128, limit\n   - For each vertex format\n    - For offset stride, stride - componentsize(format), stride - sizeof(format), stride - sizeof(format) + componentsize(format), 0, 2^32 - componentsize(format), 2^32, 2**60\n      - Check error IFF offset + sizeof(format) > stride (or 2048 for 0)\n\nTest that an attribute must be aligned to the component size:\n - For each vertex format\n  - For stride = 2*sizeof(format), 128, limit\n    - For offset = componentsize(format), componentsize(format) / 2, stride - sizeof(format) - componentsize(format), stride - sizeof(format)\n     - Check error IFF offset not aligned to componentsize(format);\n`;\n\nimport { params, pbool, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nconst MAX_VERTEX_ATTRIBUTES: number = 16;\nconst MAX_VERTEX_BUFFER_END: number = 2048;\nconst MAX_VERTEX_BUFFER_ARRAY_STRIDE: number = 2048;\nconst MAX_VERTEX_BUFFERS: number = 8;\n\nconst SIZEOF_FLOAT = Float32Array.BYTES_PER_ELEMENT;\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  [[builtin(position)]] var<out> Position : vec4<f32>;\n  [[stage(vertex)]] fn main() -> void {\n    Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction clone<T extends GPUVertexStateDescriptor>(descriptor: T): T {\n  return JSON.parse(JSON.stringify(descriptor));\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    vertexState: GPUVertexStateDescriptor,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      vertexStage: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor : vec4<f32>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      primitiveTopology: 'triangle-list',\n      colorStates: [{ format: 'rgba8unorm' }],\n      vertexState,\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    vertexState: GPUVertexStateDescriptor,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        vertexState,\n        vertexStage: {\n          module: this.device.createShaderModule({ code: vertexShader }),\n          entryPoint: 'main',\n        },\n        fragmentStage: {\n          module: this.device.createShaderModule({\n            code: `\n            [[location(0)]] var<out> fragColor : vec4<f32>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n          }),\n          entryPoint: 'main',\n        },\n        primitiveTopology: 'triangle-list',\n        colorStates: [{ format: 'rgba8unorm' }],\n      });\n    }, !success);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('count', [0, 1, MAX_VERTEX_BUFFERS, MAX_VERTEX_BUFFERS + 1]))\n      .combine(pbool('lastEmpty'))\n  )\n  .fn(t => {\n    const { count, lastEmpty } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        });\n      }\n    }\n\n    const success = count <= MAX_VERTEX_BUFFERS;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attributes.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('attribCount', [0, 1, MAX_VERTEX_ATTRIBUTES, MAX_VERTEX_ATTRIBUTES + 1]))\n      .combine(poptions('attribsPerBuffer', [0, 1, 4]))\n  )\n  .fn(t => {\n    const { attribCount, attribsPerBuffer } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === MAX_VERTEX_BUFFERS - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes: GPUVertexAttributeDescriptor[] = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float', offset: 0, shaderLocation: attribsAdded });\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= MAX_VERTEX_ATTRIBUTES;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, MAX_VERTEX_BUFFERS - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          4,\n          256,\n          MAX_VERTEX_BUFFER_ARRAY_STRIDE - 4,\n          MAX_VERTEX_BUFFER_ARRAY_STRIDE,\n          MAX_VERTEX_BUFFER_ARRAY_STRIDE + 4,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= MAX_VERTEX_BUFFER_ARRAY_STRIDE;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, MAX_VERTEX_BUFFERS - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          1,\n          2,\n          4,\n          MAX_VERTEX_BUFFER_ARRAY_STRIDE - 4,\n          MAX_VERTEX_BUFFER_ARRAY_STRIDE - 2,\n          MAX_VERTEX_BUFFER_ARRAY_STRIDE,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, MAX_VERTEX_BUFFERS - 1]))\n      .combine(poptions('extraAttributes', [0, 1, MAX_VERTEX_ATTRIBUTES - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(\n        poptions('testShaderLocation', [0, 1, MAX_VERTEX_ATTRIBUTES - 1, MAX_VERTEX_ATTRIBUTES])\n      )\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributes,\n      testShaderLocation,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n\n    let currentLocation = 0;\n    for (let i = 0; i < extraAttributes; i++) {\n      if (currentLocation === testShaderLocation) {\n        currentLocation++;\n      }\n\n      attributes.push({ format: 'float', shaderLocation: currentLocation, offset: 0 });\n      currentLocation++;\n    }\n\n    const testAttribute: GPUVertexAttributeDescriptor = {\n      format: 'float',\n      shaderLocation: testShaderLocation,\n      offset: 0,\n    };\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < MAX_VERTEX_ATTRIBUTES;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('pipeline_vertex_buffers_are_backed_by_attributes_in_vertex_input').fn(async t => {\n  const vertexState: GPUVertexStateDescriptor = {\n    vertexBuffers: [\n      {\n        arrayStride: 2 * SIZEOF_FLOAT,\n        attributes: [\n          {\n            format: 'float',\n            offset: 0,\n            shaderLocation: 0,\n          },\n          {\n            format: 'float',\n            offset: 0,\n            shaderLocation: 1,\n          },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case: pipeline with one input per attribute\n    const code = `\n      [[location(0)]] var<in> a : vec4<f32>;\n      [[location(1)]] var<in> b : vec4<f32>;\n\n      [[builtin(position)]] var<out> Position : vec4<f32>;\n      [[stage(vertex)]] fn main() -> void {\n        Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n  `;\n    const descriptor = t.getDescriptor(vertexState, code);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Check it is valid for the pipeline to use a subset of the VertexState\n    const code = `\n      [[location(0)]] var<in> a : vec4<f32>;\n\n      [[builtin(position)]] var<out> Position : vec4<f32>;\n      [[stage(vertex)]] fn main() -> void {\n        Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n    `;\n    const descriptor = t.getDescriptor(vertexState, code);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Check for an error when the pipeline uses an attribute not in the vertex input\n    const code = `\n      [[location(2)]] var<in> a : vec4<f32>;\n\n      [[builtin(position)]] var<out> Position : vec4<f32>;\n      [[stage(vertex)]] fn main() -> void {\n        Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n    `;\n    const descriptor = t.getDescriptor(vertexState, code);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('offset_should_be_within_vertex_buffer_arrayStride_if_arrayStride_is_not_zero').fn(\n  async t => {\n    const vertexState = {\n      vertexBuffers: [\n        {\n          arrayStride: 2 * SIZEOF_FLOAT,\n          attributes: [\n            {\n              format: 'float' as GPUVertexFormat,\n              offset: 0,\n              shaderLocation: 0,\n            },\n            {\n              format: 'float' as GPUVertexFormat,\n              offset: SIZEOF_FLOAT,\n              shaderLocation: 1,\n            },\n          ],\n        },\n      ],\n    };\n    {\n      // Control case, setting correct arrayStride and offset\n      const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n      t.device.createRenderPipeline(descriptor);\n    }\n    {\n      // Test vertex attribute offset exceed vertex buffer arrayStride range\n      const badVertexState = clone(vertexState);\n      badVertexState.vertexBuffers[0].attributes[1].format = 'float2';\n      const descriptor = t.getDescriptor(badVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n    {\n      // Test vertex attribute offset exceed vertex buffer arrayStride range\n      const badVertexState = clone(vertexState);\n      badVertexState.vertexBuffers[0].arrayStride = SIZEOF_FLOAT;\n      const descriptor = t.getDescriptor(badVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n    {\n      // It's OK if arrayStride is zero\n      const goodVertexState = clone(vertexState);\n      goodVertexState.vertexBuffers[0].arrayStride = 0;\n      const descriptor = t.getDescriptor(goodVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n      t.device.createRenderPipeline(descriptor);\n    }\n  }\n);\n\n// TODO: This should be made into an operation test.\ng.test('check_two_attributes_overlapping').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 2 * SIZEOF_FLOAT,\n        attributes: [\n          {\n            format: 'float' as GPUVertexFormat,\n            offset: 0,\n            shaderLocation: 0,\n          },\n          {\n            format: 'float' as GPUVertexFormat,\n            offset: SIZEOF_FLOAT,\n            shaderLocation: 1,\n          },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting correct arrayStride and offset\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test two attributes overlapping\n    const overlappingVertexState = clone(vertexState);\n    overlappingVertexState.vertexBuffers[0].attributes[0].format = 'int2';\n    const descriptor = t.getDescriptor(overlappingVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n});\n\ng.test('identical_duplicate_attributes_are_invalid').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [{ format: 'float' as const, offset: 0, shaderLocation: 0 }],\n      },\n    ],\n  };\n  {\n    // Control case, setting attribute 0\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Oh no, attribute 0 is set twice\n    vertexState.vertexBuffers[0].attributes.push({\n      format: 'float' as const,\n      offset: 0,\n      shaderLocation: 0,\n    });\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('we_cannot_set_same_shader_location').fn(async t => {\n  {\n    const vertexState = {\n      vertexBuffers: [\n        {\n          arrayStride: 0,\n          attributes: [\n            { format: 'float' as const, offset: 0, shaderLocation: 0 },\n            { format: 'float' as const, offset: SIZEOF_FLOAT, shaderLocation: 1 },\n          ],\n        },\n      ],\n    };\n    {\n      // Control case, setting different shader locations in two attributes\n      const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n      t.device.createRenderPipeline(descriptor);\n    }\n    {\n      // Test same shader location in two attributes in the same buffer\n      vertexState.vertexBuffers[0].attributes[1].shaderLocation = 0;\n      const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  }\n  {\n    const vertexState: GPUVertexStateDescriptor = {\n      vertexBuffers: [\n        {\n          arrayStride: 0,\n          attributes: [\n            {\n              format: 'float',\n              offset: 0,\n              shaderLocation: 0,\n            },\n          ],\n        },\n        {\n          arrayStride: 0,\n          attributes: [\n            {\n              format: 'float',\n              offset: 0,\n              shaderLocation: 0,\n            },\n          ],\n        },\n      ],\n    };\n    // Test same shader location in two attributes in different buffers\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('check_out_of_bounds_condition_on_attribute_shader_location').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [\n          { format: 'float' as const, offset: 0, shaderLocation: MAX_VERTEX_ATTRIBUTES - 1 },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting last attribute shader location\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test attribute location OOB\n    vertexState.vertexBuffers[0].attributes[0].shaderLocation = MAX_VERTEX_ATTRIBUTES;\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('check_attribute_offset_out_of_bounds').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [\n          {\n            format: 'float2' as const,\n            offset: MAX_VERTEX_BUFFER_END - 2 * SIZEOF_FLOAT,\n            shaderLocation: 0,\n          },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting max attribute offset to MAX_VERTEX_BUFFER_END - 8\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Control case, setting attribute offset to 8\n    vertexState.vertexBuffers[0].attributes[0].offset = 8;\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test attribute offset out of bounds\n    vertexState.vertexBuffers[0].attributes[0].offset = MAX_VERTEX_BUFFER_END - 4;\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('check_multiple_of_4_bytes_constraint_on_offset').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [\n          { format: 'float' as GPUVertexFormat, offset: SIZEOF_FLOAT, shaderLocation: 0 },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting offset 4 bytes\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test offset of 2 bytes with uchar2 format\n    vertexState.vertexBuffers[0].attributes[0].offset = 2;\n    vertexState.vertexBuffers[0].attributes[0].format = 'uchar2';\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n  {\n    // Test offset of 2 bytes with float format\n    vertexState.vertexBuffers[0].attributes[0].offset = 2;\n    vertexState.vertexBuffers[0].attributes[0].format = 'float';\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('check_attribute_offset_overflow').fn(async t => {\n  const vertexState: GPUVertexStateDescriptor = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [{ format: 'float', offset: Number.MAX_SAFE_INTEGER, shaderLocation: 0 }],\n      },\n    ],\n  };\n  const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n  t.expectValidationError(() => {\n    t.device.createRenderPipeline(descriptor);\n  });\n});\n"],"file":"vertex_state.spec.js"}