{"version":3,"sources":["../../../../src/webgpu/api/validation/vertex_state.spec.ts"],"names":["description","params","pbool","poptions","makeTestGroup","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","ValidationTest","SIZEOF_FLOAT","Float32Array","BYTES_PER_ELEMENT","VERTEX_SHADER_CODE_WITH_NO_INPUT","clone","descriptor","JSON","parse","stringify","F","getDescriptor","vertexState","vertexShaderCode","vertexStage","module","device","createShaderModule","code","entryPoint","fragmentStage","primitiveTopology","colorStates","format","testVertexState","success","vertexShader","vsModule","fsModule","expectValidationError","createRenderPipeline","generateTestVertexShader","inputs","interfaces","body","count","input","location","type","g","test","desc","subcases","combine","fn","t","lastEmpty","vertexBuffers","i","push","attributes","arrayStride","offset","shaderLocation","attribCount","attribsPerBuffer","attribsAdded","targetCount","Math","min","length","vertexBufferIndex","extraAttributes","testShaderLocation","testAttributeAtStart","currentLocation","testAttribute","unshift","vertexBufferIndexA","vertexBufferIndexB","testAttributeAtStartA","testAttributeAtStartB","shaderLocationA","shaderLocationB","vertexBufferAttributes","attributesA","attributesB","testLocation","shader","badVertexState","goodVertexState","overlappingVertexState","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["export const description = `\nvertexState validation tests.\n\nTODO: implement the combinations tests below.\n\nTest each declaration must have a format compatible with the attribute:\n - For each vertex format\n  - For each type of shader declaration\n   - Check error IFF shader declaration not compatible with the attribute's format.\n\nOne-off test that many attributes can overlap.\n\nAll tests below are for a vertex buffer index 0, 1, limit-1.\n\nTest check that the end attribute must be contained in the stride:\n - For stride = 0 (special case), 4, 128, limit\n   - For each vertex format\n    - For offset stride, stride - componentsize(format), stride - sizeof(format), stride - sizeof(format) + componentsize(format), 0, 2^32 - componentsize(format), 2^32, 2**60\n      - Check error IFF offset + sizeof(format) > stride (or 2048 for 0)\n\nTest that an attribute must be aligned to the component size:\n - For each vertex format\n  - For stride = 2*sizeof(format), 128, limit\n    - For offset = componentsize(format), componentsize(format) / 2, stride - sizeof(format) - componentsize(format), stride - sizeof(format)\n     - Check error IFF offset not aligned to componentsize(format);\n`;\n\nimport { params, pbool, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n} from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nconst SIZEOF_FLOAT = Float32Array.BYTES_PER_ELEMENT;\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  [[builtin(position)]] var<out> Position : vec4<f32>;\n  [[stage(vertex)]] fn main() -> void {\n    Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction clone<T extends GPUVertexStateDescriptor>(descriptor: T): T {\n  return JSON.parse(JSON.stringify(descriptor));\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    vertexState: GPUVertexStateDescriptor,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      vertexStage: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor : vec4<f32>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      primitiveTopology: 'triangle-list',\n      colorStates: [{ format: 'rgba8unorm' }],\n      vertexState,\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    vertexState: GPUVertexStateDescriptor,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    const vsModule = this.device.createShaderModule({ code: vertexShader });\n    const fsModule = this.device.createShaderModule({\n      code: `\n        [[location(0)]] var<out> fragColor : vec4<f32>;\n        [[stage(fragment)]] fn main() -> void {\n          fragColor = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n    });\n\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        vertexState,\n        vertexStage: {\n          module: vsModule,\n          entryPoint: 'main',\n        },\n        fragmentStage: {\n          module: fsModule,\n          entryPoint: 'main',\n        },\n        primitiveTopology: 'triangle-list',\n        colorStates: [{ format: 'rgba8unorm' }],\n      });\n    }, !success);\n  }\n\n  generateTestVertexShader(inputs: { type: string; location: number }[]): string {\n    let interfaces = '';\n    let body = '';\n\n    let count = 0;\n    for (const input of inputs) {\n      interfaces += `[[location(${input.location})]] var<in> input${count} : ${input.type};\\n`;\n      body += `var i${count} : ${input.type} = input${count};\\n`;\n      count++;\n    }\n\n    return `\n      [[builtin(position)]] var<out> Position : vec4<f32>;\n      ${interfaces}\n      [[stage(vertex)]] fn main() -> void {\n        Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n        ${body}\n      }\n    `;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('count', [0, 1, kMaxVertexBuffers, kMaxVertexBuffers + 1]))\n      .combine(pbool('lastEmpty'))\n  )\n  .fn(t => {\n    const { count, lastEmpty } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float32', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        });\n      }\n    }\n\n    const success = count <= kMaxVertexBuffers;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attribute.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('attribCount', [0, 1, kMaxVertexAttributes, kMaxVertexAttributes + 1]))\n      .combine(poptions('attribsPerBuffer', [0, 1, 4]))\n  )\n  .fn(t => {\n    const { attribCount, attribsPerBuffer } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === kMaxVertexBuffers - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes: GPUVertexAttributeDescriptor[] = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float32', offset: 0, shaderLocation: attribsAdded });\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= kMaxVertexAttributes;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          4,\n          256,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride,\n          kMaxVertexBufferArrayStride + 4,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= kMaxVertexBufferArrayStride;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          1,\n          2,\n          4,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride - 2,\n          kMaxVertexBufferArrayStride,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributes', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(\n        poptions('testShaderLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes])\n      )\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributes,\n      testShaderLocation,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n\n    let currentLocation = 0;\n    for (let i = 0; i < extraAttributes; i++) {\n      if (currentLocation === testShaderLocation) {\n        currentLocation++;\n      }\n\n      attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n      currentLocation++;\n    }\n\n    const testAttribute: GPUVertexAttributeDescriptor = {\n      format: 'float32',\n      shaderLocation: testShaderLocation,\n      offset: 0,\n    };\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < kMaxVertexAttributes;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_attribute_shaderLocation_unique')\n  .desc(\n    `Test that shaderLocation must be unique in the vertex state.\n   - Test for various pairs of buffers that contain the potentially conflicting attributes\n   - Test for the potentially conflicting attributes in various places in the buffers (with dummy attributes)\n   - Test for various shaderLocations that conflict or not`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndexA', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('vertexBufferIndexB', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(pbool('testAttributeAtStartA'))\n      .combine(pbool('testAttributeAtStartB'))\n      .combine(poptions('shaderLocationA', [0, 1, 7, kMaxVertexAttributes - 1]))\n      .combine(poptions('shaderLocationB', [0, 1, 7, kMaxVertexAttributes - 1]))\n      .combine(poptions('extraAttributes', [0, 4]))\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexA,\n      vertexBufferIndexB,\n      testAttributeAtStartA,\n      testAttributeAtStartB,\n      shaderLocationA,\n      shaderLocationB,\n      extraAttributes,\n    } = t.params;\n\n    // Depending on the params, the vertexBuffer for A and B can be the same or different. To support\n    // both cases without code changes we treat `vertexBufferAttributes` as a map from indices to\n    // vertex buffer descriptors, with A and B potentially reusing the same JS object if they have the\n    // same index.\n    const vertexBufferAttributes: GPUVertexAttributeDescriptor[][] = [];\n    vertexBufferAttributes[vertexBufferIndexA] = [];\n    vertexBufferAttributes[vertexBufferIndexB] = [];\n\n    // Add the dummy attributes for attribute A\n    const attributesA = vertexBufferAttributes[vertexBufferIndexA];\n    let currentLocation = 0;\n    for (let i = 0; i < extraAttributes; i++) {\n      if (currentLocation === shaderLocationA || currentLocation === shaderLocationB) {\n        currentLocation++;\n        continue;\n      }\n\n      attributesA.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n      currentLocation++;\n    }\n\n    // Add attribute A\n    if (testAttributeAtStartA) {\n      attributesA.unshift({ format: 'float32', offset: 0, shaderLocation: shaderLocationA });\n    } else {\n      attributesA.push({ format: 'float32', offset: 0, shaderLocation: shaderLocationA });\n    }\n\n    // Add attribute B. Not that attributesB can be the same object as attributesA.\n    const attributesB = vertexBufferAttributes[vertexBufferIndexB];\n    if (testAttributeAtStartB) {\n      attributesB.unshift({ format: 'float32', offset: 0, shaderLocation: shaderLocationB });\n    } else {\n      attributesB.push({ format: 'float32', offset: 0, shaderLocation: shaderLocationB });\n    }\n\n    // Use the attributes to make the list of vertex buffers. Note that we might be setting the same vertex\n    // buffer twice, but that only happens when it is the only vertex buffer.\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndexA] = { arrayStride: 256, attributes: attributesA };\n    vertexBuffers[vertexBufferIndexB] = { arrayStride: 256, attributes: attributesB };\n\n    // Note that an empty vertex shader will be used so errors only happens because of the conflict\n    // in the vertex state.\n    const success = shaderLocationA !== shaderLocationB;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_shader_input_location_limit')\n  .desc(\n    `Test that vertex shader's input's location decoration must be less than maxVertexAttributes.\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params().combine(\n      poptions('testLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes, -1, 2 ** 32])\n    )\n  )\n  .fn(t => {\n    const { testLocation } = t.params;\n\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testLocation,\n      },\n    ]);\n\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [\n      {\n        arrayStride: 512,\n        attributes: [\n          {\n            format: 'float32',\n            offset: 0,\n            shaderLocation: testLocation,\n          },\n        ],\n      },\n    ];\n\n    const success = testLocation < kMaxVertexAttributes;\n    t.testVertexState(success, { vertexBuffers }, shader);\n  });\n\ng.test('vertex_shader_input_location_in_vertex_state')\n  .desc(\n    `Test that a vertex shader defined in the shader must have a corresponding attribute in the vertex state.\n       - Test for various input locations.\n       - Test for the attribute in various places in the list of vertex buffer and various places inside the vertex buffer descriptor`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributes', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(poptions('testShaderLocation', [0, 1, 4, 7, kMaxVertexAttributes - 1]))\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributes,\n      testAttributeAtStart,\n      testShaderLocation,\n    } = t.params;\n    // We have a shader using `testShaderLocation`.\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testShaderLocation,\n      },\n    ]);\n\n    // Fill attributes with a bunch of attributes for other locations.\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n\n    let currentLocation = 0;\n    for (let i = 0; i < extraAttributes; i++) {\n      if (currentLocation === testShaderLocation) {\n        currentLocation++;\n      }\n\n      attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n      currentLocation++;\n    }\n\n    // Using that vertex state is invalid because the vertex state doesn't contain the test location\n    const vertexBuffers: GPUVertexBufferLayoutDescriptor[] = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n    t.testVertexState(false, { vertexBuffers }, shader);\n\n    // Add an attribute for the test location and try again.\n    const testAttribute: GPUVertexAttributeDescriptor = {\n      format: 'float32',\n      shaderLocation: testShaderLocation,\n      offset: 0,\n    };\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n\n    t.testVertexState(true, { vertexBuffers }, shader);\n  });\n\ng.test('offset_should_be_within_vertex_buffer_arrayStride_if_arrayStride_is_not_zero').fn(\n  async t => {\n    const vertexState = {\n      vertexBuffers: [\n        {\n          arrayStride: 2 * SIZEOF_FLOAT,\n          attributes: [\n            {\n              format: 'float32' as GPUVertexFormat,\n              offset: 0,\n              shaderLocation: 0,\n            },\n            {\n              format: 'float32' as GPUVertexFormat,\n              offset: SIZEOF_FLOAT,\n              shaderLocation: 1,\n            },\n          ],\n        },\n      ],\n    };\n    {\n      // Control case, setting correct arrayStride and offset\n      const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n      t.device.createRenderPipeline(descriptor);\n    }\n    {\n      // Test vertex attribute offset exceed vertex buffer arrayStride range\n      const badVertexState = clone(vertexState);\n      badVertexState.vertexBuffers[0].attributes[1].format = 'float32x2';\n      const descriptor = t.getDescriptor(badVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n    {\n      // Test vertex attribute offset exceed vertex buffer arrayStride range\n      const badVertexState = clone(vertexState);\n      badVertexState.vertexBuffers[0].arrayStride = SIZEOF_FLOAT;\n      const descriptor = t.getDescriptor(badVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n    {\n      // It's OK if arrayStride is zero\n      const goodVertexState = clone(vertexState);\n      goodVertexState.vertexBuffers[0].arrayStride = 0;\n      const descriptor = t.getDescriptor(goodVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n      t.device.createRenderPipeline(descriptor);\n    }\n  }\n);\n\n// TODO: This should be made into an operation test.\ng.test('check_two_attributes_overlapping').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 2 * SIZEOF_FLOAT,\n        attributes: [\n          {\n            format: 'float32' as GPUVertexFormat,\n            offset: 0,\n            shaderLocation: 0,\n          },\n          {\n            format: 'float32' as GPUVertexFormat,\n            offset: SIZEOF_FLOAT,\n            shaderLocation: 1,\n          },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting correct arrayStride and offset\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test two attributes overlapping\n    const overlappingVertexState = clone(vertexState);\n    overlappingVertexState.vertexBuffers[0].attributes[0].format = 'sint32x2';\n    const descriptor = t.getDescriptor(overlappingVertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n});\n\ng.test('check_attribute_offset_out_of_bounds').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [\n          {\n            format: 'float32x2' as const,\n            offset: kMaxVertexBufferArrayStride - 2 * SIZEOF_FLOAT,\n            shaderLocation: 0,\n          },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting max attribute offset to MAX_VERTEX_BUFFER_END - 8\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Control case, setting attribute offset to 8\n    vertexState.vertexBuffers[0].attributes[0].offset = 8;\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test attribute offset out of bounds\n    vertexState.vertexBuffers[0].attributes[0].offset = kMaxVertexBufferArrayStride - 4;\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('check_multiple_of_4_bytes_constraint_on_offset').fn(async t => {\n  const vertexState = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [\n          { format: 'float32' as GPUVertexFormat, offset: SIZEOF_FLOAT, shaderLocation: 0 },\n        ],\n      },\n    ],\n  };\n  {\n    // Control case, setting offset 4 bytes\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.device.createRenderPipeline(descriptor);\n  }\n  {\n    // Test offset of 2 bytes with uint8x2 format\n    vertexState.vertexBuffers[0].attributes[0].offset = 2;\n    vertexState.vertexBuffers[0].attributes[0].format = 'uint8x2';\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n  {\n    // Test offset of 2 bytes with float32 format\n    vertexState.vertexBuffers[0].attributes[0].offset = 2;\n    vertexState.vertexBuffers[0].attributes[0].format = 'float32';\n    const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n    t.expectValidationError(() => {\n      t.device.createRenderPipeline(descriptor);\n    });\n  }\n});\n\ng.test('check_attribute_offset_overflow').fn(async t => {\n  const vertexState: GPUVertexStateDescriptor = {\n    vertexBuffers: [\n      {\n        arrayStride: 0,\n        attributes: [{ format: 'float32', offset: Number.MAX_SAFE_INTEGER, shaderLocation: 0 }],\n      },\n    ],\n  };\n  const descriptor = t.getDescriptor(vertexState, VERTEX_SHADER_CODE_WITH_NO_INPUT);\n\n  t.expectValidationError(() => {\n    t.device.createRenderPipeline(descriptor);\n  });\n});\n"],"file":"vertex_state.spec.js"}