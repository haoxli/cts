{"version":3,"sources":["../../../../../src/webgpu/api/validation/copy_between_linear_data_and_texture/copyBetweenLinearDataAndTexture_dataRelated.spec.ts"],"names":["description","params","poptions","makeTestGroup","assert","kUncompressedTextureFormatInfo","kSizedTextureFormats","kSizedTextureFormatInfo","align","bytesInACompleteRow","dataBytesForCopy","kImageCopyTypes","CopyBetweenLinearDataAndTextureTest","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","formatCopyableWithMethod","g","test","cases","subcases","combine","undefined","fn","t","rowsPerImage","copyHeightInBlocks","copyDepth","method","format","copyHeight","blockHeight","texture","device","createTexture","size","width","height","depth","usage","GPUTextureUsage","COPY_SRC","COPY_DST","layout","bytesPerRow","minDataSize","valid","testRun","dataSize","success","_success","filter","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","offsetInBlocks","info","selectDeviceOrSkipTestCase","extension","bytesPerRowAlignment","copyWidth","blockWidth","offset","bytesPerBlock","createAlignedTexture","desc","blocksPerRow","additionalPaddingPerRow","copySize","dataSizeInBlocks"],"mappings":"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","sourcesContent":["export const description = '';\n\nimport { params, poptions } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/framework/util/util.js';\nimport {\n  kUncompressedTextureFormatInfo,\n  kSizedTextureFormats,\n  kSizedTextureFormatInfo,\n} from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopy,\n  kImageCopyTypes,\n} from '../../../util/texture/image_copy.js';\n\nimport {\n  CopyBetweenLinearDataAndTextureTest,\n  texelBlockAlignmentTestExpanderForOffset,\n  texelBlockAlignmentTestExpanderForRowsPerImage,\n  formatCopyableWithMethod,\n} from './copyBetweenLinearDataAndTexture.js';\n\nexport const g = makeTestGroup(CopyBetweenLinearDataAndTextureTest);\n\ng.test('bound_on_rows_per_image')\n  .cases(poptions('method', kImageCopyTypes))\n  .subcases(() =>\n    params()\n      .combine(poptions('rowsPerImage', [undefined, 0, 1, 2, 1024]))\n      .combine(poptions('copyHeightInBlocks', [0, 1, 2]))\n      .combine(poptions('copyDepth', [1, 3]))\n  )\n  .fn(async t => {\n    const { rowsPerImage, copyHeightInBlocks, copyDepth, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const copyHeight = copyHeightInBlocks * kUncompressedTextureFormatInfo[format].blockHeight;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depth: 3 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const layout = { bytesPerRow: 1024, rowsPerImage };\n    const size = { width: 0, height: copyHeight, depth: copyDepth };\n    const { minDataSize, valid } = dataBytesForCopy(layout, format, size, { method });\n\n    t.testRun({ texture }, layout, size, {\n      dataSize: minDataSize,\n      method,\n      success: valid,\n    });\n  });\n\n// Test with offset + requiredBytesIsCopy overflowing GPUSize64.\ng.test('offset_plus_required_bytes_in_copy_overflow')\n  .cases(poptions('method', kImageCopyTypes))\n  .subcases(() => [\n    { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depth: 1, _success: true }, // success case\n    { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depth: 16, _success: false }, // bytesPerRow * rowsPerImage * (depth - 1) overflows.\n  ])\n  .fn(async t => {\n    const { method, bytesPerRow, rowsPerImage, depth, _success } = t.params;\n\n    const texture = t.device.createTexture({\n      size: [1, 1, depth],\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun(\n      { texture },\n      { bytesPerRow, rowsPerImage },\n      { width: 1, height: 1, depth },\n      {\n        dataSize: 10000,\n        method,\n        success: _success,\n      }\n    );\n  });\n\n// Testing that the minimal data size condition is checked correctly.\n// In the success case, we test the exact value.\n// In the failing case, we test the exact value minus 1.\ng.test('required_bytes_in_copy')\n  .cases(\n    params()\n      .combine(poptions('method', kImageCopyTypes))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n  )\n  .subcases(() =>\n    params()\n      .combine([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combine([\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 3, offsetInBlocks: 11 }, // standard copy, offset > 0\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2, offsetInBlocks: 0 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5, offsetInBlocks: 0 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0, offsetInBlocks: 13 }, // empty copy because of depth, offset > 0\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // copyWidth = 1\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 1, copyDepth: 5, offsetInBlocks: 15 }, // copyHeight = 1, offset > 0\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1, offsetInBlocks: 0 }, // copyDepth = 1\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1, offsetInBlocks: 0 }, // copyHeight = 1 and copyDepth = 1\n      ])\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      method,\n    } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const size = { width: copyWidth, height: copyHeight, depth: copyDepth };\n\n    const layout = { offset, bytesPerRow, rowsPerImage };\n    const { minDataSize, valid } = dataBytesForCopy(layout, format, size, { method });\n    assert(valid);\n\n    const texture = t.createAlignedTexture(format, size);\n\n    t.testRun({ texture }, { offset, bytesPerRow, rowsPerImage }, size, {\n      dataSize: minDataSize,\n      method,\n      success: true,\n    });\n\n    if (minDataSize > 0) {\n      t.testRun({ texture }, { offset, bytesPerRow, rowsPerImage }, size, {\n        dataSize: minDataSize - 1,\n        method,\n        success: false,\n      });\n    }\n  });\n\ng.test('rows_per_image_alignment')\n  .desc(`rowsPerImage is measured in multiples of block height, so has no alignment constraints.`)\n  .cases(\n    params()\n      .combine(poptions('method', kImageCopyTypes))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n  )\n  .subcases(texelBlockAlignmentTestExpanderForRowsPerImage)\n  .fn(async t => {\n    const { rowsPerImage, format, method } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    const size = { width: 0, height: 0, depth: 0 };\n\n    const texture = t.createAlignedTexture(format, size);\n\n    t.testRun({ texture }, { bytesPerRow: 0, rowsPerImage }, size, {\n      dataSize: 1,\n      method,\n      success: true,\n    });\n  });\n\ng.test('texel_block_alignment_on_offset')\n  .cases(\n    params()\n      .combine(poptions('method', kImageCopyTypes))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n  )\n  .subcases(texelBlockAlignmentTestExpanderForOffset)\n  .fn(async t => {\n    const { format, offset, method } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    const size = { width: 0, height: 0, depth: 0 };\n\n    const texture = t.createAlignedTexture(format, size);\n\n    const success =\n      method === 'WriteTexture' || offset % kSizedTextureFormatInfo[format].bytesPerBlock === 0;\n\n    t.testRun({ texture }, { offset, bytesPerRow: 0 }, size, { dataSize: offset, method, success });\n  });\n\ng.test('bound_on_bytes_per_row')\n  .cases(\n    params()\n      .combine(poptions('method', kImageCopyTypes))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n  )\n  .subcases(() =>\n    params()\n      .combine([\n        { blocksPerRow: 2, additionalPaddingPerRow: 0, copyWidthInBlocks: 2 }, // success\n        { blocksPerRow: 2, additionalPaddingPerRow: 5, copyWidthInBlocks: 3 }, // success if bytesPerBlock <= 5\n        { blocksPerRow: 1, additionalPaddingPerRow: 0, copyWidthInBlocks: 2 }, // failure, bytesPerRow > 0\n        { blocksPerRow: 0, additionalPaddingPerRow: 0, copyWidthInBlocks: 1 }, // failure, bytesPerRow = 0\n      ])\n      .combine([\n        { copyHeightInBlocks: 0, copyDepth: 1 }, // we don't have to check the bound\n        { copyHeightInBlocks: 1, copyDepth: 0 }, // we don't have to check the bound\n        { copyHeightInBlocks: 2, copyDepth: 1 }, // we have to check the bound\n        { copyHeightInBlocks: 0, copyDepth: 2 }, // we have to check the bound\n      ])\n  )\n  .fn(async t => {\n    const {\n      blocksPerRow,\n      additionalPaddingPerRow,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      method,\n    } = t.params;\n    const info = kSizedTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n\n    const copyWidth = align(copyWidthInBlocks * info.blockWidth, bytesPerRowAlignment);\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const bytesPerRow = align(\n      blocksPerRow * info.bytesPerBlock + additionalPaddingPerRow,\n      bytesPerRowAlignment\n    );\n    const copySize = { width: copyWidth, height: copyHeight, depth: copyDepth };\n\n    const texture = t.createAlignedTexture(format, {\n      width: copyWidth,\n      // size 0 is not valid; round up if needed\n      height: copyHeight || info.blockHeight,\n      depth: copyDepth || 1,\n    });\n\n    const layout = { bytesPerRow, rowsPerImage: copyHeight };\n    const { minDataSize, valid } = dataBytesForCopy(layout, format, copySize, { method });\n\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSize,\n      method,\n      success: valid,\n    });\n  });\n\ng.test('bound_on_offset')\n  .cases(poptions('method', kImageCopyTypes))\n  .subcases(() =>\n    params()\n      .combine(poptions('offsetInBlocks', [0, 1, 2]))\n      .combine(poptions('dataSizeInBlocks', [0, 1, 2]))\n  )\n  .fn(async t => {\n    const { offsetInBlocks, dataSizeInBlocks, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const info = kSizedTextureFormatInfo[format];\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const dataSize = dataSizeInBlocks * info.bytesPerBlock;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depth: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = offset <= dataSize;\n\n    t.testRun(\n      { texture },\n      { offset, bytesPerRow: 0 },\n      { width: 0, height: 0, depth: 0 },\n      { dataSize, method, success }\n    );\n  });\n"],"file":"copyBetweenLinearDataAndTexture_dataRelated.spec.js"}