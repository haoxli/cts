{"version":3,"sources":["../../../../../src/webgpu/api/validation/copy_between_linear_data_and_texture/copyBetweenLinearDataAndTexture.ts"],"names":["poptions","assert","kSizedTextureFormatInfo","align","ValidationTest","kAllTestMethods","CopyBetweenLinearDataAndTextureTest","bytesInACompleteRow","copyWidth","format","info","blockWidth","bytesPerBlock","dataBytesForCopy","layout","copyExtent","method","width","widthInBlocks","height","blockHeight","heightInBlocks","bytesInLastRow","valid","offset","bytesPerRow","undefined","rowsPerImage","requiredBytesInCopy","depth","bytesPerImage","bytesBeforeLastImage","minDataSize","testRun","textureCopyView","textureDataLayout","size","dataSize","success","submit","data","Uint8Array","expectValidationError","device","queue","writeTexture","buffer","createBuffer","usage","GPUBufferUsage","COPY_SRC","encoder","createCommandEncoder","copyBufferToTexture","cmd","finish","COPY_DST","copyTextureToBuffer","createAlignedTexture","copySize","origin","x","y","z","createTexture","Math","max","GPUTextureUsage","valuesToTestDivisibilityBy","number","values","i","push","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","texelBlockAlignmentTestExpanderForValueToCoordinate","coordinateToTest","formatCopyableWithMethod","copySrc","copyDst"],"mappings":"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","sourcesContent":["import { poptions } from '../../../../common/framework/params_builder.js';\nimport { assert } from '../../../../common/framework/util/util.js';\nimport { kSizedTextureFormatInfo, SizedTextureFormat } from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\nimport { ValidationTest } from '../validation_test.js';\n\ntype TestMethod = 'WriteTexture' | 'CopyBufferToTexture' | 'CopyTextureToBuffer';\nexport const kAllTestMethods: readonly TestMethod[] = [\n  'WriteTexture',\n  'CopyBufferToTexture',\n  'CopyTextureToBuffer',\n] as const;\n\nexport class CopyBetweenLinearDataAndTextureTest extends ValidationTest {\n  bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n    const info = kSizedTextureFormatInfo[format];\n    assert(copyWidth % info.blockWidth === 0);\n    return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n  }\n\n  /**\n   * Validate a copy and compute the number of bytes it needs. If the copy is invalid, computes a\n   * guess assuming `bytesPerRow` and `rowsPerImage` should be optimal.\n   */\n  dataBytesForCopy(\n    layout: GPUTextureDataLayout,\n    format: SizedTextureFormat,\n    copyExtent: GPUExtent3DDict,\n    { method }: { method: TestMethod }\n  ): { minDataSize: number; valid: boolean } {\n    const info = kSizedTextureFormatInfo[format];\n    assert(copyExtent.width % info.blockWidth === 0);\n    const widthInBlocks = copyExtent.width / info.blockWidth;\n    assert(copyExtent.height % info.blockHeight === 0);\n    const heightInBlocks = copyExtent.height / info.blockHeight;\n    const bytesInLastRow = widthInBlocks * info.bytesPerBlock;\n\n    let valid = true;\n    const offset = layout.offset ?? 0;\n    if (method !== 'WriteTexture') {\n      if (offset % info.bytesPerBlock !== 0) valid = false;\n      if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n    }\n    if (layout.bytesPerRow !== undefined && bytesInLastRow > layout.bytesPerRow) valid = false;\n    if (layout.rowsPerImage !== undefined && heightInBlocks > layout.rowsPerImage) valid = false;\n\n    let requiredBytesInCopy = 0;\n    {\n      let { bytesPerRow, rowsPerImage } = layout;\n\n      // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n      if (heightInBlocks > 1 && bytesPerRow === undefined) valid = false;\n      // If copyExtent.depth > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n      if (copyExtent.depth > 1 && rowsPerImage === undefined) valid = false;\n      // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n      if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) valid = false;\n      // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n      if (rowsPerImage !== undefined && rowsPerImage < heightInBlocks) valid = false;\n\n      bytesPerRow ??= align(info.bytesPerBlock * widthInBlocks, 256);\n      rowsPerImage ??= heightInBlocks;\n\n      if (copyExtent.depth > 1) {\n        const bytesPerImage = bytesPerRow * rowsPerImage;\n        const bytesBeforeLastImage = bytesPerImage * (copyExtent.depth - 1);\n        requiredBytesInCopy += bytesBeforeLastImage;\n      }\n      if (copyExtent.depth > 0) {\n        if (heightInBlocks > 1) requiredBytesInCopy += bytesPerRow * (heightInBlocks - 1);\n        if (heightInBlocks > 0) requiredBytesInCopy += bytesInLastRow;\n      }\n    }\n\n    return { minDataSize: offset + requiredBytesInCopy, valid };\n  }\n\n  testRun(\n    textureCopyView: GPUTextureCopyView,\n    textureDataLayout: GPUTextureDataLayout,\n    size: GPUExtent3D,\n    {\n      method,\n      dataSize,\n      success,\n      submit = false,\n    }: {\n      method: TestMethod;\n      dataSize: number;\n      success: boolean;\n      /** If submit is true, the validaton error is expected to come from the submit and encoding\n       * should succeed. */\n      submit?: boolean;\n    }\n  ): void {\n    switch (method) {\n      case 'WriteTexture': {\n        const data = new Uint8Array(dataSize);\n\n        this.expectValidationError(() => {\n          this.device.queue.writeTexture(textureCopyView, data, textureDataLayout, size);\n        }, !success);\n\n        break;\n      }\n      case 'CopyBufferToTexture': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, textureCopyView, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.queue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n      case 'CopyTextureToBuffer': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_DST,\n        });\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyTextureToBuffer(textureCopyView, { buffer, ...textureDataLayout }, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.queue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n    }\n  }\n\n  // This is a helper function used for creating a texture when we don't have to be very\n  // precise about its size as long as it's big enough and properly aligned.\n  createAlignedTexture(\n    format: SizedTextureFormat,\n    copySize: GPUExtent3DDict = { width: 1, height: 1, depth: 1 },\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n  ): GPUTexture {\n    const info = kSizedTextureFormatInfo[format];\n    return this.device.createTexture({\n      size: {\n        width: Math.max(1, copySize.width + origin.x) * info.blockWidth,\n        height: Math.max(1, copySize.height + origin.y) * info.blockHeight,\n        depth: Math.max(1, copySize.depth + origin.z),\n      },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n  }\n}\n\n// For testing divisibility by a number we test all the values returned by this function:\nfunction valuesToTestDivisibilityBy(number: number): Iterable<number> {\n  const values = [];\n  for (let i = 0; i <= 2 * number; ++i) {\n    values.push(i);\n  }\n  values.push(3 * number);\n  return values;\n}\n\ninterface WithFormat {\n  format: SizedTextureFormat;\n}\n\ninterface WithFormatAndCoordinate extends WithFormat {\n  coordinateToTest: keyof GPUOrigin3DDict | keyof GPUExtent3DDict;\n}\n\ninterface WithFormatAndMethod extends WithFormat {\n  method: string;\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on offset\nexport function texelBlockAlignmentTestExpanderForOffset({ format }: WithFormat) {\n  return poptions(\n    'offset',\n    valuesToTestDivisibilityBy(kSizedTextureFormatInfo[format].bytesPerBlock)\n  );\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on rowsPerImage\nexport function texelBlockAlignmentTestExpanderForRowsPerImage({ format }: WithFormat) {\n  return poptions(\n    'rowsPerImage',\n    valuesToTestDivisibilityBy(kSizedTextureFormatInfo[format].blockHeight)\n  );\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on origin and size\nexport function texelBlockAlignmentTestExpanderForValueToCoordinate({\n  format,\n  coordinateToTest,\n}: WithFormatAndCoordinate) {\n  switch (coordinateToTest) {\n    case 'x':\n    case 'width':\n      return poptions(\n        'valueToCoordinate',\n        valuesToTestDivisibilityBy(kSizedTextureFormatInfo[format].blockWidth!)\n      );\n\n    case 'y':\n    case 'height':\n      return poptions(\n        'valueToCoordinate',\n        valuesToTestDivisibilityBy(kSizedTextureFormatInfo[format].blockHeight!)\n      );\n\n    case 'z':\n    case 'depth':\n      return poptions('valueToCoordinate', valuesToTestDivisibilityBy(1));\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function formatCopyableWithMethod({ format, method }: WithFormatAndMethod): boolean {\n  if (method === 'CopyTextureToBuffer') {\n    return kSizedTextureFormatInfo[format].copySrc;\n  } else {\n    return kSizedTextureFormatInfo[format].copyDst;\n  }\n}\n"],"file":"copyBetweenLinearDataAndTexture.js"}