{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/programmable/pipeline_bind_group_compat.spec.ts"],"names":["description","makeTestGroup","kShaderStageCombinations","GPUConst","kProgrammableEncoderTypes","ValidationTest","getTestCmds","encoderType","kResourceTypes","F","getUniformBuffer","device","createBuffer","size","Float32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","UNIFORM","createRenderPipeline","pipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","primitive","topology","beginRenderPass","commandEncoder","attachmentTexture","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","loadValue","r","g","b","a","storeOp","test","desc","params","u","combine","expand","p","beginSubcases","combineWithParams","setBindGroup0","setUnusedBindGroup1","setBindGroup2","_success","unimplemented","paramsSubcasesOnly","setBindGroup1","fn","t","uniformBuffer","bindGroup0","createBindGroup","entries","binding","resource","buffer","layout","getBindGroupLayout","bindGroup1","createCommandEncoder","renderPass","setPipeline","setBindGroup","draw","endPass","expectValidationError","finish","bgBindings","plBindings","ShaderStage","COMPUTE","VERTEX","FRAGMENT"],"mappings":"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","sourcesContent":["export const description = `\nTODO:\n- test compatibility between bind groups and pipelines\n    - the binding resource in bindGroups[i].layout is \"group-equivalent\" (value-equal) to pipelineLayout.bgls[i].\n    - in the test fn, test once without the dispatch/draw (should always be valid) and once with\n      the dispatch/draw, to make sure the validation happens in dispatch/draw.\n    - x= {dispatch, all draws} (dispatch/draw should be size 0 to make sure validation still happens if no-op)\n    - x= all relevant stages\n\nTODO: subsume existing test, rewrite fixture as needed.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { kShaderStageCombinations } from '../../../../capability_info.js';\nimport { GPUConst } from '../../../../constants.js';\nimport {\n  ProgrammableEncoderType,\n  kProgrammableEncoderTypes,\n} from '../../util/command_buffer_maker.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nfunction getTestCmds(encoderType: ProgrammableEncoderType): readonly string[] {\n  if (encoderType === 'compute pass') {\n    return ['dispatch', 'dispatchIndirect'] as const;\n  } else {\n    return ['draw', 'drawIndexed', 'drawIndirect', 'drawIndexedIndirect'] as const;\n  }\n}\n\nconst kResourceTypes = ['buffer', 'sampler', 'texture', 'storageTexture', 'externalTexture'];\n\nclass F extends ValidationTest {\n  getUniformBuffer(): GPUBuffer {\n    return this.device.createBuffer({\n      size: 8 * Float32Array.BYTES_PER_ELEMENT,\n      usage: GPUBufferUsage.UNIFORM,\n    });\n  }\n\n  createRenderPipeline(): GPURenderPipeline {\n    const pipeline = this.device.createRenderPipeline({\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[block]] struct VertexUniforms {\n              transform : mat2x2<f32> ;\n            };\n            [[group(0), binding(0)]] var<uniform> uniforms : VertexUniforms;\n\n            [[stage(vertex)]] fn main(\n              [[builtin(vertex_index)]] VertexIndex : u32\n              ) -> [[builtin(position)]] vec4<f32> {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( 1.0, -1.0),\n                vec2<f32>(-1.0,  1.0)\n              );\n              return vec4<f32>(uniforms.transform * pos[VertexIndex], 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[block]] struct FragmentUniforms {\n              color : vec4<f32>;\n            };\n            [[group(1), binding(0)]] var<uniform> uniforms : FragmentUniforms;\n\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n              return uniforms.color;\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    });\n    return pipeline;\n  }\n\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: attachmentTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('bind_groups_and_pipeline_layout_mismatch')\n  .desc(\n    `\n    Tests the bind groups must match the requirements of the pipeline layout.\n    - bind groups required by the pipeline layout are required.\n    - bind groups unused by the pipeline layout can be set or not.\n\n    TODO: merge existing tests to this test\n    `\n  )\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .expand('call', p => getTestCmds(p.encoderType))\n      .beginSubcases()\n      .combineWithParams([\n        { setBindGroup0: true, setUnusedBindGroup1: true, setBindGroup2: true, _success: true },\n        { setBindGroup0: true, setUnusedBindGroup1: false, setBindGroup2: true, _success: true },\n        { setBindGroup0: true, setUnusedBindGroup1: true, setBindGroup2: false, _success: false },\n        { setBindGroup0: false, setUnusedBindGroup1: true, setBindGroup2: true, _success: false },\n        { setBindGroup0: false, setUnusedBindGroup1: false, setBindGroup2: false, _success: false },\n      ])\n      .combine('useU32Array', [false, true])\n  )\n  .unimplemented();\n\ng.test('it_is_invalid_to_draw_in_a_render_pass_with_missing_bind_groups')\n  .paramsSubcasesOnly([\n    { setBindGroup1: true, setBindGroup2: true, _success: true },\n    { setBindGroup1: true, setBindGroup2: false, _success: false },\n    { setBindGroup1: false, setBindGroup2: true, _success: false },\n    { setBindGroup1: false, setBindGroup2: false, _success: false },\n  ])\n  .fn(async t => {\n    const { setBindGroup1, setBindGroup2, _success } = t.params;\n\n    const pipeline = t.createRenderPipeline();\n\n    const uniformBuffer = t.getUniformBuffer();\n\n    const bindGroup0 = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: pipeline.getBindGroupLayout(0),\n    });\n\n    const bindGroup1 = t.device.createBindGroup({\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n      ],\n      layout: pipeline.getBindGroupLayout(1),\n    });\n\n    const commandEncoder = t.device.createCommandEncoder();\n    const renderPass = t.beginRenderPass(commandEncoder);\n    renderPass.setPipeline(pipeline);\n    if (setBindGroup1) {\n      renderPass.setBindGroup(0, bindGroup0);\n    }\n    if (setBindGroup2) {\n      renderPass.setBindGroup(1, bindGroup1);\n    }\n    renderPass.draw(3);\n    renderPass.endPass();\n    t.expectValidationError(() => {\n      commandEncoder.finish();\n    }, !_success);\n  });\n\ng.test('bgl_binding_mismatch')\n  .desc(\n    'Tests the binding number must exist or not exist in both bindGroups[i].layout and pipelineLayout.bgls[i]'\n  )\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .expand('call', p => getTestCmds(p.encoderType))\n      .beginSubcases()\n      .combineWithParams([\n        { bgBindings: [0, 1, 2], plBindings: [0, 1, 2], _success: true },\n        { bgBindings: [0, 1, 2], plBindings: [0, 1, 3], _success: false },\n        { bgBindings: [0, 2], plBindings: [0, 2], _success: true },\n        { bgBindings: [0, 2], plBindings: [2, 0], _success: true },\n        { bgBindings: [0, 1, 2], plBindings: [0, 1], _success: false },\n        { bgBindings: [0, 1], plBindings: [0, 1, 2], _success: false },\n      ])\n      .combine('useU32Array', [false, true])\n  )\n  .unimplemented();\n\ng.test('bgl_visibility_mismatch')\n  .desc('Tests the visibility in bindGroups[i].layout and pipelineLayout.bgls[i] must be matched')\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .expand('call', p => getTestCmds(p.encoderType))\n      .beginSubcases()\n      .combine('bgVisibility', kShaderStageCombinations)\n      .expand('plVisibility', p =>\n        p.encoderType === 'compute pass'\n          ? ([GPUConst.ShaderStage.COMPUTE] as const)\n          : ([\n              GPUConst.ShaderStage.VERTEX,\n              GPUConst.ShaderStage.FRAGMENT,\n              GPUConst.ShaderStage.VERTEX | GPUConst.ShaderStage.FRAGMENT,\n            ] as const)\n      )\n      .combine('useU32Array', [false, true])\n  )\n  .unimplemented();\n\ng.test('bgl_resource_type_mismatch')\n  .desc(\n    'Tests the binding resource type in bindGroups[i].layout and pipelineLayout.bgls[i] must be matched'\n  )\n  .params(u =>\n    u\n      .combine('encoderType', kProgrammableEncoderTypes)\n      .expand('call', p => getTestCmds(p.encoderType))\n      .beginSubcases()\n      .combine('bgResourceType', kResourceTypes)\n      .combine('plResourceType', kResourceTypes)\n      .combine('useU32Array', [false, true])\n  )\n  .unimplemented();\n"],"file":"pipeline_bind_group_compat.spec.js"}