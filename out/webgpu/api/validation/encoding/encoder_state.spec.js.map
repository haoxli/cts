{"version":3,"sources":["../../../../../src/webgpu/api/validation/encoding/encoder_state.spec.ts"],"names":["description","makeTestGroup","ValidationTest","F","beginRenderPass","commandEncoder","attachmentTexture","device","createTexture","format","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","trackForCleanup","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","test","desc","paramsSubcasesOnly","u","combine","fn","t","pass0Type","pass1Type","endPasses","params","encoder","createCommandEncoder","firstPass","beginComputePass","secondPass","passes","index","end","expectValidationError","finish","passType","IsEncoderFinished","pass","srcBuffer","createBuffer","GPUBufferUsage","COPY_SRC","dstBuffer","COPY_DST","copyBufferToBuffer"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhBO,CAkBP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,cAAT,QAA+B,uBAA/B;;AAEA,MAAMC,CAAN,SAAgBD,cAAhB,CAA+B;AAC7BE,EAAAA,eAAe,CAACC,cAAD,EAA0D;AACvE,UAAMC,iBAAiB,GAAG,KAAKC,MAAL,CAAYC,aAAZ,CAA0B;AAClDC,MAAAA,MAAM,EAAE,YAD0C;AAElDC,MAAAA,IAAI,EAAE,EAAEC,KAAK,EAAE,EAAT,EAAaC,MAAM,EAAE,EAArB,EAAyBC,kBAAkB,EAAE,CAA7C,EAF4C;AAGlDC,MAAAA,KAAK,EAAEC,eAAe,CAACC,iBAH2B,EAA1B,CAA1B;;AAKA,SAAKC,eAAL,CAAqBX,iBAArB;AACA,WAAOD,cAAc,CAACD,eAAf,CAA+B;AACpCc,MAAAA,gBAAgB,EAAE;AAChB;AACEC,QAAAA,IAAI,EAAEb,iBAAiB,CAACc,UAAlB,EADR;AAEEC,QAAAA,UAAU,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUC,CAAC,EAAE,GAAb,EAAkBC,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAFd;AAGEC,QAAAA,MAAM,EAAE,OAHV;AAIEC,QAAAA,OAAO,EAAE,OAJX,EADgB,CADkB,EAA/B,CAAP;;;;AAUD,GAlB4B;;;AAqB/B,OAAO,MAAMJ,CAAC,GAAGtB,aAAa,CAACE,CAAD,CAAvB;;AAEPoB,CAAC,CAACK,IAAF,CAAO,wBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA,GAPA;;AASGC,kBATH,CASsB,CAAAC,CAAC;AACnBA,CAAC;AACEC,OADH,CACW,WADX,EACwB,CAAC,SAAD,EAAY,QAAZ,CADxB;AAEGA,OAFH,CAEW,WAFX,EAEwB,CAAC,SAAD,EAAY,QAAZ,CAFxB;AAGGA,OAHH,CAGW,WAHX,EAGwB,CAAC,EAAD,EAAK,CAAC,CAAD,CAAL,EAAU,CAAC,CAAD,CAAV,EAAe,CAAC,CAAD,EAAI,CAAJ,CAAf,EAAuB,CAAC,CAAD,EAAI,CAAJ,CAAvB,CAHxB,CAVJ;;AAeGC,EAfH,CAeM,OAAMC,CAAN,KAAW;AACb,QAAM,EAAEC,SAAF,EAAaC,SAAb,EAAwBC,SAAxB,KAAsCH,CAAC,CAACI,MAA9C;;AAEA,QAAMC,OAAO,GAAGL,CAAC,CAAC3B,MAAF,CAASiC,oBAAT,EAAhB;;AAEA,QAAMC,SAAS;AACbN,EAAAA,SAAS,KAAK,SAAd,GAA0BI,OAAO,CAACG,gBAAR,EAA1B,GAAuDR,CAAC,CAAC9B,eAAF,CAAkBmC,OAAlB,CADzD;;AAGA;AACA,QAAMI,UAAU;AACdP,EAAAA,SAAS,KAAK,SAAd,GAA0BG,OAAO,CAACG,gBAAR,EAA1B,GAAuDR,CAAC,CAAC9B,eAAF,CAAkBmC,OAAlB,CADzD;;AAGA,QAAMK,MAAM,GAAG,CAACH,SAAD,EAAYE,UAAZ,CAAf;AACA,OAAK,MAAME,KAAX,IAAoBR,SAApB,EAA+B;AAC7BO,IAAAA,MAAM,CAACC,KAAD,CAAN,CAAcC,GAAd;AACD;;AAEDZ,EAAAA,CAAC,CAACa,qBAAF,CAAwB,MAAM;AAC5BR,IAAAA,OAAO,CAACS,MAAR;AACD,GAFD,EAEG,IAFH;AAGD,CAnCH;;AAqCAzB,CAAC,CAACK,IAAF,CAAO,8BAAP;AACGC,IADH,CACS,oFADT;AAEGC,kBAFH,CAEsB,CAAAC,CAAC;AACnBA,CAAC,CAACC,OAAF,CAAU,UAAV,EAAsB,CAAC,SAAD,EAAY,QAAZ,CAAtB,EAA6CA,OAA7C,CAAqD,mBAArD,EAA0E,CAAC,KAAD,EAAQ,IAAR,CAA1E,CAHJ;;AAKGC,EALH,CAKM,OAAMC,CAAN,KAAW;AACb,QAAM,EAAEe,QAAF,EAAYC,iBAAZ,KAAkChB,CAAC,CAACI,MAA1C;;AAEA,QAAMC,OAAO,GAAGL,CAAC,CAAC3B,MAAF,CAASiC,oBAAT,EAAhB;;AAEA,QAAMW,IAAI,GAAGF,QAAQ,KAAK,SAAb,GAAyBV,OAAO,CAACG,gBAAR,EAAzB,GAAsDR,CAAC,CAAC9B,eAAF,CAAkBmC,OAAlB,CAAnE;AACAY,EAAAA,IAAI,CAACL,GAAL;;AAEA,QAAMM,SAAS,GAAGlB,CAAC,CAAC3B,MAAF,CAAS8C,YAAT,CAAsB;AACtC3C,IAAAA,IAAI,EAAE,IADgC;AAEtCI,IAAAA,KAAK,EAAEwC,cAAc,CAACC,QAFgB,EAAtB,CAAlB;;;AAKA,QAAMC,SAAS,GAAGtB,CAAC,CAAC3B,MAAF,CAAS8C,YAAT,CAAsB;AACtC3C,IAAAA,IAAI,EAAE,IADgC;AAEtCI,IAAAA,KAAK,EAAEwC,cAAc,CAACG,QAFgB,EAAtB,CAAlB;;;AAKA,MAAIP,iBAAJ,EAAuB;AACrBX,IAAAA,OAAO,CAACS,MAAR;AACAd,IAAAA,CAAC,CAACa,qBAAF,CAAwB,MAAM;AAC5BR,MAAAA,OAAO,CAACmB,kBAAR,CAA2BN,SAA3B,EAAsC,CAAtC,EAAyCI,SAAzC,EAAoD,CAApD,EAAuD,CAAvD;AACD,KAFD,EAEGN,iBAFH;AAGD,GALD,MAKO;AACLhB,IAAAA,CAAC,CAACa,qBAAF,CAAwB,MAAM;AAC5BR,MAAAA,OAAO,CAACmB,kBAAR,CAA2BN,SAA3B,EAAsC,CAAtC,EAAyCI,SAAzC,EAAoD,CAApD,EAAuD,CAAvD;AACD,KAFD,EAEGN,iBAFH;AAGAX,IAAAA,OAAO,CAACS,MAAR;AACD;AACF,CAlCH","sourcesContent":["export const description = `\nTODO:\n- createCommandEncoder\n- non-pass command, or beginPass, during {render, compute} pass\n- {before (control case), after} finish()\n    - x= {finish(), ... all non-pass commands}\n- {before (control case), after} end()\n    - x= {render, compute} pass\n    - x= {finish(), ... all relevant pass commands}\n    - x= {\n        - before endPass (control case)\n        - after endPass (no pass open)\n        - after endPass+beginPass (a new pass of the same type is open)\n        - }\n    - should make whole encoder invalid\n- ?\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../validation_test.js';\n\nclass F extends ValidationTest {\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    this.trackForCleanup(attachmentTexture);\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: attachmentTexture.createView(),\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('pass_end_invalid_order')\n  .desc(\n    `\n  Test that beginning a  {compute,render} pass before ending the previous {compute,render} pass\n  causes an error.\n\n  TODO: Need to add a control case to be sure a validation error happens because of ending order.\n  `\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('pass0Type', ['compute', 'render'])\n      .combine('pass1Type', ['compute', 'render'])\n      .combine('endPasses', [[], [0], [1], [0, 1], [1, 0]])\n  )\n  .fn(async t => {\n    const { pass0Type, pass1Type, endPasses } = t.params;\n\n    const encoder = t.device.createCommandEncoder();\n\n    const firstPass =\n      pass0Type === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n\n    // Begin a second pass before ending the previous pass.\n    const secondPass =\n      pass1Type === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n\n    const passes = [firstPass, secondPass];\n    for (const index of endPasses) {\n      passes[index].end();\n    }\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, true);\n  });\n\ng.test('call_after_successful_finish')\n  .desc(`Test that encoding command after a successful finish generates a validation error.`)\n  .paramsSubcasesOnly(u =>\n    u.combine('passType', ['compute', 'render']).combine('IsEncoderFinished', [false, true])\n  )\n  .fn(async t => {\n    const { passType, IsEncoderFinished } = t.params;\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = passType === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n    pass.end();\n\n    const srcBuffer = t.device.createBuffer({\n      size: 1024,\n      usage: GPUBufferUsage.COPY_SRC,\n    });\n\n    const dstBuffer = t.device.createBuffer({\n      size: 1024,\n      usage: GPUBufferUsage.COPY_DST,\n    });\n\n    if (IsEncoderFinished) {\n      encoder.finish();\n      t.expectValidationError(() => {\n        encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, 0);\n      }, IsEncoderFinished);\n    } else {\n      t.expectValidationError(() => {\n        encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, 0);\n      }, IsEncoderFinished);\n      encoder.finish();\n    }\n  });\n"],"file":"encoder_state.spec.js"}