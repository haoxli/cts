{"version":3,"sources":["../../../../../src/webgpu/api/validation/encoding/encoder_state.spec.ts"],"names":["description","makeTestGroup","objectEquals","ValidationTest","F","beginRenderPass","commandEncoder","attachmentTexture","device","createTexture","format","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","trackForCleanup","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","test","desc","params","u","combine","beginSubcases","fn","t","pass0Type","pass1Type","firstPassEnd","endPasses","encoder","createCommandEncoder","firstPass","beginComputePass","end","secondPass","passes","index","valid","expectValidationError","finish","paramsSubcasesOnly","passType","IsEncoderFinished","pass","srcBuffer","createBuffer","GPUBufferUsage","COPY_SRC","dstBuffer","COPY_DST","copyBufferToBuffer","endCount","i","endTwice"],"mappings":"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","sourcesContent":["export const description = `\nTODO:\n- createCommandEncoder\n- non-pass command, or beginPass, during {render, compute} pass\n- {before (control case), after} finish()\n    - x= {finish(), ... all non-pass commands}\n- {before (control case), after} end()\n    - x= {render, compute} pass\n    - x= {finish(), ... all relevant pass commands}\n    - x= {\n        - before endPass (control case)\n        - after endPass (no pass open)\n        - after endPass+beginPass (a new pass of the same type is open)\n        - }\n    - should make whole encoder invalid\n- ?\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { objectEquals } from '../../../../common/util/util.js';\nimport { ValidationTest } from '../validation_test.js';\n\nclass F extends ValidationTest {\n  beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const attachmentTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: { width: 16, height: 16, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    this.trackForCleanup(attachmentTexture);\n    return commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: attachmentTexture.createView(),\n          clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('pass_end_invalid_order')\n  .desc(\n    `\n  Test that beginning a {compute,render} pass before ending the previous {compute,render} pass\n  causes an error.\n\n  TODO: Update this test according to https://github.com/gpuweb/gpuweb/issues/2464\n  `\n  )\n  .params(u =>\n    u\n      .combine('pass0Type', ['compute', 'render'])\n      .combine('pass1Type', ['compute', 'render'])\n      .beginSubcases()\n      .combine('firstPassEnd', [true, false])\n      .combine('endPasses', [[], [0], [1], [0, 1], [1, 0]])\n  )\n  .fn(async t => {\n    const { pass0Type, pass1Type, firstPassEnd, endPasses } = t.params;\n\n    const encoder = t.device.createCommandEncoder();\n\n    const firstPass =\n      pass0Type === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n\n    if (firstPassEnd) firstPass.end();\n\n    // Begin a second pass before ending the previous pass.\n    const secondPass =\n      pass1Type === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n\n    const passes = [firstPass, secondPass];\n    for (const index of endPasses) {\n      passes[index].end();\n    }\n\n    // If {endPasses} is '[1]' and {firstPass} ends, it's a control case.\n    const valid = firstPassEnd && objectEquals(endPasses, [1]);\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, !valid);\n  });\n\ng.test('call_after_successful_finish')\n  .desc(`Test that encoding command after a successful finish generates a validation error.`)\n  .paramsSubcasesOnly(u =>\n    u.combine('passType', ['compute', 'render']).combine('IsEncoderFinished', [false, true])\n  )\n  .fn(async t => {\n    const { passType, IsEncoderFinished } = t.params;\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = passType === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n    pass.end();\n\n    const srcBuffer = t.device.createBuffer({\n      size: 1024,\n      usage: GPUBufferUsage.COPY_SRC,\n    });\n\n    const dstBuffer = t.device.createBuffer({\n      size: 1024,\n      usage: GPUBufferUsage.COPY_DST,\n    });\n\n    if (IsEncoderFinished) {\n      encoder.finish();\n      t.expectValidationError(() => {\n        encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, 0);\n      }, IsEncoderFinished);\n    } else {\n      t.expectValidationError(() => {\n        encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, 0);\n      }, IsEncoderFinished);\n      encoder.finish();\n    }\n  });\n\ng.test('pass_end_none')\n  .desc(\n    `\n  Test that ending a {compute,render} pass without ending the passes generates a validation error.\n  `\n  )\n  .paramsSubcasesOnly(u => u.combine('passType', ['compute', 'render']).combine('endCount', [0, 1]))\n  .fn(async t => {\n    const { passType, endCount } = t.params;\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = passType === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n\n    for (let i = 0; i < endCount; ++i) {\n      pass.end();\n    }\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, endCount === 0);\n  });\n\ng.test('pass_end_twice')\n  .desc('Test that ending a {compute,render} pass twice generates a validation error.')\n  .paramsSubcasesOnly(u =>\n    u //\n      .combine('passType', ['compute', 'render'])\n      .combine('endTwice', [false, true])\n  )\n  .fn(async t => {\n    const { passType, endTwice } = t.params;\n\n    const encoder = t.device.createCommandEncoder();\n\n    const pass = passType === 'compute' ? encoder.beginComputePass() : t.beginRenderPass(encoder);\n\n    pass.end();\n    if (endTwice) {\n      t.expectValidationError(() => {\n        pass.end();\n      });\n    }\n\n    encoder.finish();\n  });\n"],"file":"encoder_state.spec.js"}