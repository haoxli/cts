{"version":3,"sources":["../../src/webgpu/gpu_test.ts"],"names":["Fixture","DevicePool","TestOOMedShouldAttemptGC","attemptGarbageCollection","assert","fillTextureDataWithTexelValue","getTextureCopyLayout","getTexelDataRepresentation","devicePool","GPUTest","undefined","device","objects","queue","init","acquire","defaultQueue","finalize","threw","release","ex","createCopyForMapRead","src","size","dst","createBuffer","usage","GPUBufferUsage","MAP_READ","COPY_DST","c","createCommandEncoder","copyBufferToBuffer","submit","finish","expectContents","expected","buffer","byteLength","eventualAsyncExpectation","niceStack","constructor","actual","mapReadAsync","check","checkBuffer","message","rec","fail","destroy","expectBuffer","exp","Error","tolerance","lines","failedPixels","i","tol","Math","abs","push","expHex","Array","from","Uint8Array","byteOffset","map","x","toString","padStart","join","actHex","expectSingleColor","format","dimension","slice","layout","bytesPerRow","rowsPerImage","expectedTexelData","getBytes","COPY_SRC","commandEncoder","copyTextureToBuffer","texture","mipLevel","arrayLayer","arrayBuffer","ArrayBuffer"],"mappings":"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","sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { DevicePool, TestOOMedShouldAttemptGC } from '../common/framework/gpu/device_pool.js';\nimport { attemptGarbageCollection } from '../common/framework/util/collect_garbage.js';\nimport { assert } from '../common/framework/util/util.js';\n\nimport {\n  fillTextureDataWithTexelValue,\n  getTextureCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, getTexelDataRepresentation } from './util/texture/texelData.js';\n\ntype TypedArrayBufferView =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\ntype TypedArrayBufferViewConstructor =\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst devicePool = new DevicePool();\n\nexport class GPUTest extends Fixture {\n  private objects: { device: GPUDevice; queue: GPUQueue } | undefined = undefined;\n  initialized = false;\n\n  get device(): GPUDevice {\n    assert(this.objects !== undefined);\n    return this.objects.device;\n  }\n\n  get queue(): GPUQueue {\n    assert(this.objects !== undefined);\n    return this.objects.queue;\n  }\n\n  async init(): Promise<void> {\n    await super.init();\n\n    const device = await devicePool.acquire();\n    const queue = device.defaultQueue;\n    this.objects = { device, queue };\n  }\n\n  // Note: finalize is called even if init was unsuccessful.\n  async finalize(): Promise<void> {\n    await super.finalize();\n\n    if (this.objects) {\n      let threw: undefined | Error;\n      {\n        const objects = this.objects;\n        this.objects = undefined;\n        try {\n          await devicePool.release(objects.device);\n        } catch (ex) {\n          threw = ex;\n        }\n      }\n      // The GPUDevice and GPUQueue should now have no outstanding references.\n\n      if (threw) {\n        if (threw instanceof TestOOMedShouldAttemptGC) {\n          // Try to clean up, in case there are stray GPU resources in need of collection.\n          await attemptGarbageCollection();\n        }\n        throw threw;\n      }\n    }\n  }\n\n  createCopyForMapRead(src: GPUBuffer, size: number): GPUBuffer {\n    const dst = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    const c = this.device.createCommandEncoder();\n    c.copyBufferToBuffer(src, 0, dst, 0, size);\n\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  // TODO: add an expectContents for textures, which logs data: uris on failure\n\n  expectContents(src: GPUBuffer, expected: TypedArrayBufferView): void {\n    const dst = this.createCopyForMapRead(src, expected.buffer.byteLength);\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const constructor = expected.constructor as TypedArrayBufferViewConstructor;\n      const actual = new constructor(await dst.mapReadAsync());\n      const check = this.checkBuffer(actual, expected);\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.fail(niceStack);\n      }\n      dst.destroy();\n    });\n  }\n\n  expectBuffer(actual: Uint8Array, exp: Uint8Array): void {\n    const check = this.checkBuffer(actual, exp);\n    if (check !== undefined) {\n      this.rec.fail(new Error(check));\n    }\n  }\n\n  checkBuffer(\n    actual: TypedArrayBufferView,\n    exp: TypedArrayBufferView,\n    tolerance: number | ((i: number) => number) = 0\n  ): string | undefined {\n    assert(actual.constructor === exp.constructor);\n\n    const size = exp.byteLength;\n    if (actual.byteLength !== size) {\n      return 'size mismatch';\n    }\n    const lines = [];\n    let failedPixels = 0;\n    for (let i = 0; i < size; ++i) {\n      const tol = typeof tolerance === 'function' ? tolerance(i) : tolerance;\n      if (Math.abs(actual[i] - exp[i]) > tol) {\n        if (failedPixels > 4) {\n          lines.push('... and more');\n          break;\n        }\n        failedPixels++;\n        lines.push(`at [${i}], expected ${exp[i]}, got ${actual[i]}`);\n      }\n    }\n\n    // TODO: Could make a more convenient message, which could look like e.g.:\n    //\n    //   Starting at offset 48,\n    //              got 22222222 ABCDABCD 99999999\n    //     but expected 22222222 55555555 99999999\n    //\n    // or\n    //\n    //   Starting at offset 0,\n    //              got 00000000 00000000 00000000 00000000 (... more)\n    //     but expected 00FF00FF 00FF00FF 00FF00FF 00FF00FF (... more)\n    //\n    // Or, maybe these diffs aren't actually very useful (given we have the prints just above here),\n    // and we should remove them. More important will be logging of texture data in a visual format.\n\n    if (size <= 256 && failedPixels > 0) {\n      const expHex = Array.from(new Uint8Array(exp.buffer, exp.byteOffset, exp.byteLength))\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n      const actHex = Array.from(new Uint8Array(actual.buffer, actual.byteOffset, actual.byteLength))\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n      lines.push('EXPECT:\\t  ' + exp.join(' '));\n      lines.push('\\t0x' + expHex);\n      lines.push('ACTUAL:\\t  ' + actual.join(' '));\n      lines.push('\\t0x' + actHex);\n    }\n    if (failedPixels) {\n      return lines.join('\\n');\n    }\n    return undefined;\n  }\n\n  expectSingleColor(\n    src: GPUTexture,\n    format: GPUTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    const { byteLength, bytesPerRow, rowsPerImage } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n    const expectedTexelData = getTexelDataRepresentation(format).getBytes(exp);\n\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, arrayLayer: slice },\n      { buffer, bytesPerRow, rowsPerImage },\n      size\n    );\n    this.queue.submit([commandEncoder.finish()]);\n    const arrayBuffer = new ArrayBuffer(byteLength);\n    fillTextureDataWithTexelValue(expectedTexelData, format, dimension, arrayBuffer, size, layout);\n    this.expectContents(buffer, new Uint8Array(arrayBuffer));\n  }\n}\n"],"file":"gpu_test.js"}