{"version":3,"sources":["../../src/webgpu/gpu_test.ts"],"names":["Fixture","attemptGarbageCollection","assert","unreachable","kTextureFormatInfo","kQueryTypeInfo","makeBufferWithContents","checkElementsEqual","checkElementsBetween","checkElementsFloat16Between","DevicePool","TestOOMedShouldAttemptGC","align","roundDown","fillTextureDataWithTexelValue","getTextureCopyLayout","kTexelRepresentationInfo","devicePool","GPUTest","device","provider","undefined","acquiredDevice","acquire","queue","init","reserve","finalize","threw","release","ex","selectDeviceOrSkipTestCase","descriptor","requiredFeatures","Array","filter","f","oldProvider","selectDeviceForTextureFormatOrSkipTestCase","formats","isArray","features","Set","format","add","feature","from","selectDeviceForQueryTypeOrSkipTestCase","types","map","t","createCopyForMapRead","src","srcOffset","size","dst","createBuffer","usage","GPUBufferUsage","MAP_READ","COPY_DST","trackForCleanup","c","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","subarrayByteStart","alignedSize","mappable","readGPUBufferRangeTyped","srcByteOffset","method","type","typedLength","BYTES_PER_ELEMENT","byteLength","mapOffset","mapSize","subarrayStart","mapAsync","GPUMapMode","READ","mapped","getMappedRange","data","subarray","cleanup","unmap","destroy","expectGPUBufferValuesPassCheck","check","mode","readbackPromise","eventualAsyncExpectation","niceStack","readback","expectOK","expectGPUBufferValuesEqual","expected","a","constructor","length","expectSingleColor","exp","dimension","slice","layout","bytesPerRow","rowsPerImage","mipSize","rep","expectedTexelData","pack","encode","buffer","COPY_SRC","commandEncoder","copyTextureToBuffer","texture","mipLevel","origin","x","y","z","arrayBuffer","ArrayBuffer","Uint8Array","readSinglePixelFrom2DTexture","expectSinglePixelIn2DTexture","generateWarningOnly","expectSinglePixelBetweenTwoValuesIn2DTexture","checkElementsBetweenFn","expectSinglePixelBetweenTwoValuesFloat16In2DTexture","expectGPUError","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","message","rec","expectationFailed","debug","dataArray","opts","createTexture2DWithMipmaps","mipmapDataArray","mipLevelCount","textureSizeMipmap0","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","TEXTURE_BINDING","textureEncoder","i","mipLevelData","r","o","end","copyBufferToTexture"],"mappings":"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","sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { attemptGarbageCollection } from '../common/util/collect_garbage.js';\nimport {\n  assert,\n  TypedArrayBufferView,\n  TypedArrayBufferViewConstructor,\n  unreachable,\n} from '../common/util/util.js';\n\nimport {\n  EncodableTextureFormat,\n  SizedTextureFormat,\n  kTextureFormatInfo,\n  kQueryTypeInfo,\n} from './capability_info.js';\nimport { makeBufferWithContents } from './util/buffer.js';\nimport {\n  checkElementsEqual,\n  checkElementsBetween,\n  checkElementsFloat16Between,\n} from './util/check_contents.js';\nimport {\n  DevicePool,\n  DeviceProvider,\n  TestOOMedShouldAttemptGC,\n  UncanonicalizedDeviceDescriptor,\n} from './util/device_pool.js';\nimport { align, roundDown } from './util/math.js';\nimport {\n  fillTextureDataWithTexelValue,\n  getTextureCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, kTexelRepresentationInfo } from './util/texture/texel_data.js';\n\nconst devicePool = new DevicePool();\n\n/**\n * Base fixture for WebGPU tests.\n */\nexport class GPUTest extends Fixture {\n  private provider: DeviceProvider | undefined;\n  /** Must not be replaced once acquired. */\n  private acquiredDevice: GPUDevice | undefined;\n\n  /** GPUDevice for the test to use. */\n  get device(): GPUDevice {\n    assert(\n      this.provider !== undefined,\n      'No provider available right now; did you \"await\" selectDeviceOrSkipTestCase?'\n    );\n    if (!this.acquiredDevice) {\n      this.acquiredDevice = this.provider.acquire();\n    }\n    return this.acquiredDevice;\n  }\n\n  /** GPUQueue for the test to use. (Same as `t.device.queue`.) */\n  get queue(): GPUQueue {\n    return this.device.queue;\n  }\n\n  protected async init(): Promise<void> {\n    await super.init();\n\n    this.provider = await devicePool.reserve();\n  }\n\n  protected async finalize(): Promise<void> {\n    await super.finalize();\n\n    if (this.provider) {\n      let threw: undefined | Error;\n      {\n        const provider = this.provider;\n        this.provider = undefined;\n        try {\n          await devicePool.release(provider);\n        } catch (ex) {\n          threw = ex;\n        }\n      }\n      // The GPUDevice and GPUQueue should now have no outstanding references.\n\n      if (threw) {\n        if (threw instanceof TestOOMedShouldAttemptGC) {\n          // Try to clean up, in case there are stray GPU resources in need of collection.\n          await attemptGarbageCollection();\n        }\n        throw threw;\n      }\n    }\n  }\n\n  /**\n   * When a GPUTest test accesses `.device` for the first time, a \"default\" GPUDevice\n   * (descriptor = `undefined`) is provided by default.\n   * However, some tests or cases need particular nonGuaranteedFeatures to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to select a\n   * GPUDevice with matching capabilities.\n   *\n   * If the request descriptor can't be supported, throws an exception to skip the entire test case.\n   */\n  async selectDeviceOrSkipTestCase(\n    descriptor:\n      | UncanonicalizedDeviceDescriptor\n      | GPUFeatureName\n      | undefined\n      | Array<GPUFeatureName | undefined>\n  ): Promise<void> {\n    if (descriptor === undefined) return;\n    if (typeof descriptor === 'string') {\n      descriptor = { requiredFeatures: [descriptor] };\n    } else if (descriptor instanceof Array) {\n      descriptor = {\n        requiredFeatures: descriptor.filter(f => f !== undefined) as GPUFeatureName[],\n      };\n    }\n\n    assert(this.provider !== undefined);\n    // Make sure the device isn't replaced after it's been retrieved once.\n    assert(\n      !this.acquiredDevice,\n      \"Can't selectDeviceOrSkipTestCase() after the device has been used\"\n    );\n\n    const oldProvider = this.provider;\n    this.provider = undefined;\n    await devicePool.release(oldProvider);\n\n    this.provider = await devicePool.reserve(descriptor);\n    this.acquiredDevice = this.provider.acquire();\n  }\n\n  /**\n   * Create device with texture format(s) required feature(s).\n   * If the device creation fails, then skip the test for that format(s).\n   */\n  async selectDeviceForTextureFormatOrSkipTestCase(\n    formats: GPUTextureFormat | undefined | (GPUTextureFormat | undefined)[]\n  ): Promise<void> {\n    if (!Array.isArray(formats)) {\n      formats = [formats];\n    }\n    const features = new Set<GPUFeatureName | undefined>();\n    for (const format of formats) {\n      if (format !== undefined) {\n        features.add(kTextureFormatInfo[format].feature);\n      }\n    }\n\n    await this.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n\n  /**\n   * Create device with query type(s) required feature(s).\n   * If the device creation fails, then skip the test for that type(s).\n   */\n  async selectDeviceForQueryTypeOrSkipTestCase(\n    types: GPUQueryType | GPUQueryType[]\n  ): Promise<void> {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const features = types.map(t => kQueryTypeInfo[t].feature);\n    await this.selectDeviceOrSkipTestCase(features);\n  }\n\n  /** Snapshot a GPUBuffer's contents, returning a new GPUBuffer with the `MAP_READ` usage. */\n  private createCopyForMapRead(src: GPUBuffer, srcOffset: number, size: number): GPUBuffer {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(dst);\n\n    const c = this.device.createCommandEncoder();\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  /**\n   * Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n   * we might need to copy more bytes from the buffer than we want to map.\n   * begin and end values represent the part of the copied buffer that stores the contents\n   * we initially wanted to map.\n   * The copy will not cause an OOB error because the buffer size must be 4-aligned.\n   */\n  private createAlignedCopyForMapRead(\n    src: GPUBuffer,\n    size: number,\n    offset: number\n  ): { mappable: GPUBuffer; subarrayByteStart: number } {\n    const alignedOffset = roundDown(offset, 4);\n    const subarrayByteStart = offset - alignedOffset;\n    const alignedSize = align(size + subarrayByteStart, 4);\n    const mappable = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { mappable, subarrayByteStart };\n  }\n\n  /**\n   * Snapshot the current contents of a range of a GPUBuffer, and return them as a TypedArray.\n   * Also provides a cleanup() function to unmap and destroy the staging buffer.\n   */\n  async readGPUBufferRangeTyped<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    {\n      srcByteOffset = 0,\n      method = 'copy',\n      type,\n      typedLength,\n    }: {\n      srcByteOffset?: number;\n      method?: 'copy' | 'map';\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n    }\n  ): Promise<{ data: T; cleanup(): void }> {\n    assert(\n      srcByteOffset % type.BYTES_PER_ELEMENT === 0,\n      'srcByteOffset must be a multiple of BYTES_PER_ELEMENT'\n    );\n\n    const byteLength = typedLength * type.BYTES_PER_ELEMENT;\n    let mappable: GPUBuffer;\n    let mapOffset: number | undefined, mapSize: number | undefined, subarrayByteStart: number;\n    if (method === 'copy') {\n      ({ mappable, subarrayByteStart } = this.createAlignedCopyForMapRead(\n        src,\n        byteLength,\n        srcByteOffset\n      ));\n    } else if (method === 'map') {\n      mappable = src;\n      mapOffset = roundDown(srcByteOffset, 8);\n      mapSize = align(byteLength, 4);\n      subarrayByteStart = srcByteOffset - mapOffset;\n    } else {\n      unreachable();\n    }\n\n    assert(subarrayByteStart % type.BYTES_PER_ELEMENT === 0);\n    const subarrayStart = subarrayByteStart / type.BYTES_PER_ELEMENT;\n\n    // 2. Map the staging buffer, and create the TypedArray from it.\n    await mappable.mapAsync(GPUMapMode.READ, mapOffset, mapSize);\n    const mapped = new type(mappable.getMappedRange(mapOffset, mapSize));\n    const data = mapped.subarray(subarrayStart, typedLength) as T;\n\n    return {\n      data,\n      cleanup() {\n        mappable.unmap();\n        mappable.destroy();\n      },\n    };\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to pass the provided check.\n   */\n  expectGPUBufferValuesPassCheck<T extends TypedArrayBufferView>(\n    src: GPUBuffer,\n    check: (actual: T) => Error | undefined,\n    {\n      srcByteOffset = 0,\n      type,\n      typedLength,\n      method = 'copy',\n      mode = 'fail',\n    }: {\n      srcByteOffset?: number;\n      type: TypedArrayBufferViewConstructor<T>;\n      typedLength: number;\n      method?: 'copy' | 'map';\n      mode?: 'fail' | 'warn';\n    }\n  ) {\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      srcByteOffset,\n      type,\n      typedLength,\n      method,\n    });\n    this.eventualAsyncExpectation(async niceStack => {\n      const readback = await readbackPromise;\n      this.expectOK(check(readback.data), { mode, niceStack });\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to equal the values in the provided TypedArray.\n   */\n  expectGPUBufferValuesEqual(\n    src: GPUBuffer,\n    expected: TypedArrayBufferView,\n    srcByteOffset: number = 0,\n    { method = 'copy', mode = 'fail' }: { method?: 'copy' | 'map'; mode?: 'fail' | 'warn' } = {}\n  ): void {\n    this.expectGPUBufferValuesPassCheck(src, a => checkElementsEqual(a, expected), {\n      srcByteOffset,\n      type: expected.constructor as TypedArrayBufferViewConstructor,\n      typedLength: expected.length,\n      method,\n      mode,\n    });\n  }\n\n  // TODO: add an expectContents for textures, which logs data: uris on failure\n\n  /**\n   * Expect a whole GPUTexture to have the single provided color.\n   */\n  expectSingleColor(\n    src: GPUTexture,\n    format: EncodableTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n    const rep = kTexelRepresentationInfo[format];\n    const expectedTexelData = rep.pack(rep.encode(exp));\n\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(buffer);\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x: 0, y: 0, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n    const arrayBuffer = new ArrayBuffer(byteLength);\n    fillTextureDataWithTexelValue(expectedTexelData, format, dimension, arrayBuffer, size, layout);\n    this.expectGPUBufferValuesEqual(buffer, new Uint8Array(arrayBuffer));\n  }\n\n  /** Return a GPUBuffer that data are going to be written into. */\n  private readSinglePixelFrom2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    { slice = 0, layout }: { slice?: number; layout?: TextureLayoutOptions }\n  ): GPUBuffer {\n    const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      '2d',\n      [1, 1, 1],\n      layout\n    );\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    this.trackForCleanup(buffer);\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x, y, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    return buffer;\n  }\n\n  /**\n   * Expect a single pixel of a 2D texture to have a particular byte representation.\n   *\n   * TODO: Add check for values of depth/stencil, probably through sampling of shader\n   * TODO: Can refactor this and expectSingleColor to use a similar base expect\n   */\n  expectSinglePixelIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: Uint8Array;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesEqual(buffer, exp, 0, {\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Take a single pixel of a 2D texture, interpret it using a TypedArray of the `expected` type,\n   * and expect each value in that array to be between the corresponding \"expected\" values\n   * (either `a[i] <= actual[i] <= b[i]` or `a[i] >= actual[i] => b[i]`).\n   */\n  expectSinglePixelBetweenTwoValuesIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n      checkElementsBetweenFn = checkElementsBetween,\n    }: {\n      exp: [TypedArrayBufferView, TypedArrayBufferView];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n      checkElementsBetweenFn?: (\n        actual: TypedArrayBufferView,\n        expected: readonly [TypedArrayBufferView, TypedArrayBufferView]\n      ) => Error | undefined;\n    }\n  ): void {\n    assert(exp[0].constructor === exp[1].constructor);\n    const constructor = exp[0].constructor as TypedArrayBufferViewConstructor;\n    assert(exp[0].length === exp[1].length);\n    const typedLength = exp[0].length;\n\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesPassCheck(buffer, a => checkElementsBetweenFn(a, exp), {\n      type: constructor,\n      typedLength,\n      mode: generateWarningOnly ? 'warn' : 'fail',\n    });\n  }\n\n  /**\n   * Equivalent to {@link expectSinglePixelBetweenTwoValuesIn2DTexture} but uses a special check func\n   * to interpret incoming values as float16\n   */\n  expectSinglePixelBetweenTwoValuesFloat16In2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: [Uint16Array, Uint16Array];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    this.expectSinglePixelBetweenTwoValuesIn2DTexture(\n      src,\n      format,\n      { x, y },\n      {\n        exp,\n        slice,\n        layout,\n        generateWarningOnly,\n        checkElementsBetweenFn: checkElementsFloat16Between,\n      }\n    );\n  }\n\n  /**\n   * Expect the specified WebGPU error to be generated when running the provided function.\n   */\n  expectGPUError<R>(filter: GPUErrorFilter, fn: () => R, shouldError: boolean = true): R {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Create a GPUBuffer with the specified contents and usage.\n   *\n   * TODO: Several call sites would be simplified if this took ArrayBuffer as well.\n   */\n  makeBufferWithContents(\n    dataArray: TypedArrayBufferView,\n    usage: GPUBufferUsageFlags,\n    opts: { padToMultipleOf4?: boolean } = {}\n  ): GPUBuffer {\n    return this.trackForCleanup(makeBufferWithContents(this.device, dataArray, usage, opts));\n  }\n\n  /**\n   * Create a GPUTexture with multiple mip levels, each having the specified contents.\n   */\n  createTexture2DWithMipmaps(mipmapDataArray: TypedArrayBufferView[]): GPUTexture {\n    const format = 'rgba8unorm';\n    const mipLevelCount = mipmapDataArray.length;\n    const textureSizeMipmap0 = 1 << (mipLevelCount - 1);\n    const texture = this.device.createTexture({\n      mipLevelCount,\n      size: { width: textureSizeMipmap0, height: textureSizeMipmap0, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING,\n    });\n    this.trackForCleanup(texture);\n\n    const textureEncoder = this.device.createCommandEncoder();\n    for (let i = 0; i < mipLevelCount; i++) {\n      const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n        format,\n        '2d',\n        [textureSizeMipmap0, textureSizeMipmap0, 1],\n        { mipLevel: i }\n      );\n\n      const data: Uint8Array = new Uint8Array(byteLength);\n      const mipLevelData = mipmapDataArray[i];\n      assert(rowsPerImage === mipSize[0]); // format is rgba8unorm and block size should be 1\n      for (let r = 0; r < rowsPerImage; r++) {\n        const o = r * bytesPerRow;\n        for (let c = o, end = o + mipSize[1] * 4; c < end; c += 4) {\n          data[c] = mipLevelData[0];\n          data[c + 1] = mipLevelData[1];\n          data[c + 2] = mipLevelData[2];\n          data[c + 3] = mipLevelData[3];\n        }\n      }\n      const buffer = this.makeBufferWithContents(\n        data,\n        GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n      );\n\n      textureEncoder.copyBufferToTexture(\n        { buffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel: i, origin: [0, 0, 0] },\n        mipSize\n      );\n    }\n    this.device.queue.submit([textureEncoder.finish()]);\n\n    return texture;\n  }\n}\n"],"file":"gpu_test.js"}