{"version":3,"file":"floating_point.js","names":["assert","unreachable","Float16Array","kValue","f32","reinterpretF32AsU32","reinterpretU32AsF32","calculatePermutations","cartesianProduct","correctlyRoundedF16","correctlyRoundedF32","flatten2DArray","flushSubnormalNumberF32","isFiniteF16","isFiniteF32","isSubnormalNumberF16","isSubnormalNumberF32","map2DArray","oneULPF32","unflatten2DArray","FPInterval","constructor","kind","bounds","begin","end","length","Number","isNaN","traits","FP","isPoint","contains","n","NEGATIVE_INFINITY","POSITIVE_INFINITY","containsZeroOrSubnormals","constants","negative","subnormal","min","positive","max","isFinite","toString","map","scalarBuilder","serializeFPInterval","i","anyInterval","deserializeFPInterval","data","toInterval","addFlushedIfNeededF16","values","some","v","concat","FPTraits","k","Array","spanIntervals","intervals","every","forEach","Math","isVector","e","toVector","f","spanVectors","vectors","vector_length","result","isMatrix","m","c","num_rows","toMatrix","bind","spanMatrices","matrices","ms","num_cols","r","_","j","addFlushedIfNeeded","subnormals","filter","isSubnormal","needs_zero","s","limitPointToIntervalDomain","domain","impl","limitBinaryToIntervalDomain","x","y","d","roundAndFlushPointToInterval","op","correctlyRounded","inputs","results","Set","roundAndFlushBinaryToInterval","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","roundAndFlushVectorToInterval","x_rounded","x_flushed","roundAndFlushVectorPairToInterval","y_rounded","y_flushed","roundAndFlushVectorToVector","interval_vectors","roundAndFlushVectorPairToVector","roundAndFlushMatrixToMatrix","m_flat","m_rounded","m_flushed","m_options","m_inputs","interval_matrices","inner_m","runPointToIntervalOp","extrema","undefined","b","runBinaryToIntervalOp","outputs","runTernaryToIntervalOp","runVectorToIntervalOp","runVectorPairToIntervalOp","runVectorToVectorOp","anyVector","runPointToIntervalOpComponentWise","runVectorPairToVectorOp","runBinaryToIntervalOpVectorComponentWise","idx","runMatrixToMatrixOp","anyMatrix","m_values","unflat_m","result_cols","result_rows","runBinaryToIntervalOpMatrixComponentWise","cols","rows","flat_x","flat_y","CorrectlyRoundedIntervalOp","correctlyRoundedInterval","correctlyRoundedMatrix","AbsoluteErrorIntervalOp","error_range","absoluteErrorInterval","abs","ULPIntervalOp","numULP","ulp","oneULP","flushSubnormal","ulpInterval","AbsIntervalOp","absInterval","AcosIntervalOp","sqrtInterval","subtractionInterval","multiplicationInterval","atan2Interval","acos","acosInterval","acoshIntervals","acoshAlternativeInterval","acoshPrimaryInterval","AcoshAlternativeIntervalOp","inner_value","additionInterval","sqrt_value","logInterval","AcoshPrimaryIntervalOp","AdditionIntervalOp","additionMatrixInterval","AsinIntervalOp","asin","asinInterval","AsinhIntervalOp","asinhInterval","AtanIntervalOp","atan","atanInterval","Atan2IntervalOp","atan_yx","pi","whole","AtanhIntervalOp","numerator","denominator","log_interval","divisionInterval","atanhInterval","CeilIntervalOp","ceil","ceilInterval","clampIntervals","clampMinMaxInterval","clampMedianInterval","ClampMedianIntervalOp","sort","a","ClampMinMaxIntervalOp","low","high","minInterval","maxInterval","CosIntervalOp","negPiToPiInterval","cos","cosInterval","CoshIntervalOp","minus_n","negationInterval","expInterval","coshInterval","CrossIntervalOp","r0","r1","r2","crossInterval","DegreesIntervalOp","degreesInterval","minorNxN","col","row","dim","col_indices","keys","row_indices","determinant2x2Interval","determinant3x3Interval","A","B","C","permutations","p","reduce","prev","cur","determinant4x4Interval","D","determinantInterval","DistanceIntervalScalarOp","lengthInterval","DistanceIntervalVectorOp","SubtractionIntervalOp","distanceInterval","DivisionIntervalOp","DotIntervalOp","multiplications","MultiplicationIntervalOp","dotInterval","ExpIntervalOp","exp","Exp2IntervalOp","pow","exp2Interval","faceForwardIntervals","x_vec","positive_x","negative_x","NegationIntervalOp","dot_interval","push","FloorIntervalOp","floor","floorInterval","FmaIntervalOp","fmaInterval","FractIntervalOp","less_than_one","fractInterval","InverseSqrtIntervalOp","greaterThanZeroInterval","sqrt","inverseSqrtInterval","LdexpIntervalOp","e1","e2","ldexpInterval","LengthIntervalScalarOp","LengthIntervalVectorOp","LogIntervalOp","log","Log2IntervalOp","log2","log2Interval","MaxIntervalOp","MinIntervalOp","mixIntervals","mixImpreciseInterval","mixPreciseInterval","MixImpreciseIntervalOp","t","MixPreciseIntervalOp","modfInterval","fract","MultiplicationInnerOp","multiplyVectorByScalar","multiplicationMatrixScalarInterval","mat","scalar","multiplicationScalarMatrixInterval","multiplicationMatrixMatrixInterval","mat_x","mat_y","x_cols","x_rows","y_cols","y_rows","x_transposed","transposeInterval","multiplicationMatrixVectorInterval","multiplicationVectorMatrixInterval","NormalizeIntervalOp","normalizeInterval","PowIntervalOp","powInterval","QuantizeToF16IntervalOp","rounded","flushed","quantizeToF16Interval","RadiansIntervalOp","radiansInterval","ReflectIntervalOp","rhs","reflectInterval","refractInterval","r_squared","dot","dot_squared","one_minus_dot_squared","zeroVector","dot_times_r","k_sqrt","RemainderIntervalOp","truncInterval","remainderInterval","RoundIntervalOp","diff_before","diff_after","roundInterval","saturateInterval","SignIntervalOp","signInterval","SinIntervalOp","sin","sinInterval","SinhIntervalOp","sinhInterval","SmoothStepOp","smoothStepInterval","SqrtIntervalOp","StepIntervalOp","edge","stepInterval","subtractionMatrixInterval","TanIntervalOp","tanInterval","TanhIntervalOp","tanhInterval","TransposeIntervalOp","TruncIntervalOp","trunc","unpackData","ArrayBuffer","unpackDataU32","Uint32Array","unpackDataU16","Uint16Array","unpackDataU8","Uint8Array","unpackDataI16","Int16Array","unpackDataI8","Int8Array","unpackDataF16","unpack2x16floatInterval","u32","unpack2x16snormInterval","unpack2x16unormInterval","unpack4x8snormInterval","unpack4x8unormInterval","kF32AnyInterval","kF32ZeroInterval","F32Traits","_constants","infinity","nearest_max","three_quarters","half","third","quarter","sixth","nearest_min","zeroInterval"],"sources":["../../../src/webgpu/util/floating_point.ts"],"sourcesContent":["import { assert, unreachable } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kValue } from './constants.js';\nimport { f32, reinterpretF32AsU32, reinterpretU32AsF32, Scalar } from './conversion.js';\nimport {\n  calculatePermutations,\n  cartesianProduct,\n  correctlyRoundedF16,\n  correctlyRoundedF32,\n  flatten2DArray,\n  FlushMode,\n  flushSubnormalNumberF32,\n  isFiniteF16,\n  isFiniteF32,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  map2DArray,\n  oneULPF32,\n  unflatten2DArray,\n} from './math.js';\n\n/** Indicate the kind of WGSL floating point numbers being operated on */\nexport type FPKind = 'f32';\n\n// Containers\n\n/**\n * Representation of bounds for an interval as an array with either one or two\n * elements. Single element indicates that the interval is a single point. For\n * two elements, the first is the lower bound of the interval and the second is\n * the upper bound.\n */\nexport type IntervalBounds = [number] | [number, number];\n\n/** Represents a closed interval of floating point numbers */\nexport class FPInterval {\n  public readonly kind: FPKind;\n  public readonly begin: number;\n  public readonly end: number;\n\n  /**\n   * Constructor\n   *\n   * `FPTraits.toInterval` is the preferred way to create FPIntervals\n   *\n   * @param kind the floating point number type this is an interval for\n   * @param bounds beginning and end of the interval\n   */\n  public constructor(kind: FPKind, ...bounds: IntervalBounds) {\n    this.kind = kind;\n\n    const [begin, end] = bounds.length === 2 ? bounds : [bounds[0], bounds[0]];\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `bounds[0] (${begin}) must be less than or equal to bounds[1]  (${end})`);\n\n    this.begin = begin;\n    this.end = end;\n  }\n\n  /** @returns the floating point traits for this interval */\n  public traits(): FPTraits {\n    return FP[this.kind];\n  }\n\n  /** @returns begin and end if non-point interval, otherwise just begin */\n  public bounds(): IntervalBounds {\n    return this.isPoint() ? [this.begin] : [this.begin, this.end];\n  }\n\n  /** @returns if a point or interval is completely contained by this interval */\n  public contains(n: number | FPInterval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the 'any' interval indicates that accuracy is not defined for this\n      // test, so the test is just checking that this input doesn't cause the\n      // implementation to misbehave, so NaN is accepted.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n\n    if (n instanceof FPInterval) {\n      return this.begin <= n.begin && this.end >= n.end;\n    }\n    return this.begin <= n && this.end >= n;\n  }\n\n  /** @returns if any values in the interval may be flushed to zero, this\n   *           includes any subnormals and zero itself.\n   */\n  public containsZeroOrSubnormals(): boolean {\n    return !(\n      this.end < this.traits().constants().negative.subnormal.min ||\n      this.begin > this.traits().constants().positive.subnormal.max\n    );\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns if this interval only contains f32 finite values */\n  public isFinite(): boolean {\n    return this.traits().isFinite(this.begin) && this.traits().isFinite(this.end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `{ '${this.kind}', [${this.bounds().map(this.traits().scalarBuilder)}] }`;\n  }\n}\n\n/**\n * SerializedFPInterval holds the serialized form of a FPInterval.\n * This form can be safely encoded to JSON.\n */\n// When non-f32 traits are defined this will need to be extended to include a\n// kind entry to differentiate.\nexport type SerializedFPInterval = { begin: number; end: number } | 'any';\n\n/** serializeFPInterval() converts a FPInterval to a SerializedFPInterval */\nexport function serializeFPInterval(i: FPInterval): SerializedFPInterval {\n  // When non-f32 traits are defined this will need to be re-written to pull\n  // the kind from i to get the traits, and embed the kind in the serialized\n  // form\n  return i === FP['f32'].constants().anyInterval\n    ? 'any'\n    : { begin: reinterpretF32AsU32(i.begin), end: reinterpretF32AsU32(i.end) };\n}\n\n/** serializeFPInterval() converts a SerializedFPInterval to a FPInterval */\nexport function deserializeFPInterval(data: SerializedFPInterval): FPInterval {\n  // When non-f32 traits are defined this will need to be re-written to pull\n  // the kind from serialized data to get the traits and perform unpacking\n  const traits = FP['f32'];\n  return data === 'any'\n    ? traits.constants().anyInterval\n    : traits.toInterval([reinterpretU32AsF32(data.begin), reinterpretU32AsF32(data.end)]);\n}\n\n/**\n * Representation of a vec2/3/4 of floating point intervals as an array of\n * FPIntervals.\n */\nexport type FPVector =\n  | [FPInterval, FPInterval]\n  | [FPInterval, FPInterval, FPInterval]\n  | [FPInterval, FPInterval, FPInterval, FPInterval];\n\n/**\n * Shorthand for an Array of Arrays that contains a column-major matrix\n *\n * This isn't exported outside of this file to avoid colliding with the Matrix\n * container for going in/out of a shader that the test runner uses.\n */\ntype Matrix<T> = T[][];\n\n/**\n * Representation of a matCxR of floating point intervals as an array of arrays\n * of FPIntervals. This maps onto the WGSL concept of matrix. Internally\n */\nexport type FPMatrix =\n  | [[FPInterval, FPInterval], [FPInterval, FPInterval]]\n  | [[FPInterval, FPInterval], [FPInterval, FPInterval], [FPInterval, FPInterval]]\n  | [\n      [FPInterval, FPInterval],\n      [FPInterval, FPInterval],\n      [FPInterval, FPInterval],\n      [FPInterval, FPInterval]\n    ]\n  | [[FPInterval, FPInterval, FPInterval], [FPInterval, FPInterval, FPInterval]]\n  | [\n      [FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval]\n    ]\n  | [\n      [FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval]\n    ]\n  | [\n      [FPInterval, FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval, FPInterval]\n    ]\n  | [\n      [FPInterval, FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval, FPInterval]\n    ]\n  | [\n      [FPInterval, FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval, FPInterval],\n      [FPInterval, FPInterval, FPInterval, FPInterval]\n    ];\n\n// Utilities\n\n/** @returns input with an appended 0, if inputs contains non-zero subnormals */\n// When f16 traits is defined, this can be replaced with something like\n// `FP.f16..addFlushIfNeeded`\nfunction addFlushedIfNeededF16(values: number[]): number[] {\n  return values.some(v => v !== 0 && isSubnormalNumberF16(v)) ? values.concat(0) : values;\n}\n\n// Operations\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): FPInterval;\n}\n\n/** Operation used to implement a PointToInterval */\ninterface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: PointToInterval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * Used by this.runPointToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for operations that meet all the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | FPInterval, not x: number\n   */\n  extrema?: (x: FPInterval) => FPInterval;\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): FPInterval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: BinaryToInterval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * Used by runBinaryToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: FPInterval, y: FPInterval) => [FPInterval, FPInterval];\n}\n\n/** Domain for a BinaryToInterval implementation */\ninterface BinaryToIntervalDomain {\n  // Arrays to support discrete valid domain intervals\n  x: FPInterval[];\n  y: FPInterval[];\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): FPInterval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: TernaryToInterval;\n}\n\n// Currently PointToVector is not integrated with the rest of the floating point\n// framework, because the only builtins that use it are actually\n// u32 -> [f32, f32, f32, f32] functions, so the whole rounding and interval\n// process doesn't get applied to the inputs.\n// They do use the framework internally by invoking divisionInterval on segments\n// of the input.\n/**\n * A function that converts a point to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToVector {\n  (n: number): FPVector;\n}\n\n/**\n * A function that converts a vector to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToInterval {\n  (x: number[]): FPInterval;\n}\n\n/** Operation used to implement a VectorToInterval */\ninterface VectorToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vector x */\n  impl: VectorToInterval;\n}\n\n/**\n * A function that converts a pair of vectors to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToInterval {\n  (x: number[], y: number[]): FPInterval;\n}\n\n/** Operation used to implement a VectorPairToInterval */\ninterface VectorPairToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vectors (x, y) */\n  impl: VectorPairToInterval;\n}\n\n/**\n * A function that converts a vector to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToVector {\n  (x: number[]): FPVector;\n}\n\n/** Operation used to implement a VectorToVector */\ninterface VectorToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vector x */\n  impl: VectorToVector;\n}\n\n/**\n * A function that converts a pair of vectors to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToVector {\n  (x: number[], y: number[]): FPVector;\n}\n\n/** Operation used to implement a VectorPairToVector */\ninterface VectorPairToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vectors (x, y) */\n  impl: VectorPairToVector;\n}\n\n/**\n * A function that converts a vector and a scalar to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorScalarToVector {\n  (x: number[], y: number): FPVector;\n}\n\n/**\n * A function that converts a scalar and a vector  to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarVectorToVector {\n  (x: number, y: number[]): FPVector;\n}\n\n/**\n * A function that converts a matrix to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixToScalar {\n  (m: Matrix<number>): FPInterval;\n}\n\n/** Operation used to implement a MatrixToMatrix */\ninterface MatrixToMatrixOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a matrix of acceptance intervals for a function on matrix x */\n  impl: MatrixToMatrix;\n}\n\n/**\n * A function that converts a matrix to a matrix of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixToMatrix {\n  (m: Matrix<number>): FPMatrix;\n}\n\n/** Operation used to implement a MatrixToMatrix */\ninterface MatrixToMatrixOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a matrix of acceptance intervals for a function on matrix x */\n  impl: MatrixToMatrix;\n}\n\n/**\n * A function that converts a pair of matrices to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixPairToMatrix {\n  (x: Matrix<number>, y: Matrix<number>): FPMatrix;\n}\n\n/**\n * A function that converts a matrix and a scalar to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixScalarToMatrix {\n  (x: Matrix<number>, y: number): FPMatrix;\n}\n\n/**\n * A function that converts a scalar and a matrix to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarMatrixToMatrix {\n  (x: number, y: Matrix<number>): FPMatrix;\n}\n\n/**\n * A function that converts a matrix and a vector to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixVectorToVector {\n  (x: Matrix<number>, y: number[]): FPVector;\n}\n\n/**\n * A function that converts a vector and a matrix to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorMatrixToVector {\n  (x: number[], y: Matrix<number>): FPVector;\n}\n\n// Traits\n\n/**\n * Typed structure containing all the limits/constants defined for each\n * WGSL floating point kind\n */\ninterface FPConstants {\n  positive: {\n    min: number;\n    max: number;\n    infinity: number;\n    nearest_max: number;\n    less_than_one: number;\n    subnormal: {\n      min: number;\n      max: number;\n    };\n    pi: {\n      whole: number;\n      three_quarters: number;\n      half: number;\n      third: number;\n      quarter: number;\n      sixth: number;\n    };\n    e: number;\n  };\n  negative: {\n    min: number;\n    max: number;\n    infinity: number;\n    nearest_min: number;\n    less_than_one: number;\n    subnormal: {\n      min: number;\n      max: number;\n    };\n    pi: {\n      whole: number;\n      three_quarters: number;\n      half: number;\n      third: number;\n      quarter: number;\n      sixth: number;\n    };\n  };\n  anyInterval: FPInterval;\n  zeroInterval: FPInterval;\n  negPiToPiInterval: FPInterval;\n  greaterThanZeroInterval: FPInterval;\n  zeroVector: {\n    2: FPVector;\n    3: FPVector;\n    4: FPVector;\n  };\n  anyVector: {\n    2: FPVector;\n    3: FPVector;\n    4: FPVector;\n  };\n  anyMatrix: {\n    2: {\n      2: FPMatrix;\n      3: FPMatrix;\n      4: FPMatrix;\n    };\n    3: {\n      2: FPMatrix;\n      3: FPMatrix;\n      4: FPMatrix;\n    };\n    4: {\n      2: FPMatrix;\n      3: FPMatrix;\n      4: FPMatrix;\n    };\n  };\n}\n\nabstract class FPTraits {\n  public readonly kind: FPKind;\n  protected constructor(k: FPKind) {\n    this.kind = k;\n  }\n\n  public abstract constants(): FPConstants;\n\n  // Utilities - Implemented\n  /** @returns an interval containing the point or the original interval */\n  public toInterval(n: number | IntervalBounds | FPInterval): FPInterval {\n    if (n instanceof FPInterval) {\n      if (n.kind === this.kind) {\n        return n;\n      }\n      return new FPInterval(this.kind, ...n.bounds());\n    }\n\n    if (n instanceof Array) {\n      return new FPInterval(this.kind, ...n);\n    }\n\n    return new FPInterval(this.kind, n, n);\n  }\n\n  /**\n   * @returns an interval with the tightest bounds that includes all provided\n   *          intervals\n   */\n  public spanIntervals(...intervals: FPInterval[]): FPInterval {\n    assert(intervals.length > 0, `span of an empty list of FPIntervals is not allowed`);\n    assert(\n      intervals.every(i => i.kind === this.kind),\n      `span is only defined for intervals with the same kind`\n    );\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return this.toInterval([begin, end]);\n  }\n\n  /** Narrow an array of values to FPVector if possible */\n  public isVector(v: (number | IntervalBounds | FPInterval)[]): v is FPVector {\n    if (v.every(e => e instanceof FPInterval && e.kind === this.kind)) {\n      return v.length === 2 || v.length === 3 || v.length === 4;\n    }\n    return false;\n  }\n\n  /** @returns an FPVector representation of an array of values if possible */\n  public toVector(v: (number | IntervalBounds | FPInterval)[]): FPVector {\n    if (this.isVector(v)) {\n      return v;\n    }\n\n    const f = v.map(e => this.toInterval(e));\n    // The return of the map above is a FPInterval[], which needs to be narrowed\n    // to FPVector, since FPVector is defined as fixed length tuples.\n    if (this.isVector(f)) {\n      return f;\n    }\n    unreachable(`Cannot convert [${v}] to FPVector`);\n  }\n\n  /**\n   * @returns a FPVector where each element is the span for corresponding\n   *          elements at the same index in the input vectors\n   */\n  public spanVectors(...vectors: FPVector[]): FPVector {\n    assert(\n      vectors.every(e => this.isVector(e)),\n      'Vector span is not defined for vectors of differing floating point kinds'\n    );\n\n    const vector_length = vectors[0].length;\n    assert(\n      vectors.every(e => e.length === vector_length),\n      `Vector span is not defined for vectors of differing lengths`\n    );\n\n    const result: FPInterval[] = new Array<FPInterval>(vector_length);\n\n    for (let i = 0; i < vector_length; i++) {\n      result[i] = this.spanIntervals(...vectors.map(v => v[i]));\n    }\n    return this.toVector(result);\n  }\n\n  /** Narrow an array of an array of values to FPMatrix if possible */\n  public isMatrix(m: Matrix<number | IntervalBounds | FPInterval> | FPVector[]): m is FPMatrix {\n    if (!m.every(c => c.every(e => e instanceof FPInterval && e.kind === this.kind))) {\n      return false;\n    }\n    // At this point m guaranteed to be a FPInterval[][], but maybe typed as a\n    // FPVector[].\n    // Coercing the type since FPVector[] is functionally equivalent to\n    // FPInterval[][] for .length and .every, but they are type compatible,\n    // since tuples are not equivalent to arrays, so TS considers c in .every to\n    // be unresolvable below, even though our usage is safe.\n    m = m as FPInterval[][];\n\n    if (m.length > 4 || m.length < 2) {\n      return false;\n    }\n\n    const num_rows = m[0].length;\n    if (num_rows > 4 || num_rows < 2) {\n      return false;\n    }\n\n    return m.every(c => c.length === num_rows);\n  }\n\n  /** @returns an FPMatrix representation of an array of an array of values if possible */\n  public toMatrix(m: Matrix<number | IntervalBounds | FPInterval> | FPVector[]): FPMatrix {\n    if (this.isMatrix(m)) {\n      return m;\n    }\n\n    const result = map2DArray(m, this.toInterval.bind(this));\n\n    // The return of the map above is a FPInterval[][], which needs to be\n    // narrowed to FPMatrix, since FPMatrix is defined as fixed length tuples.\n    if (this.isMatrix(result)) {\n      return result;\n    }\n    unreachable(`Cannot convert ${m} to FPMatrix`);\n  }\n\n  /**\n   * @returns a FPMatrix where each element is the span for corresponding\n   *          elements at the same index in the input matrices\n   */\n  public spanMatrices(...matrices: FPMatrix[]): FPMatrix {\n    // Coercing the type of matrices, since tuples are not generally compatible\n    // with Arrays, but they are functionally equivalent for the usages in this\n    // function.\n    const ms = matrices as Matrix<FPInterval>[];\n    const num_cols = ms[0].length;\n    const num_rows = ms[0][0].length;\n    assert(\n      ms.every(m => m.length === num_cols && m.every(r => r.length === num_rows)),\n      `Matrix span is not defined for Matrices of differing dimensions`\n    );\n\n    const result: Matrix<FPInterval> = [...Array(num_cols)].map(_ => [...Array(num_rows)]);\n    for (let i = 0; i < num_cols; i++) {\n      for (let j = 0; j < num_rows; j++) {\n        result[i][j] = this.spanIntervals(...ms.map(m => m[i][j]));\n      }\n    }\n\n    return this.toMatrix(result);\n  }\n\n  /** @returns input with an appended 0, if inputs contains non-zero subnormals */\n  public addFlushedIfNeeded(values: number[]): number[] {\n    const subnormals = values.filter(this.isSubnormal);\n    const needs_zero = subnormals.length > 0 && subnormals.every(s => s !== 0);\n    return needs_zero ? values.concat(0) : values;\n  }\n\n  /**\n   * Restrict the inputs to an PointToInterval operation\n   *\n   * Only used for operations that have tighter domain requirements than 'must\n   * be finite'.\n   *\n   * @param domain interval to restrict inputs to\n   * @param impl operation implementation to run if input is within the required domain\n   * @returns a PointToInterval that calls impl if domain contains the input,\n   *          otherwise it returns an any interval */\n  protected limitPointToIntervalDomain(domain: FPInterval, impl: PointToInterval): PointToInterval {\n    return (n: number): FPInterval => {\n      return domain.contains(n) ? impl(n) : this.constants().anyInterval;\n    };\n  }\n\n  /**\n   * Restrict the inputs to a BinaryToInterval\n   *\n   * Only used for operations that have tighter domain requirements than 'must be\n   * finite'.\n   *\n   * @param domain set of intervals to restrict inputs to\n   * @param impl operation implementation to run if input is within the required domain\n   * @returns a BinaryToInterval that calls impl if domain contains the input,\n   *          otherwise it returns an any interval */\n  protected limitBinaryToIntervalDomain(\n    domain: BinaryToIntervalDomain,\n    impl: BinaryToInterval\n  ): BinaryToInterval {\n    return (x: number, y: number): FPInterval => {\n      if (!domain.x.some(d => d.contains(x)) || !domain.y.some(d => d.contains(y))) {\n        return this.constants().anyInterval;\n      }\n\n      return impl(x, y);\n    };\n  }\n\n  // Utilities - Defined by subclass\n  /** @returns all valid roundings of input */\n  public abstract readonly correctlyRounded: (n: number) => number[];\n  /** @returns true if input is considered finite, otherwise false */\n  public abstract readonly isFinite: (n: number) => boolean;\n  /** @returns true if input is considered subnormal, otherwise false */\n  public abstract readonly isSubnormal: (n: number) => boolean;\n  /** @returns 0 if the provided number is subnormal, otherwise returns the proved number */\n  public abstract readonly flushSubnormal: (n: number) => number;\n  /** @returns 1 * ULP(number) */\n  public abstract readonly oneULP: (target: number, mode?: FlushMode) => number;\n  /** @returns a builder for converting numbers to Scalars */\n  public abstract readonly scalarBuilder: (n: number) => Scalar;\n\n  // Framework\n  /**\n   * Converts a point to an acceptance interval, using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * op.extrema is invoked before this point in the call stack.\n   * op.domain is tested before this point in the call stack.\n   *\n   * @param n value to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n    assert(!Number.isNaN(n), `flush not defined for NaN`);\n    const values = this.correctlyRounded(n);\n    const inputs = this.addFlushedIfNeeded(values);\n    const results = new Set<FPInterval>(inputs.map(op.impl));\n    return this.spanIntervals(...results);\n  }\n\n  /**\n   * Converts a pair to an acceptance interval, using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * All unique combinations of x & y are run.\n   * op.extrema is invoked before this point in the call stack.\n   * op.domain is tested before this point in the call stack.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): FPInterval {\n    assert(!Number.isNaN(x), `flush not defined for NaN`);\n    assert(!Number.isNaN(y), `flush not defined for NaN`);\n    const x_values = this.correctlyRounded(x);\n    const y_values = this.correctlyRounded(y);\n    const x_inputs = this.addFlushedIfNeeded(x_values);\n    const y_inputs = this.addFlushedIfNeeded(y_values);\n    const intervals = new Set<FPInterval>();\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        intervals.add(op.impl(inner_x, inner_y));\n      });\n    });\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a triplet to an acceptance interval, using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * All unique combinations of x, y & z are run.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param z third param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushTernaryToInterval(\n    x: number,\n    y: number,\n    z: number,\n    op: TernaryToIntervalOp\n  ): FPInterval {\n    assert(!Number.isNaN(x), `flush not defined for NaN`);\n    assert(!Number.isNaN(y), `flush not defined for NaN`);\n    assert(!Number.isNaN(z), `flush not defined for NaN`);\n    const x_values = this.correctlyRounded(x);\n    const y_values = this.correctlyRounded(y);\n    const z_values = this.correctlyRounded(z);\n    const x_inputs = this.addFlushedIfNeeded(x_values);\n    const y_inputs = this.addFlushedIfNeeded(y_values);\n    const z_inputs = this.addFlushedIfNeeded(z_values);\n    const intervals = new Set<FPInterval>();\n    // prettier-ignore\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        z_inputs.forEach(inner_z => {\n          intervals.add(op.impl(inner_x, inner_y, inner_z));\n        });\n      });\n    });\n\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a vector to an acceptance interval using a specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param x param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushVectorToInterval(x: number[], op: VectorToIntervalOp): FPInterval {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: number[][] = x.map(this.correctlyRounded);\n    const x_flushed: number[][] = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n\n    const intervals = new Set<FPInterval>();\n    x_inputs.forEach(inner_x => {\n      intervals.add(op.impl(inner_x));\n    });\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a pair of vectors to an acceptance interval using a specific\n   * function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   * All unique combinations of x & y are run.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param y second param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private roundAndFlushVectorPairToInterval(\n    x: number[],\n    y: number[],\n    op: VectorPairToIntervalOp\n  ): FPInterval {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n    assert(\n      y.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: number[][] = x.map(this.correctlyRounded);\n    const y_rounded: number[][] = y.map(this.correctlyRounded);\n    const x_flushed: number[][] = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const y_flushed: number[][] = y_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n    const y_inputs = cartesianProduct<number>(...y_flushed);\n\n    const intervals = new Set<FPInterval>();\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        intervals.add(op.impl(inner_x, inner_y));\n      });\n    });\n    return this.spanIntervals(...intervals);\n  }\n\n  /**\n   * Converts a vector to a vector of acceptance intervals using a specific\n   * function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param x param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a vector of spans for each outputs of op.impl\n   */\n  private roundAndFlushVectorToVector(x: number[], op: VectorToVectorOp): FPVector {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: number[][] = x.map(this.correctlyRounded);\n    const x_flushed: number[][] = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n\n    const interval_vectors = new Set<FPVector>();\n    x_inputs.forEach(inner_x => {\n      interval_vectors.add(op.impl(inner_x));\n    });\n\n    return this.spanVectors(...interval_vectors);\n  }\n\n  /**\n   * Converts a pair of vectors to a vector of acceptance intervals using a\n   * specific function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param x first param to flush & round then invoke op.impl on\n   * @param x second param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a vector of spans for each output of op.impl\n   */\n  private roundAndFlushVectorPairToVector(\n    x: number[],\n    y: number[],\n    op: VectorPairToVectorOp\n  ): FPVector {\n    assert(\n      x.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n    assert(\n      y.every(e => !Number.isNaN(e)),\n      `flush not defined for NaN`\n    );\n\n    const x_rounded: number[][] = x.map(this.correctlyRounded);\n    const y_rounded: number[][] = y.map(this.correctlyRounded);\n    const x_flushed: number[][] = x_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const y_flushed: number[][] = y_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const x_inputs = cartesianProduct<number>(...x_flushed);\n    const y_inputs = cartesianProduct<number>(...y_flushed);\n\n    const interval_vectors = new Set<FPVector>();\n    x_inputs.forEach(inner_x => {\n      y_inputs.forEach(inner_y => {\n        interval_vectors.add(op.impl(inner_x, inner_y));\n      });\n    });\n\n    return this.spanVectors(...interval_vectors);\n  }\n\n  /**\n   * Converts a matrix to a matrix of acceptance intervals using a specific\n   * function\n   *\n   * This handles correctly rounding and flushing inputs as needed.\n   * Duplicate inputs are pruned before invoking op.impl.\n   *\n   * @param m param to flush & round then invoke op.impl on\n   * @param op operation defining the function being run\n   * @returns a matrix of spans for each outputs of op.impl\n   */\n  private roundAndFlushMatrixToMatrix(m: Matrix<number>, op: MatrixToMatrixOp): FPMatrix {\n    const num_cols = m.length;\n    const num_rows = m[0].length;\n    assert(\n      m.every(c => c.every(r => !Number.isNaN(r))),\n      `flush not defined for NaN`\n    );\n\n    const m_flat = flatten2DArray(m);\n    const m_rounded: number[][] = m_flat.map(this.correctlyRounded);\n    const m_flushed: number[][] = m_rounded.map(this.addFlushedIfNeeded.bind(this));\n    const m_options: number[][] = cartesianProduct<number>(...m_flushed);\n    const m_inputs: Matrix<number>[] = m_options.map(e => unflatten2DArray(e, num_cols, num_rows));\n\n    const interval_matrices = new Set<FPMatrix>();\n    m_inputs.forEach(inner_m => {\n      interval_matrices.add(op.impl(inner_m));\n    });\n\n    return this.spanMatrices(...interval_matrices);\n  }\n\n  /**\n   * Calculate the acceptance interval for a unary function over an interval\n   *\n   * If the interval is actually a point, this just decays to\n   * roundAndFlushPointToInterval.\n   *\n   * The provided domain interval may be adjusted if the operation defines an\n   * extrema function.\n   *\n   * @param x input domain interval\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private runPointToIntervalOp(x: FPInterval, op: PointToIntervalOp): FPInterval {\n    if (!x.isFinite()) {\n      return this.constants().anyInterval;\n    }\n\n    if (op.extrema !== undefined) {\n      x = op.extrema(x);\n    }\n\n    const result = this.spanIntervals(\n      ...x.bounds().map(b => this.roundAndFlushPointToInterval(b, op))\n    );\n    return result.isFinite() ? result : this.constants().anyInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a binary function over an interval\n   *\n   * The provided domain intervals may be adjusted if the operation defines an\n   * extrema function.\n   *\n   * @param x first input domain interval\n   * @param y second input domain interval\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private runBinaryToIntervalOp(x: FPInterval, y: FPInterval, op: BinaryToIntervalOp): FPInterval {\n    if (!x.isFinite() || !y.isFinite()) {\n      return this.constants().anyInterval;\n    }\n\n    if (op.extrema !== undefined) {\n      [x, y] = op.extrema(x, y);\n    }\n\n    const outputs = new Set<FPInterval>();\n    x.bounds().forEach(inner_x => {\n      y.bounds().forEach(inner_y => {\n        outputs.add(this.roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n      });\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().anyInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a ternary function over an interval\n   *\n   * @param x first input domain interval\n   * @param y second input domain interval\n   * @param z third input domain interval\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private runTernaryToIntervalOp(\n    x: FPInterval,\n    y: FPInterval,\n    z: FPInterval,\n    op: TernaryToIntervalOp\n  ): FPInterval {\n    if (!x.isFinite() || !y.isFinite() || !z.isFinite()) {\n      return this.constants().anyInterval;\n    }\n\n    const outputs = new Set<FPInterval>();\n    x.bounds().forEach(inner_x => {\n      y.bounds().forEach(inner_y => {\n        z.bounds().forEach(inner_z => {\n          outputs.add(this.roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n        });\n      });\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().anyInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a vector function over given\n   * intervals\n   *\n   * @param x input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private runVectorToIntervalOp(x: FPVector, op: VectorToIntervalOp): FPInterval {\n    if (x.some(e => !e.isFinite())) {\n      return this.constants().anyInterval;\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n    const outputs = new Set<FPInterval>();\n    x_values.forEach(inner_x => {\n      outputs.add(this.roundAndFlushVectorToInterval(inner_x, op));\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().anyInterval;\n  }\n\n  /**\n   * Calculate the acceptance interval for a vector pair function over given\n   * intervals\n   *\n   * @param x first input domain intervals vector\n   * @param y second input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a span over all the outputs of op.impl\n   */\n  private runVectorPairToIntervalOp(\n    x: FPVector,\n    y: FPVector,\n    op: VectorPairToIntervalOp\n  ): FPInterval {\n    if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n      return this.constants().anyInterval;\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n    const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n    const outputs = new Set<FPInterval>();\n    x_values.forEach(inner_x => {\n      y_values.forEach(inner_y => {\n        outputs.add(this.roundAndFlushVectorPairToInterval(inner_x, inner_y, op));\n      });\n    });\n\n    const result = this.spanIntervals(...outputs);\n    return result.isFinite() ? result : this.constants().anyInterval;\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals for a pair of vector function\n   * over given intervals\n   *\n   * @param x input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a vector of spans over all the outputs of op.impl\n   */\n  private runVectorToVectorOp(x: FPVector, op: VectorToVectorOp): FPVector {\n    if (x.some(e => !e.isFinite())) {\n      return this.constants().anyVector[x.length];\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n    const outputs = new Set<FPVector>();\n    x_values.forEach(inner_x => {\n      outputs.add(this.roundAndFlushVectorToVector(inner_x, op));\n    });\n\n    const result = this.spanVectors(...outputs);\n    return result.every(e => e.isFinite()) ? result : this.constants().anyVector[result.length];\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals by running a scalar operation\n   * component-wise over a vector.\n   *\n   * This is used for situations where a component-wise operation, like vector\n   * negation, is needed as part of an inherited accuracy, but the top-level\n   * operation test don't require an explicit vector definition of the function,\n   * due to the generated 'vectorize' tests being sufficient.\n   *\n   * @param x input domain intervals vector\n   * @param op scalar operation to be run component-wise\n   * @returns a vector of intervals with the outputs of op.impl\n   */\n  private runPointToIntervalOpComponentWise(x: FPVector, op: PointToIntervalOp): FPVector {\n    return this.toVector(x.map(e => this.runPointToIntervalOp(e, op)));\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals for a vector function over\n   * given intervals\n   *\n   * @param x first input domain intervals vector\n   * @param y second input domain intervals vector\n   * @param op operation defining the function being run\n   * @returns a vector of spans over all the outputs of op.impl\n   */\n  private runVectorPairToVectorOp(x: FPVector, y: FPVector, op: VectorPairToVectorOp): FPVector {\n    if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n      return this.constants().anyVector[x.length];\n    }\n\n    const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n    const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n    const outputs = new Set<FPVector>();\n    x_values.forEach(inner_x => {\n      y_values.forEach(inner_y => {\n        outputs.add(this.roundAndFlushVectorPairToVector(inner_x, inner_y, op));\n      });\n    });\n\n    const result = this.spanVectors(...outputs);\n    return result.every(e => e.isFinite()) ? result : this.constants().anyVector[result.length];\n  }\n\n  /**\n   * Calculate the vector of acceptance intervals by running a scalar operation\n   * component-wise over a pair of vectors.\n   *\n   * This is used for situations where a component-wise operation, like vector\n   * subtraction, is needed as part of an inherited accuracy, but the top-level\n   * operation test don't require an explicit vector definition of the function,\n   * due to the generated 'vectorize' tests being sufficient.\n   *\n   * @param x first input domain intervals vector\n   * @param y second input domain intervals vector\n   * @param op scalar operation to be run component-wise\n   * @returns a vector of intervals with the outputs of op.impl\n   */\n  private runBinaryToIntervalOpVectorComponentWise(\n    x: FPVector,\n    y: FPVector,\n    op: BinaryToIntervalOp\n  ): FPVector {\n    assert(\n      x.length === y.length,\n      `runBinaryToIntervalOpVectorComponentWise requires vectors of the same dimensions`\n    );\n\n    return this.toVector(\n      x.map((i, idx) => {\n        return this.runBinaryToIntervalOp(i, y[idx], op);\n      })\n    );\n  }\n\n  /**\n   * Calculate the matrix of acceptance intervals for a pair of matrix function over\n   * given intervals\n   *\n   * @param x input domain intervals matrix\n   * @param x input domain intervals matrix\n   * @param op operation defining the function being run\n   * @returns a matrix of spans over all the outputs of op.impl\n   */\n  private runMatrixToMatrixOp(m: FPMatrix, op: MatrixToMatrixOp): FPMatrix {\n    const num_cols = m.length;\n    const num_rows = m[0].length;\n    if (m.some(c => c.some(r => !r.isFinite()))) {\n      return this.constants().anyMatrix[num_cols][num_rows];\n    }\n\n    const m_flat: FPInterval[] = flatten2DArray(m);\n    const m_values: number[][] = cartesianProduct<number>(...m_flat.map(e => e.bounds()));\n\n    const outputs = new Set<FPMatrix>();\n    m_values.forEach(inner_m => {\n      const unflat_m = unflatten2DArray(inner_m, num_cols, num_rows);\n      outputs.add(this.roundAndFlushMatrixToMatrix(unflat_m, op));\n    });\n\n    const result = this.spanMatrices(...outputs);\n    const result_cols = result.length;\n    const result_rows = result[0].length;\n\n    // FPMatrix has to be coerced to FPInterval[][] to use .every. This should\n    // always be safe, since FPMatrix are defined as fixed length array of\n    // arrays.\n    return (result as FPInterval[][]).every(c => c.every(r => r.isFinite()))\n      ? result\n      : this.constants().anyMatrix[result_cols][result_rows];\n  }\n\n  /**\n   * Calculate the Matrix of acceptance intervals by running a scalar operation\n   * component-wise over a pair of matrices.\n   *\n   * An example of this is performing matrix addition.\n   *\n   * @param x first input domain intervals matrix\n   * @param y second input domain intervals matrix\n   * @param op scalar operation to be run component-wise\n   * @returns a matrix of intervals with the outputs of op.impl\n   */\n  private runBinaryToIntervalOpMatrixComponentWise(\n    x: FPMatrix,\n    y: FPMatrix,\n    op: BinaryToIntervalOp\n  ): FPMatrix {\n    assert(\n      x.length === y.length && x[0].length === y[0].length,\n      `runBinaryToIntervalOpMatrixComponentWise requires matrices of the same dimensions`\n    );\n\n    const cols = x.length;\n    const rows = x[0].length;\n    const flat_x = flatten2DArray(x);\n    const flat_y = flatten2DArray(y);\n\n    return this.toMatrix(\n      unflatten2DArray(\n        flat_x.map((i, idx) => {\n          return this.runBinaryToIntervalOp(i, flat_y[idx], op);\n        }),\n        cols,\n        rows\n      )\n    );\n  }\n\n  // API - Fundamental Error Intervals\n\n  /**\n   * Defines a PointToIntervalOp for an interval of the correctly rounded values\n   * around the point\n   */\n  private readonly CorrectlyRoundedIntervalOp: PointToIntervalOp = {\n    impl: (n: number) => {\n      assert(!Number.isNaN(n), `absolute not defined for NaN`);\n      return this.toInterval(n);\n    },\n  };\n\n  /** @returns an interval of the correctly rounded values around the point */\n  public correctlyRoundedInterval(n: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.CorrectlyRoundedIntervalOp);\n  }\n\n  /** @returns a matrix of correctly rounded intervals for the provided matrix */\n  public correctlyRoundedMatrix(m: Matrix<number>): FPMatrix {\n    return this.toMatrix(map2DArray(m, this.correctlyRoundedInterval.bind(this)));\n  }\n\n  /** @returns a PointToIntervalOp for [n - error_range, n + error_range] */\n  private AbsoluteErrorIntervalOp(error_range: number): PointToIntervalOp {\n    const op: PointToIntervalOp = {\n      impl: (_: number) => {\n        return this.constants().anyInterval;\n      },\n    };\n\n    if (isFiniteF32(error_range)) {\n      op.impl = (n: number) => {\n        assert(!Number.isNaN(n), `absolute error not defined for NaN`);\n        return this.toInterval([n - error_range, n + error_range]);\n      };\n    }\n\n    return op;\n  }\n\n  /** @returns an interval of the absolute error around the point */\n  public absoluteErrorInterval(n: number, error_range: number): FPInterval {\n    error_range = Math.abs(error_range);\n    return this.runPointToIntervalOp(this.toInterval(n), this.AbsoluteErrorIntervalOp(error_range));\n  }\n\n  /** @returns a PointToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\n  private ULPIntervalOp(numULP: number): PointToIntervalOp {\n    const op: PointToIntervalOp = {\n      impl: (_: number) => {\n        return this.constants().anyInterval;\n      },\n    };\n\n    if (this.isFinite(numULP)) {\n      op.impl = (n: number) => {\n        assert(!Number.isNaN(n), `ULP error not defined for NaN`);\n\n        const ulp = this.oneULP(n);\n        const begin = n - numULP * ulp;\n        const end = n + numULP * ulp;\n\n        return this.toInterval([\n          Math.min(begin, this.flushSubnormal(begin)),\n          Math.max(end, this.flushSubnormal(end)),\n        ]);\n      };\n    }\n\n    return op;\n  }\n\n  /** @returns an interval of N * ULP around the point */\n  public ulpInterval(n: number, numULP: number): FPInterval {\n    numULP = Math.abs(numULP);\n    return this.runPointToIntervalOp(this.toInterval(n), this.ULPIntervalOp(numULP));\n  }\n\n  // API - Acceptance Intervals\n\n  private readonly AbsIntervalOp: PointToIntervalOp = {\n    impl: (n: number) => {\n      return this.correctlyRoundedInterval(Math.abs(n));\n    },\n  };\n\n  /** Calculate an acceptance interval for abs(n) */\n  public absInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.AbsIntervalOp);\n  }\n\n  private readonly AcosIntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(this.toInterval([-1.0, 1.0]), (n: number) => {\n      // acos(n) = atan2(sqrt(1.0 - n * n), n) or a polynomial approximation with absolute error\n      const y = this.sqrtInterval(this.subtractionInterval(1, this.multiplicationInterval(n, n)));\n      return this.spanIntervals(\n        this.atan2Interval(y, n),\n        this.absoluteErrorInterval(Math.acos(n), 6.77e-5)\n      );\n    }),\n  };\n\n  /** Calculate an acceptance interval for acos(n) */\n  public acosInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.AcosIntervalOp);\n  }\n\n  /** All acceptance interval functions for acosh(x) */\n  public readonly acoshIntervals: PointToInterval[] = [\n    this.acoshAlternativeInterval.bind(this),\n    this.acoshPrimaryInterval.bind(this),\n  ];\n\n  private readonly AcoshAlternativeIntervalOp: PointToIntervalOp = {\n    impl: (x: number): FPInterval => {\n      // acosh(x) = log(x + sqrt((x + 1.0f) * (x - 1.0)))\n      const inner_value = this.multiplicationInterval(\n        this.additionInterval(x, 1.0),\n        this.subtractionInterval(x, 1.0)\n      );\n      const sqrt_value = this.sqrtInterval(inner_value);\n      return this.logInterval(this.additionInterval(x, sqrt_value));\n    },\n  };\n\n  /** Calculate an acceptance interval of acosh(x) using log(x + sqrt((x + 1.0f) * (x - 1.0))) */\n  public acoshAlternativeInterval(x: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(x), this.AcoshAlternativeIntervalOp);\n  }\n\n  private readonly AcoshPrimaryIntervalOp: PointToIntervalOp = {\n    impl: (x: number): FPInterval => {\n      // acosh(x) = log(x + sqrt(x * x - 1.0))\n      const inner_value = this.subtractionInterval(this.multiplicationInterval(x, x), 1.0);\n      const sqrt_value = this.sqrtInterval(inner_value);\n      return this.logInterval(this.additionInterval(x, sqrt_value));\n    },\n  };\n\n  /** Calculate an acceptance interval of acosh(x) using log(x + sqrt(x * x - 1.0)) */\n  public acoshPrimaryInterval(x: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(x), this.AcoshPrimaryIntervalOp);\n  }\n\n  private readonly AdditionIntervalOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.correctlyRoundedInterval(x + y);\n    },\n  };\n\n  /** Calculate an acceptance interval of x + y */\n  public additionInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.AdditionIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x + y, when x and y are matrices */\n  public additionMatrixInterval(x: Matrix<number>, y: Matrix<number>): FPMatrix {\n    return this.runBinaryToIntervalOpMatrixComponentWise(\n      this.toMatrix(x),\n      this.toMatrix(y),\n      this.AdditionIntervalOp\n    );\n  }\n\n  private readonly AsinIntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(this.toInterval([-1.0, 1.0]), (n: number) => {\n      // asin(n) = atan2(n, sqrt(1.0 - n * n)) or a polynomial approximation with absolute error\n      const x = this.sqrtInterval(this.subtractionInterval(1, this.multiplicationInterval(n, n)));\n      return this.spanIntervals(\n        this.atan2Interval(n, x),\n        this.absoluteErrorInterval(Math.asin(n), 6.77e-5)\n      );\n    }),\n  };\n\n  /** Calculate an acceptance interval for asin(n) */\n  public asinInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.AsinIntervalOp);\n  }\n\n  private readonly AsinhIntervalOp: PointToIntervalOp = {\n    impl: (x: number): FPInterval => {\n      // asinh(x) = log(x + sqrt(x * x + 1.0))\n      const inner_value = this.additionInterval(this.multiplicationInterval(x, x), 1.0);\n      const sqrt_value = this.sqrtInterval(inner_value);\n      return this.logInterval(this.additionInterval(x, sqrt_value));\n    },\n  };\n\n  /** Calculate an acceptance interval of asinh(x) */\n  public asinhInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.AsinhIntervalOp);\n  }\n\n  private readonly AtanIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.ulpInterval(Math.atan(n), 4096);\n    },\n  };\n\n  /** Calculate an acceptance interval of atan(x) */\n  public atanInterval(n: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.AtanIntervalOp);\n  }\n\n  private readonly Atan2IntervalOp: BinaryToIntervalOp = {\n    impl: this.limitBinaryToIntervalDomain(\n      {\n        // For atan2, there params are labelled (y, x), not (x, y), so domain.x is first parameter (y), and domain.y is\n        // the second parameter (x)\n        x: [\n          this.toInterval([kValue.f32.negative.min, kValue.f32.negative.max]),\n          this.toInterval([kValue.f32.positive.min, kValue.f32.positive.max]),\n        ], // first param must be finite and normal\n        y: [this.toInterval([-(2 ** 126), -(2 ** -126)]), this.toInterval([2 ** -126, 2 ** 126])], // inherited from division\n      },\n      (y: number, x: number): FPInterval => {\n        const atan_yx = Math.atan(y / x);\n        // x > 0, atan(y/x)\n        if (x > 0) {\n          return this.ulpInterval(atan_yx, 4096);\n        }\n\n        // x < 0, y > 0, atan(y/x) + π\n        if (y > 0) {\n          return this.ulpInterval(atan_yx + kValue.f32.positive.pi.whole, 4096);\n        }\n\n        // x < 0, y < 0, atan(y/x) - π\n        return this.ulpInterval(atan_yx - kValue.f32.positive.pi.whole, 4096);\n      }\n    ),\n    extrema: (y: FPInterval, x: FPInterval): [FPInterval, FPInterval] => {\n      // There is discontinuity + undefined behaviour at y/x = 0 that will dominate the accuracy\n      if (y.contains(0)) {\n        if (x.contains(0)) {\n          return [this.toInterval(0), this.toInterval(0)];\n        }\n        return [this.toInterval(0), x];\n      }\n      return [y, x];\n    },\n  };\n\n  /** Calculate an acceptance interval of atan2(y, x) */\n  public atan2Interval(y: number | FPInterval, x: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(this.toInterval(y), this.toInterval(x), this.Atan2IntervalOp);\n  }\n\n  private readonly AtanhIntervalOp: PointToIntervalOp = {\n    impl: (n: number) => {\n      // atanh(x) = log((1.0 + x) / (1.0 - x)) * 0.5\n      const numerator = this.additionInterval(1.0, n);\n      const denominator = this.subtractionInterval(1.0, n);\n      const log_interval = this.logInterval(this.divisionInterval(numerator, denominator));\n      return this.multiplicationInterval(log_interval, 0.5);\n    },\n  };\n\n  /** Calculate an acceptance interval of atanh(x) */\n  public atanhInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.AtanhIntervalOp);\n  }\n\n  private readonly CeilIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(Math.ceil(n));\n    },\n  };\n\n  /** Calculate an acceptance interval of ceil(x) */\n  public ceilInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.CeilIntervalOp);\n  }\n\n  /** All acceptance interval functions for clamp(x, y, z) */\n  public readonly clampIntervals: TernaryToInterval[] = [\n    this.clampMinMaxInterval.bind(this),\n    this.clampMedianInterval.bind(this),\n  ];\n\n  private readonly ClampMedianIntervalOp: TernaryToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      return this.correctlyRoundedInterval(\n        // Default sort is string sort, so have to implement numeric comparison.\n        // Cannot use the b-a one-liner, because that assumes no infinities.\n        [x, y, z].sort((a, b) => {\n          if (a < b) {\n            return -1;\n          }\n          if (a > b) {\n            return 1;\n          }\n          return 0;\n        })[1]\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\n  public clampMedianInterval(\n    x: number | FPInterval,\n    y: number | FPInterval,\n    z: number | FPInterval\n  ): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.ClampMedianIntervalOp\n    );\n  }\n\n  private readonly ClampMinMaxIntervalOp: TernaryToIntervalOp = {\n    impl: (x: number, low: number, high: number): FPInterval => {\n      return this.minInterval(this.maxInterval(x, low), high);\n    },\n  };\n\n  /** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\n  public clampMinMaxInterval(\n    x: number | FPInterval,\n    low: number | FPInterval,\n    high: number | FPInterval\n  ): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(low),\n      this.toInterval(high),\n      this.ClampMinMaxIntervalOp\n    );\n  }\n\n  private readonly CosIntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(\n      this.constants().negPiToPiInterval,\n      (n: number): FPInterval => {\n        return this.absoluteErrorInterval(Math.cos(n), 2 ** -11);\n      }\n    ),\n  };\n\n  /** Calculate an acceptance interval of cos(x) */\n  public cosInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.CosIntervalOp);\n  }\n\n  private readonly CoshIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      // cosh(x) = (exp(x) + exp(-x)) * 0.5\n      const minus_n = this.negationInterval(n);\n      return this.multiplicationInterval(\n        this.additionInterval(this.expInterval(n), this.expInterval(minus_n)),\n        0.5\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval of cosh(x) */\n  public coshInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.CoshIntervalOp);\n  }\n\n  private readonly CrossIntervalOp: VectorPairToVectorOp = {\n    impl: (x: number[], y: number[]): FPVector => {\n      assert(x.length === 3, `CrossIntervalOp received x with ${x.length} instead of 3`);\n      assert(y.length === 3, `CrossIntervalOp received y with ${y.length} instead of 3`);\n\n      // cross(x, y) = r, where\n      //   r[0] = x[1] * y[2] - x[2] * y[1]\n      //   r[1] = x[2] * y[0] - x[0] * y[2]\n      //   r[2] = x[0] * y[1] - x[1] * y[0]\n\n      const r0 = this.subtractionInterval(\n        this.multiplicationInterval(x[1], y[2]),\n        this.multiplicationInterval(x[2], y[1])\n      );\n      const r1 = this.subtractionInterval(\n        this.multiplicationInterval(x[2], y[0]),\n        this.multiplicationInterval(x[0], y[2])\n      );\n      const r2 = this.subtractionInterval(\n        this.multiplicationInterval(x[0], y[1]),\n        this.multiplicationInterval(x[1], y[0])\n      );\n      return [r0, r1, r2];\n    },\n  };\n\n  public crossInterval(x: number[], y: number[]): FPVector {\n    assert(x.length === 3, `Cross is only defined for vec3`);\n    assert(y.length === 3, `Cross is only defined for vec3`);\n    return this.runVectorPairToVectorOp(this.toVector(x), this.toVector(y), this.CrossIntervalOp);\n  }\n\n  private readonly DegreesIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.multiplicationInterval(n, 57.295779513082322865);\n    },\n  };\n\n  /** Calculate an acceptance interval of degrees(x) */\n  public degreesInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.DegreesIntervalOp);\n  }\n\n  /**\n   * Calculate the minor of a NxN matrix.\n   *\n   * The ijth minor of a square matrix, is the N-1xN-1 matrix created by removing\n   * the ith column and jth row from the original matrix.\n   */\n  private minorNxN(m: Matrix<number>, col: number, row: number): Matrix<number> {\n    const dim = m.length;\n    assert(m.length === m[0].length, `minorMatrix is only defined for square matrices`);\n    assert(col >= 0 && col < dim, `col ${col} needs be in [0, # of columns '${dim}')`);\n    assert(row >= 0 && row < dim, `row ${row} needs be in [0, # of rows '${dim}')`);\n\n    const result: Matrix<number> = [...Array(dim - 1)].map(_ => [...Array(dim - 1)]);\n\n    const col_indices: number[] = [...Array(dim).keys()].filter(e => e !== col);\n    const row_indices: number[] = [...Array(dim).keys()].filter(e => e !== row);\n\n    col_indices.forEach((c, i) => {\n      row_indices.forEach((r, j) => {\n        result[i][j] = m[c][r];\n      });\n    });\n    return result;\n  }\n\n  /** Calculate an acceptance interval for determinant(m), where m is a 2x2 matrix */\n  private determinant2x2Interval(m: Matrix<number>): FPInterval {\n    assert(\n      m.length === m[0].length && m.length === 2,\n      `determinant2x2Interval called on non-2x2 matrix`\n    );\n    return this.subtractionInterval(\n      this.multiplicationInterval(m[0][0], m[1][1]),\n      this.multiplicationInterval(m[0][1], m[1][0])\n    );\n  }\n\n  /** Calculate an acceptance interval for determinant(m), where m is a 3x3 matrix */\n  private determinant3x3Interval(m: Matrix<number>): FPInterval {\n    assert(\n      m.length === m[0].length && m.length === 3,\n      `determinant3x3Interval called on non-3x3 matrix`\n    );\n\n    // M is a 3x3 matrix\n    // det(M) is A + B + C, where A, B, C are three elements in a row/column times\n    // their own co-factor.\n    // (The co-factor is the determinant of the minor of that position with the\n    // appropriate +/-)\n    // For simplicity sake A, B, C are calculated as the elements of the first\n    // column\n    const A = this.multiplicationInterval(\n      m[0][0],\n      this.determinant2x2Interval(this.minorNxN(m, 0, 0))\n    );\n    const B = this.multiplicationInterval(\n      -m[0][1],\n      this.determinant2x2Interval(this.minorNxN(m, 0, 1))\n    );\n    const C = this.multiplicationInterval(\n      m[0][2],\n      this.determinant2x2Interval(this.minorNxN(m, 0, 2))\n    );\n\n    // Need to calculate permutations, since for fp addition is not associative,\n    // so A + B + C is not guaranteed to equal B + C + A, etc.\n    const permutations: FPInterval[][] = calculatePermutations([A, B, C]);\n    return this.spanIntervals(\n      ...permutations.map(p =>\n        p.reduce((prev: FPInterval, cur: FPInterval) => this.additionInterval(prev, cur))\n      )\n    );\n  }\n\n  /** Calculate an acceptance interval for determinant(m), where m is a 4x4 matrix */\n  private determinant4x4Interval(m: Matrix<number>): FPInterval {\n    assert(\n      m.length === m[0].length && m.length === 4,\n      `determinant3x3Interval called on non-4x4 matrix`\n    );\n\n    // M is a 4x4 matrix\n    // det(M) is A + B + C + D, where A, B, C, D are four elements in a row/column\n    // times their own co-factor.\n    // (The co-factor is the determinant of the minor of that position with the\n    // appropriate +/-)\n    // For simplicity sake A, B, C, D are calculated as the elements of the\n    // first column\n    const A = this.multiplicationInterval(\n      m[0][0],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 0))\n    );\n    const B = this.multiplicationInterval(\n      -m[0][1],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 1))\n    );\n    const C = this.multiplicationInterval(\n      m[0][2],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 2))\n    );\n    const D = this.multiplicationInterval(\n      -m[0][3],\n      this.determinant3x3Interval(this.minorNxN(m, 0, 3))\n    );\n\n    // Need to calculate permutations, since for fp addition is not associative\n    // so A + B + C + D is not guaranteed to equal B + C + A + D, etc.\n    const permutations: FPInterval[][] = calculatePermutations([A, B, C, D]);\n    return this.spanIntervals(\n      ...permutations.map(p =>\n        p.reduce((prev: FPInterval, cur: FPInterval) => this.additionInterval(prev, cur))\n      )\n    );\n  }\n\n  /**\n   * Calculate an acceptance interval for determinant(x)\n   *\n   * This code calculates 3x3 and 4x4 determinants using the textbook co-factor\n   * method, using the first column for the co-factor selection.\n   *\n   * For matrices composed of integer elements, e, with |e|^4 < 2**21, this\n   * should be fine.\n   *\n   * For e, where e is subnormal or 4*(e^4) might not be precisely expressible as\n   * a f32 values, this approach breaks down, because the rule of all co-factor\n   * definitions of determinant being equal doesn't hold in these cases.\n   *\n   * The general solution for this is to calculate all the permutations of the\n   * operations in the worked out formula for determinant.\n   * For 3x3 this is tractable, but for 4x4 this works out to ~23! permutations\n   * that need to be calculated.\n   * Thus, CTS testing and the spec definition of accuracy is restricted to the\n   * space that the simple implementation is valid.\n   */\n  public determinantInterval(x: Matrix<number>): FPInterval {\n    const dim = x.length;\n    assert(\n      x[0].length === dim && (dim === 2 || dim === 3 || dim === 4),\n      `determinantInterval only defined for 2x2, 3x3 and 4x4 matrices`\n    );\n    switch (dim) {\n      case 2:\n        return this.determinant2x2Interval(x);\n      case 3:\n        return this.determinant3x3Interval(x);\n      case 4:\n        return this.determinant4x4Interval(x);\n    }\n    unreachable(\n      \"determinantInterval called on x, where which has an unexpected dimension of '${dim}'\"\n    );\n  }\n\n  private readonly DistanceIntervalScalarOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.lengthInterval(this.subtractionInterval(x, y));\n    },\n  };\n\n  private readonly DistanceIntervalVectorOp: VectorPairToIntervalOp = {\n    impl: (x: number[], y: number[]): FPInterval => {\n      return this.lengthInterval(\n        this.runBinaryToIntervalOpVectorComponentWise(\n          this.toVector(x),\n          this.toVector(y),\n          this.SubtractionIntervalOp\n        )\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval of distance(x, y) */\n  public distanceInterval(x: number | number[], y: number | number[]): FPInterval {\n    if (x instanceof Array && y instanceof Array) {\n      assert(\n        x.length === y.length,\n        `distanceInterval requires both params to have the same number of elements`\n      );\n      return this.runVectorPairToIntervalOp(\n        this.toVector(x),\n        this.toVector(y),\n        this.DistanceIntervalVectorOp\n      );\n    } else if (!(x instanceof Array) && !(y instanceof Array)) {\n      return this.runBinaryToIntervalOp(\n        this.toInterval(x),\n        this.toInterval(y),\n        this.DistanceIntervalScalarOp\n      );\n    }\n    unreachable(\n      `distanceInterval requires both params to both the same type, either scalars or vectors`\n    );\n  }\n\n  private readonly DivisionIntervalOp: BinaryToIntervalOp = {\n    impl: this.limitBinaryToIntervalDomain(\n      {\n        x: [this.toInterval([kValue.f32.negative.min, kValue.f32.positive.max])],\n        y: [this.toInterval([-(2 ** 126), -(2 ** -126)]), this.toInterval([2 ** -126, 2 ** 126])],\n      },\n      (x: number, y: number): FPInterval => {\n        if (y === 0) {\n          return this.constants().anyInterval;\n        }\n        return this.ulpInterval(x / y, 2.5);\n      }\n    ),\n    extrema: (x: FPInterval, y: FPInterval): [FPInterval, FPInterval] => {\n      // division has a discontinuity at y = 0.\n      if (y.contains(0)) {\n        y = this.toInterval(0);\n      }\n      return [x, y];\n    },\n  };\n\n  /** Calculate an acceptance interval of x / y */\n  public divisionInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.DivisionIntervalOp\n    );\n  }\n\n  private readonly DotIntervalOp: VectorPairToIntervalOp = {\n    impl: (x: number[], y: number[]): FPInterval => {\n      // dot(x, y) = sum of x[i] * y[i]\n      const multiplications = this.runBinaryToIntervalOpVectorComponentWise(\n        this.toVector(x),\n        this.toVector(y),\n        this.MultiplicationIntervalOp\n      );\n\n      // vec2 doesn't require permutations, since a + b = b + a for floats\n      if (multiplications.length === 2) {\n        return this.additionInterval(multiplications[0], multiplications[1]);\n      }\n\n      // The spec does not state the ordering of summation, so all the\n      // permutations are calculated and their results spanned, since addition\n      // of more than two floats is not transitive, i.e. a + b + c is not\n      // guaranteed to equal b + a + c\n      const permutations: FPInterval[][] = calculatePermutations(multiplications);\n      return this.spanIntervals(\n        ...permutations.map(p => p.reduce((prev, cur) => this.additionInterval(prev, cur)))\n      );\n    },\n  };\n\n  public dotInterval(x: number[] | FPInterval[], y: number[] | FPInterval[]): FPInterval {\n    assert(x.length === y.length, `dot not defined for vectors with different lengths`);\n    return this.runVectorPairToIntervalOp(this.toVector(x), this.toVector(y), this.DotIntervalOp);\n  }\n\n  private readonly ExpIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.ulpInterval(Math.exp(n), 3 + 2 * Math.abs(n));\n    },\n  };\n\n  /** Calculate an acceptance interval for exp(x) */\n  public expInterval(x: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(x), this.ExpIntervalOp);\n  }\n\n  private readonly Exp2IntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.ulpInterval(Math.pow(2, n), 3 + 2 * Math.abs(n));\n    },\n  };\n\n  /** Calculate an acceptance interval for exp2(x) */\n  public exp2Interval(x: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(x), this.Exp2IntervalOp);\n  }\n\n  /**\n   * Calculate the acceptance intervals for faceForward(x, y, z)\n   *\n   * faceForward(x, y, z) = select(-x, x, dot(z, y) < 0.0)\n   *\n   * This builtin selects from two discrete results (delta rounding/flushing),\n   * so the majority of the framework code is not appropriate, since the\n   * framework attempts to span results.\n   *\n   * Thus, a bespoke implementation is used instead of\n   * defining an Op and running that through the framework.\n   */\n  public faceForwardIntervals(x: number[], y: number[], z: number[]): (FPVector | undefined)[] {\n    const x_vec = this.toVector(x);\n    // Running vector through this.runPointToIntervalOpComponentWise to make\n    // sure that flushing/rounding is handled, since toVector does not perform\n    // those operations.\n    const positive_x = this.runPointToIntervalOpComponentWise(x_vec, {\n      impl: (i: number): FPInterval => {\n        return this.toInterval(i);\n      },\n    });\n    const negative_x = this.runPointToIntervalOpComponentWise(x_vec, this.NegationIntervalOp);\n\n    const dot_interval = this.dotInterval(z, y);\n\n    const results: (FPVector | undefined)[] = [];\n\n    if (!dot_interval.isFinite()) {\n      // dot calculation went out of bounds\n      // Inserting undefined in the result, so that the test running framework\n      // is aware of this potential OOB.\n      // For const-eval tests, it means that the test case should be skipped,\n      // since the shader will fail to compile.\n      // For non-const-eval the undefined should be stripped out of the possible\n      // results.\n\n      results.push(undefined);\n    }\n\n    // Because the result of dot can be an interval, it might span across 0, thus\n    // it is possible that both -x and x are valid responses.\n    if (dot_interval.begin < 0 || dot_interval.end < 0) {\n      results.push(positive_x);\n    }\n\n    if (dot_interval.begin >= 0 || dot_interval.end >= 0) {\n      results.push(negative_x);\n    }\n\n    assert(\n      results.length > 0 || results.every(r => r === undefined),\n      `faceForwardInterval selected neither positive x or negative x for the result, this shouldn't be possible`\n    );\n    return results;\n  }\n\n  private readonly FloorIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(Math.floor(n));\n    },\n  };\n\n  /** Calculate an acceptance interval of floor(x) */\n  public floorInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.FloorIntervalOp);\n  }\n\n  private readonly FmaIntervalOp: TernaryToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      return this.additionInterval(this.multiplicationInterval(x, y), z);\n    },\n  };\n\n  /** Calculate an acceptance interval for fma(x, y, z) */\n  public fmaInterval(x: number, y: number, z: number): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.FmaIntervalOp\n    );\n  }\n\n  private readonly FractIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      // fract(x) = x - floor(x) is defined in the spec.\n      // For people coming from a non-graphics background this will cause some\n      // unintuitive results. For example,\n      // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n      // This is how other shading languages operate and allows for a desirable\n      // wrap around in graphics programming.\n      const result = this.subtractionInterval(n, this.floorInterval(n));\n      if (result.contains(1)) {\n        // Very small negative numbers can lead to catastrophic cancellation,\n        // thus calculating a fract of 1.0, which is technically not a\n        // fractional part, so some implementations clamp the result to next\n        // nearest number.\n        return this.spanIntervals(result, this.toInterval(kValue.f32.positive.less_than_one));\n      }\n      return result;\n    },\n  };\n\n  /** Calculate an acceptance interval of fract(x) */\n  public fractInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.FractIntervalOp);\n  }\n\n  private readonly InverseSqrtIntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(\n      this.constants().greaterThanZeroInterval,\n      (n: number): FPInterval => {\n        return this.ulpInterval(1 / Math.sqrt(n), 2);\n      }\n    ),\n  };\n\n  /** Calculate an acceptance interval of inverseSqrt(x) */\n  public inverseSqrtInterval(n: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.InverseSqrtIntervalOp);\n  }\n\n  private readonly LdexpIntervalOp: BinaryToIntervalOp = {\n    impl: this.limitBinaryToIntervalDomain(\n      // Implementing SPIR-V's more restrictive domain until\n      // https://github.com/gpuweb/gpuweb/issues/3134 is resolved\n      {\n        x: [this.toInterval([kValue.f32.negative.min, kValue.f32.positive.max])],\n        y: [this.toInterval([-126, 128])],\n      },\n      (e1: number, e2: number): FPInterval => {\n        // Though the spec says the result of ldexp(e1, e2) = e1 * 2 ^ e2, the\n        // accuracy is listed as correctly rounded to the true value, so the\n        // inheritance framework does not need to be invoked to determine\n        // bounds.\n        // Instead, the value at a higher precision is calculated and passed to\n        // correctlyRoundedInterval.\n        const result = e1 * 2 ** e2;\n        if (Number.isNaN(result)) {\n          // Overflowed TS's number type, so definitely out of bounds for f32\n          return this.constants().anyInterval;\n        }\n        return this.correctlyRoundedInterval(result);\n      }\n    ),\n  };\n\n  /** Calculate an acceptance interval of ldexp(e1, e2) */\n  public ldexpInterval(e1: number, e2: number): FPInterval {\n    return this.roundAndFlushBinaryToInterval(e1, e2, this.LdexpIntervalOp);\n  }\n\n  private readonly LengthIntervalScalarOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.sqrtInterval(this.multiplicationInterval(n, n));\n    },\n  };\n\n  private readonly LengthIntervalVectorOp: VectorToIntervalOp = {\n    impl: (n: number[]): FPInterval => {\n      return this.sqrtInterval(this.dotInterval(n, n));\n    },\n  };\n\n  /** Calculate an acceptance interval of length(x) */\n  public lengthInterval(n: number | FPInterval | number[] | FPVector): FPInterval {\n    if (n instanceof Array) {\n      return this.runVectorToIntervalOp(this.toVector(n), this.LengthIntervalVectorOp);\n    } else {\n      return this.runPointToIntervalOp(this.toInterval(n), this.LengthIntervalScalarOp);\n    }\n  }\n\n  private readonly LogIntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(\n      this.constants().greaterThanZeroInterval,\n      (n: number): FPInterval => {\n        if (n >= 0.5 && n <= 2.0) {\n          return this.absoluteErrorInterval(Math.log(n), 2 ** -21);\n        }\n        return this.ulpInterval(Math.log(n), 3);\n      }\n    ),\n  };\n\n  /** Calculate an acceptance interval of log(x) */\n  public logInterval(x: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(x), this.LogIntervalOp);\n  }\n\n  private readonly Log2IntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(\n      this.constants().greaterThanZeroInterval,\n      (n: number): FPInterval => {\n        if (n >= 0.5 && n <= 2.0) {\n          return this.absoluteErrorInterval(Math.log2(n), 2 ** -21);\n        }\n        return this.ulpInterval(Math.log2(n), 3);\n      }\n    ),\n  };\n\n  /** Calculate an acceptance interval of log2(x) */\n  public log2Interval(x: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(x), this.Log2IntervalOp);\n  }\n\n  private readonly MaxIntervalOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      // If both of he inputs are subnormal, then either of the inputs can be returned\n      if (isSubnormalNumberF32(x) && isSubnormalNumberF32(y)) {\n        return this.correctlyRoundedInterval(\n          this.spanIntervals(this.toInterval(x), this.toInterval(y))\n        );\n      }\n\n      return this.correctlyRoundedInterval(Math.max(x, y));\n    },\n  };\n\n  /** Calculate an acceptance interval of max(x, y) */\n  public maxInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(this.toInterval(x), this.toInterval(y), this.MaxIntervalOp);\n  }\n\n  private readonly MinIntervalOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      // If both of he inputs are subnormal, then either of the inputs can be returned\n      if (isSubnormalNumberF32(x) && isSubnormalNumberF32(y)) {\n        return this.correctlyRoundedInterval(\n          this.spanIntervals(this.toInterval(x), this.toInterval(y))\n        );\n      }\n\n      return this.correctlyRoundedInterval(Math.min(x, y));\n    },\n  };\n\n  /** Calculate an acceptance interval of min(x, y) */\n  public minInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(this.toInterval(x), this.toInterval(y), this.MinIntervalOp);\n  }\n\n  /** All acceptance interval functions for mix(x, y, z) */\n  public readonly mixIntervals: TernaryToInterval[] = [\n    this.mixImpreciseInterval.bind(this),\n    this.mixPreciseInterval.bind(this),\n  ];\n\n  private readonly MixImpreciseIntervalOp: TernaryToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      // x + (y - x) * z =\n      //  x + t, where t = (y - x) * z\n      const t = this.multiplicationInterval(this.subtractionInterval(y, x), z);\n      return this.additionInterval(x, t);\n    },\n  };\n\n  /** Calculate an acceptance interval of mix(x, y, z) using x + (y - x) * z */\n  public mixImpreciseInterval(x: number, y: number, z: number): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.MixImpreciseIntervalOp\n    );\n  }\n\n  private readonly MixPreciseIntervalOp: TernaryToIntervalOp = {\n    impl: (x: number, y: number, z: number): FPInterval => {\n      // x * (1.0 - z) + y * z =\n      //   t + s, where t = x * (1.0 - z), s = y * z\n      const t = this.multiplicationInterval(x, this.subtractionInterval(1.0, z));\n      const s = this.multiplicationInterval(y, z);\n      return this.additionInterval(t, s);\n    },\n  };\n\n  /** Calculate an acceptance interval of mix(x, y, z) using x * (1.0 - z) + y * z */\n  public mixPreciseInterval(x: number, y: number, z: number): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.toInterval(z),\n      this.MixPreciseIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of modf(x) */\n  public modfInterval(n: number): { fract: FPInterval; whole: FPInterval } {\n    const fract = this.correctlyRoundedInterval(n % 1.0);\n    const whole = this.correctlyRoundedInterval(n - (n % 1.0));\n    return { fract, whole };\n  }\n\n  private readonly MultiplicationInnerOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.correctlyRoundedInterval(x * y);\n    },\n  };\n\n  private readonly MultiplicationIntervalOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.roundAndFlushBinaryToInterval(x, y, this.MultiplicationInnerOp);\n    },\n  };\n\n  /** Calculate an acceptance interval of x * y */\n  public multiplicationInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.MultiplicationIntervalOp\n    );\n  }\n\n  /**\n   * @returns the vector result of multiplying the given vector by the given\n   *          scalar\n   */\n  private multiplyVectorByScalar(v: number[], c: number | FPInterval): FPVector {\n    return this.toVector(v.map(x => this.multiplicationInterval(x, c)));\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a matrix and y is a scalar */\n  public multiplicationMatrixScalarInterval(mat: Matrix<number>, scalar: number): FPMatrix {\n    const cols = mat.length;\n    const rows = mat[0].length;\n    return this.toMatrix(\n      unflatten2DArray(\n        flatten2DArray(mat).map(e => this.MultiplicationIntervalOp.impl(e, scalar)),\n        cols,\n        rows\n      )\n    );\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a scalar and y is a matrix */\n  public multiplicationScalarMatrixInterval(scalar: number, mat: Matrix<number>): FPMatrix {\n    return this.multiplicationMatrixScalarInterval(mat, scalar);\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a matrix and y is a matrix */\n  public multiplicationMatrixMatrixInterval(\n    mat_x: Matrix<number>,\n    mat_y: Matrix<number>\n  ): FPMatrix {\n    const x_cols = mat_x.length;\n    const x_rows = mat_x[0].length;\n    const y_cols = mat_y.length;\n    const y_rows = mat_y[0].length;\n    assert(x_cols === y_rows, `'mat${x_cols}x${x_rows} * mat${y_cols}x${y_rows}' is not defined`);\n\n    const x_transposed = this.transposeInterval(mat_x);\n\n    const result: Matrix<FPInterval> = [...Array(y_cols)].map(_ => [...Array(x_rows)]);\n    mat_y.forEach((y, i) => {\n      x_transposed.forEach((x, j) => {\n        result[i][j] = this.dotInterval(x, y);\n      });\n    });\n\n    return result as FPMatrix;\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a matrix and y is a vector */\n  public multiplicationMatrixVectorInterval(x: Matrix<number>, y: number[]): FPVector {\n    const cols = x.length;\n    const rows = x[0].length;\n    assert(y.length === cols, `'mat${cols}x${rows} * vec${y.length}' is not defined`);\n\n    return this.transposeInterval(x).map(e => this.dotInterval(e, y)) as FPVector;\n  }\n\n  /** Calculate an acceptance interval of x * y, when x is a vector and y is a matrix */\n  public multiplicationVectorMatrixInterval(x: number[], y: Matrix<number>): FPVector {\n    const cols = y.length;\n    const rows = y[0].length;\n    assert(x.length === rows, `'vec${x.length} * mat${cols}x${rows}' is not defined`);\n\n    return y.map(e => this.dotInterval(x, e)) as FPVector;\n  }\n\n  private readonly NegationIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(-n);\n    },\n  };\n\n  /** Calculate an acceptance interval of -x */\n  public negationInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.NegationIntervalOp);\n  }\n\n  private readonly NormalizeIntervalOp: VectorToVectorOp = {\n    impl: (n: number[]): FPVector => {\n      const length = this.lengthInterval(n);\n      return this.toVector(n.map(e => this.divisionInterval(e, length)));\n    },\n  };\n\n  /** Calculate an acceptance interval of normalize(x) */\n  public normalizeInterval(n: number[]): FPVector {\n    return this.runVectorToVectorOp(this.toVector(n), this.NormalizeIntervalOp);\n  }\n\n  private readonly PowIntervalOp: BinaryToIntervalOp = {\n    // pow(x, y) has no explicit domain restrictions, but inherits the x <= 0\n    // domain restriction from log2(x). Invoking log2Interval(x) in impl will\n    // enforce this, so there is no need to wrap the impl call here.\n    impl: (x: number, y: number): FPInterval => {\n      return this.exp2Interval(this.multiplicationInterval(y, this.log2Interval(x)));\n    },\n  };\n\n  /** Calculate an acceptance interval of pow(x, y) */\n  public powInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(this.toInterval(x), this.toInterval(y), this.PowIntervalOp);\n  }\n\n  // Once a full implementation of F16Interval exists, the correctlyRounded for\n  // that can potentially be used instead of having a bespoke operation\n  // implementation.\n  private readonly QuantizeToF16IntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      const rounded = correctlyRoundedF16(n);\n      const flushed = addFlushedIfNeededF16(rounded);\n      return this.spanIntervals(...flushed.map(f => this.toInterval(f)));\n    },\n  };\n\n  /** Calculate an acceptance interval of quantizeToF16(x) */\n  public quantizeToF16Interval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.QuantizeToF16IntervalOp);\n  }\n\n  private readonly RadiansIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.multiplicationInterval(n, 0.017453292519943295474);\n    },\n  };\n\n  /** Calculate an acceptance interval of radians(x) */\n  public radiansInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.RadiansIntervalOp);\n  }\n\n  private readonly ReflectIntervalOp: VectorPairToVectorOp = {\n    impl: (x: number[], y: number[]): FPVector => {\n      assert(\n        x.length === y.length,\n        `ReflectIntervalOp received x (${x}) and y (${y}) with different numbers of elements`\n      );\n\n      // reflect(x, y) = x - 2.0 * dot(x, y) * y\n      //               = x - t * y, t = 2.0 * dot(x, y)\n      // x = incident vector\n      // y = normal of reflecting surface\n      const t = this.multiplicationInterval(2.0, this.dotInterval(x, y));\n      const rhs = this.multiplyVectorByScalar(y, t);\n      return this.runBinaryToIntervalOpVectorComponentWise(\n        this.toVector(x),\n        rhs,\n        this.SubtractionIntervalOp\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval of reflect(x, y) */\n  public reflectInterval(x: number[], y: number[]): FPVector {\n    assert(\n      x.length === y.length,\n      `reflect is only defined for vectors with the same number of elements`\n    );\n    return this.runVectorPairToVectorOp(this.toVector(x), this.toVector(y), this.ReflectIntervalOp);\n  }\n\n  /**\n   * Calculate acceptance interval vectors of reflect(i, s, r)\n   *\n   * refract is a singular function in the sense that it is the only builtin that\n   * takes in (FPVector, FPVector, F32) and returns FPVector and is basically\n   * defined in terms of other functions.\n   *\n   * Instead of implementing all the framework code to integrate it with its\n   * own operation type, etc, it instead has a bespoke implementation that is a\n   * composition of other builtin functions that use the framework.\n   */\n  public refractInterval(i: number[], s: number[], r: number): FPVector {\n    assert(\n      i.length === s.length,\n      `refract is only defined for vectors with the same number of elements`\n    );\n\n    const r_squared = this.multiplicationInterval(r, r);\n    const dot = this.dotInterval(s, i);\n    const dot_squared = this.multiplicationInterval(dot, dot);\n    const one_minus_dot_squared = this.subtractionInterval(1, dot_squared);\n    const k = this.subtractionInterval(\n      1.0,\n      this.multiplicationInterval(r_squared, one_minus_dot_squared)\n    );\n\n    if (!k.isFinite() || k.containsZeroOrSubnormals()) {\n      // There is a discontinuity at k == 0, due to sqrt(k) being calculated, so exiting early\n      return this.constants().anyVector[this.toVector(i).length];\n    }\n\n    if (k.end < 0.0) {\n      // if k is negative, then the zero vector is the valid response\n      return this.constants().zeroVector[this.toVector(i).length];\n    }\n\n    const dot_times_r = this.multiplicationInterval(dot, r);\n    const k_sqrt = this.sqrtInterval(k);\n    const t = this.additionInterval(dot_times_r, k_sqrt); // t = r * dot(i, s) + sqrt(k)\n\n    const result = this.runBinaryToIntervalOpVectorComponentWise(\n      this.multiplyVectorByScalar(i, r),\n      this.multiplyVectorByScalar(s, t),\n      this.SubtractionIntervalOp\n    ); // (i * r) - (s * t)\n    return result;\n  }\n\n  private readonly RemainderIntervalOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      // x % y = x - y * trunc(x/y)\n      return this.subtractionInterval(\n        x,\n        this.multiplicationInterval(y, this.truncInterval(this.divisionInterval(x, y)))\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval for x % y */\n  public remainderInterval(x: number, y: number): FPInterval {\n    return this.runBinaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.RemainderIntervalOp\n    );\n  }\n\n  private readonly RoundIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      const k = Math.floor(n);\n      const diff_before = n - k;\n      const diff_after = k + 1 - n;\n      if (diff_before < diff_after) {\n        return this.correctlyRoundedInterval(k);\n      } else if (diff_before > diff_after) {\n        return this.correctlyRoundedInterval(k + 1);\n      }\n\n      // n is in the middle of two integers.\n      // The tie breaking rule is 'k if k is even, k + 1 if k is odd'\n      if (k % 2 === 0) {\n        return this.correctlyRoundedInterval(k);\n      }\n      return this.correctlyRoundedInterval(k + 1);\n    },\n  };\n\n  /** Calculate an acceptance interval of round(x) */\n  public roundInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.RoundIntervalOp);\n  }\n\n  /**\n   * Calculate an acceptance interval of saturate(n) as clamp(n, 0.0, 1.0)\n   *\n   * The definition of saturate does not specify which version of clamp to use.\n   * Using min-max here, since it has wider acceptance intervals, that include\n   * all of median's.\n   */\n  public saturateInterval(n: number): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(n),\n      this.toInterval(0.0),\n      this.toInterval(1.0),\n      this.ClampMinMaxIntervalOp\n    );\n  }\n\n  private readonly SignIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      if (n > 0.0) {\n        return this.correctlyRoundedInterval(1.0);\n      }\n      if (n < 0.0) {\n        return this.correctlyRoundedInterval(-1.0);\n      }\n\n      return this.correctlyRoundedInterval(0.0);\n    },\n  };\n\n  /** Calculate an acceptance interval of sign(x) */\n  public signInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.SignIntervalOp);\n  }\n\n  private readonly SinIntervalOp: PointToIntervalOp = {\n    impl: this.limitPointToIntervalDomain(\n      this.constants().negPiToPiInterval,\n      (n: number): FPInterval => {\n        return this.absoluteErrorInterval(Math.sin(n), 2 ** -11);\n      }\n    ),\n  };\n\n  /** Calculate an acceptance interval of sin(x) */\n  public sinInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.SinIntervalOp);\n  }\n\n  private readonly SinhIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      // sinh(x) = (exp(x) - exp(-x)) * 0.5\n      const minus_n = this.negationInterval(n);\n      return this.multiplicationInterval(\n        this.subtractionInterval(this.expInterval(n), this.expInterval(minus_n)),\n        0.5\n      );\n    },\n  };\n\n  /** Calculate an acceptance interval of sinh(x) */\n  public sinhInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.SinhIntervalOp);\n  }\n\n  private readonly SmoothStepOp: TernaryToIntervalOp = {\n    impl: (low: number, high: number, x: number): FPInterval => {\n      // For clamp(foo, 0.0, 1.0) the different implementations of clamp provide\n      // the same value, so arbitrarily picking the minmax version to use.\n      // t = clamp((x - low) / (high - low), 0.0, 1.0)\n      // prettier-ignore\n      const t = this.clampMedianInterval(\n        this.divisionInterval(\n          this.subtractionInterval(x, low),\n          this.subtractionInterval(high, low)),\n        0.0,\n        1.0);\n      // Inherited from t * t * (3.0 - 2.0 * t)\n      // prettier-ignore\n      return this.multiplicationInterval(\n        t,\n        this.multiplicationInterval(t,\n          this.subtractionInterval(3.0,\n            this.multiplicationInterval(2.0, t))));\n    },\n  };\n\n  /** Calculate an acceptance interval of smoothStep(low, high, x) */\n  public smoothStepInterval(low: number, high: number, x: number): FPInterval {\n    return this.runTernaryToIntervalOp(\n      this.toInterval(low),\n      this.toInterval(high),\n      this.toInterval(x),\n      this.SmoothStepOp\n    );\n  }\n\n  private readonly SqrtIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.divisionInterval(1.0, this.inverseSqrtInterval(n));\n    },\n  };\n\n  /** Calculate an acceptance interval of sqrt(x) */\n  public sqrtInterval(n: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.SqrtIntervalOp);\n  }\n\n  private readonly StepIntervalOp: BinaryToIntervalOp = {\n    impl: (edge: number, x: number): FPInterval => {\n      if (edge <= x) {\n        return this.correctlyRoundedInterval(1.0);\n      }\n      return this.correctlyRoundedInterval(0.0);\n    },\n  };\n\n  /** Calculate an acceptance 'interval' for step(edge, x)\n   *\n   * step only returns two possible values, so its interval requires special\n   * interpretation in CTS tests.\n   * This interval will be one of four values: [0, 0], [0, 1], [1, 1] & [-∞, +∞].\n   * [0, 0] and [1, 1] indicate that the correct answer in point they encapsulate.\n   * [0, 1] should not be treated as a span, i.e. 0.1 is acceptable, but instead\n   * indicate either 0.0 or 1.0 are acceptable answers.\n   * [-∞, +∞] is treated as any interval, since an undefined or infinite value\n   * was passed in.\n   */\n  public stepInterval(edge: number, x: number): FPInterval {\n    return this.runBinaryToIntervalOp(\n      this.toInterval(edge),\n      this.toInterval(x),\n      this.StepIntervalOp\n    );\n  }\n\n  private readonly SubtractionIntervalOp: BinaryToIntervalOp = {\n    impl: (x: number, y: number): FPInterval => {\n      return this.correctlyRoundedInterval(x - y);\n    },\n  };\n\n  /** Calculate an acceptance interval of x - y */\n  public subtractionInterval(x: number | FPInterval, y: number | FPInterval): FPInterval {\n    return this.runBinaryToIntervalOp(\n      this.toInterval(x),\n      this.toInterval(y),\n      this.SubtractionIntervalOp\n    );\n  }\n\n  /** Calculate an acceptance interval of x - y, when x and y are matrices */\n  public subtractionMatrixInterval(x: Matrix<number>, y: Matrix<number>): FPMatrix {\n    return this.runBinaryToIntervalOpMatrixComponentWise(\n      this.toMatrix(x),\n      this.toMatrix(y),\n      this.SubtractionIntervalOp\n    );\n  }\n\n  private readonly TanIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.divisionInterval(this.sinInterval(n), this.cosInterval(n));\n    },\n  };\n\n  /** Calculate an acceptance interval of tan(x) */\n  public tanInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.TanIntervalOp);\n  }\n\n  private readonly TanhIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.divisionInterval(this.sinhInterval(n), this.coshInterval(n));\n    },\n  };\n\n  /** Calculate an acceptance interval of tanh(x) */\n  public tanhInterval(n: number): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.TanhIntervalOp);\n  }\n\n  private readonly TransposeIntervalOp: MatrixToMatrixOp = {\n    impl: (m: Matrix<number>): FPMatrix => {\n      const num_cols = m.length;\n      const num_rows = m[0].length;\n      const result: Matrix<FPInterval> = [...Array(num_rows)].map(_ => [...Array(num_cols)]);\n\n      for (let i = 0; i < num_cols; i++) {\n        for (let j = 0; j < num_rows; j++) {\n          result[j][i] = this.correctlyRoundedInterval(m[i][j]);\n        }\n      }\n      return this.toMatrix(result);\n    },\n  };\n\n  /** Calculate an acceptance interval of transpose(m) */\n  public transposeInterval(m: Matrix<number>): FPMatrix {\n    return this.runMatrixToMatrixOp(this.toMatrix(m), this.TransposeIntervalOp);\n  }\n\n  private readonly TruncIntervalOp: PointToIntervalOp = {\n    impl: (n: number): FPInterval => {\n      return this.correctlyRoundedInterval(Math.trunc(n));\n    },\n  };\n\n  /** Calculate an acceptance interval of trunc(x) */\n  public truncInterval(n: number | FPInterval): FPInterval {\n    return this.runPointToIntervalOp(this.toInterval(n), this.TruncIntervalOp);\n  }\n\n  /**\n   * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n   * converting between numeric formats\n   *\n   * unpackData* is shared between all of the unpack*Interval functions, so to\n   * avoid re-entrancy problems, they should not call each other or themselves\n   * directly or indirectly.\n   */\n  private readonly unpackData = new ArrayBuffer(4);\n  private readonly unpackDataU32 = new Uint32Array(this.unpackData);\n  private readonly unpackDataU16 = new Uint16Array(this.unpackData);\n  private readonly unpackDataU8 = new Uint8Array(this.unpackData);\n  private readonly unpackDataI16 = new Int16Array(this.unpackData);\n  private readonly unpackDataI8 = new Int8Array(this.unpackData);\n  private readonly unpackDataF16 = new Float16Array(this.unpackData);\n\n  /** Calculate an acceptance interval vector for unpack2x16float(x) */\n  public unpack2x16floatInterval(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack2x16floatInterval only accepts values on the bounds of u32'\n    );\n    this.unpackDataU32[0] = n;\n    if (this.unpackDataF16.some(f => !isFiniteF16(f))) {\n      return [this.constants().anyInterval, this.constants().anyInterval];\n    }\n\n    const result: FPVector = [\n      this.quantizeToF16Interval(this.unpackDataF16[0]),\n      this.quantizeToF16Interval(this.unpackDataF16[1]),\n    ];\n\n    if (result.some(r => !r.isFinite())) {\n      return [this.constants().anyInterval, this.constants().anyInterval];\n    }\n    return result;\n  }\n\n  /** Calculate an acceptance interval vector for unpack2x16snorm(x) */\n  public unpack2x16snormInterval(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack2x16snormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.maxInterval(this.divisionInterval(n, 32767), -1);\n    };\n\n    this.unpackDataU32[0] = n;\n    return [op(this.unpackDataI16[0]), op(this.unpackDataI16[1])];\n  }\n\n  /** Calculate an acceptance interval vector for unpack2x16unorm(x) */\n  public unpack2x16unormInterval(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack2x16unormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.divisionInterval(n, 65535);\n    };\n\n    this.unpackDataU32[0] = n;\n    return [op(this.unpackDataU16[0]), op(this.unpackDataU16[1])];\n  }\n\n  /** Calculate an acceptance interval vector for unpack4x8snorm(x) */\n  public unpack4x8snormInterval(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack4x8snormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.maxInterval(this.divisionInterval(n, 127), -1);\n    };\n    this.unpackDataU32[0] = n;\n    return [\n      op(this.unpackDataI8[0]),\n      op(this.unpackDataI8[1]),\n      op(this.unpackDataI8[2]),\n      op(this.unpackDataI8[3]),\n    ];\n  }\n\n  /** Calculate an acceptance interval vector for unpack4x8unorm(x) */\n  public unpack4x8unormInterval(n: number): FPVector {\n    assert(\n      n >= kValue.u32.min && n <= kValue.u32.max,\n      'unpack4x8unormInterval only accepts values on the bounds of u32'\n    );\n    const op = (n: number): FPInterval => {\n      return this.divisionInterval(n, 255);\n    };\n\n    this.unpackDataU32[0] = n;\n    return [\n      op(this.unpackDataU8[0]),\n      op(this.unpackDataU8[1]),\n      op(this.unpackDataU8[2]),\n      op(this.unpackDataU8[3]),\n    ];\n  }\n}\n\n// Pre-defined values that get used multiple times in _constants' initializers. Cannot use FPTraits members, since this\n// executes before they are defined.\nconst kF32AnyInterval = new FPInterval('f32', Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\nconst kF32ZeroInterval = new FPInterval('f32', 0);\n\nclass F32Traits extends FPTraits {\n  private static _constants: FPConstants = {\n    positive: {\n      min: kValue.f32.positive.min,\n      max: kValue.f32.positive.max,\n      infinity: kValue.f32.infinity.positive,\n      nearest_max: kValue.f32.positive.nearest_max,\n      less_than_one: kValue.f32.positive.less_than_one,\n      subnormal: {\n        min: kValue.f32.subnormal.positive.min,\n        max: kValue.f32.subnormal.positive.max,\n      },\n      pi: {\n        whole: kValue.f32.positive.pi.whole,\n        three_quarters: kValue.f32.positive.pi.three_quarters,\n        half: kValue.f32.positive.pi.half,\n        third: kValue.f32.positive.pi.third,\n        quarter: kValue.f32.positive.pi.quarter,\n        sixth: kValue.f32.positive.pi.sixth,\n      },\n      e: kValue.f32.positive.e,\n    },\n    negative: {\n      min: kValue.f32.negative.min,\n      max: kValue.f32.negative.max,\n      infinity: kValue.f32.infinity.negative,\n      nearest_min: kValue.f32.negative.nearest_min,\n      less_than_one: kValue.f32.negative.less_than_one,\n      subnormal: {\n        min: kValue.f32.subnormal.negative.min,\n        max: kValue.f32.subnormal.negative.max,\n      },\n      pi: {\n        whole: kValue.f32.negative.pi.whole,\n        three_quarters: kValue.f32.negative.pi.three_quarters,\n        half: kValue.f32.negative.pi.half,\n        third: kValue.f32.negative.pi.third,\n        quarter: kValue.f32.negative.pi.quarter,\n        sixth: kValue.f32.negative.pi.sixth,\n      },\n    },\n    anyInterval: kF32AnyInterval,\n    zeroInterval: kF32ZeroInterval,\n    // Have to use the constants.ts values here, because values defined in the\n    // initializer cannot be referenced in the initializer\n    negPiToPiInterval: new FPInterval(\n      'f32',\n      kValue.f32.negative.pi.whole,\n      kValue.f32.positive.pi.whole\n    ),\n    greaterThanZeroInterval: new FPInterval(\n      'f32',\n      kValue.f32.subnormal.positive.min,\n      kValue.f32.positive.max\n    ),\n    zeroVector: {\n      2: [kF32ZeroInterval, kF32ZeroInterval],\n      3: [kF32ZeroInterval, kF32ZeroInterval, kF32ZeroInterval],\n      4: [kF32ZeroInterval, kF32ZeroInterval, kF32ZeroInterval, kF32ZeroInterval],\n    },\n    anyVector: {\n      2: [kF32AnyInterval, kF32AnyInterval],\n      3: [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n      4: [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n    },\n    anyMatrix: {\n      2: {\n        2: [\n          [kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval],\n        ],\n        3: [\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n        ],\n        4: [\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n        ],\n      },\n      3: {\n        2: [\n          [kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval],\n        ],\n        3: [\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n        ],\n        4: [\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n        ],\n      },\n      4: {\n        2: [\n          [kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval],\n        ],\n        3: [\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n        ],\n        4: [\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n          [kF32AnyInterval, kF32AnyInterval, kF32AnyInterval, kF32AnyInterval],\n        ],\n      },\n    },\n  };\n\n  public constructor() {\n    super('f32');\n  }\n\n  public constants(): FPConstants {\n    return F32Traits._constants;\n  }\n\n  // Overrides - Utilities\n  public readonly correctlyRounded = correctlyRoundedF32;\n  public readonly isFinite = isFiniteF32;\n  public readonly isSubnormal = isSubnormalNumberF32;\n  public readonly flushSubnormal = flushSubnormalNumberF32;\n  public readonly oneULP = oneULPF32;\n  public readonly scalarBuilder = f32;\n}\n\nexport const FP = {\n  f32: new F32Traits(),\n};\n"],"mappings":"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"}