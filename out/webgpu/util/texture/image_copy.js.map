{"version":3,"sources":["../../../../src/webgpu/util/texture/image_copy.ts"],"names":["assert","kSizedTextureFormatInfo","align","standardizeExtent3D","kImageCopyTypes","bytesInACompleteRow","copyWidth","format","info","blockWidth","bytesPerBlock","dataBytesForCopy","layout","copyExtentValue","method","copyExtent","width","widthInBlocks","height","blockHeight","heightInBlocks","bytesInLastRow","valid","offset","bytesPerRow","undefined","rowsPerImage","requiredBytesInCopy","depth","bytesPerImage","bytesBeforeLastImage","minDataSize"],"mappings":"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","sourcesContent":["import { assert } from '../../../common/framework/util/util.js';\nimport { kSizedTextureFormatInfo, SizedTextureFormat } from '../../capability_info.js';\nimport { align } from '../math.js';\nimport { standardizeExtent3D } from '../unions.js';\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = kSizedTextureFormatInfo[format];\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, computes a\n * guess assuming `bytesPerRow` and `rowsPerImage` should be optimal.\n */\nexport function dataBytesForCopy(\n  layout: GPUImageDataLayout,\n  format: SizedTextureFormat,\n  copyExtentValue: GPUExtent3D,\n  { method }: { method: ImageCopyType }\n): { minDataSize: number; valid: boolean } {\n  const copyExtent = standardizeExtent3D(copyExtentValue);\n\n  const info = kSizedTextureFormatInfo[format];\n  assert(copyExtent.width % info.blockWidth === 0);\n  const widthInBlocks = copyExtent.width / info.blockWidth;\n  assert(copyExtent.height % info.blockHeight === 0);\n  const heightInBlocks = copyExtent.height / info.blockHeight;\n  const bytesInLastRow = widthInBlocks * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n  if (layout.bytesPerRow !== undefined && bytesInLastRow > layout.bytesPerRow) valid = false;\n  if (layout.rowsPerImage !== undefined && heightInBlocks > layout.rowsPerImage) valid = false;\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n    if (heightInBlocks > 1 && bytesPerRow === undefined) valid = false;\n    // If copyExtent.depth > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n    if (copyExtent.depth > 1 && rowsPerImage === undefined) valid = false;\n    // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n    if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) valid = false;\n    // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n    if (rowsPerImage !== undefined && rowsPerImage < heightInBlocks) valid = false;\n\n    bytesPerRow ??= align(info.bytesPerBlock * widthInBlocks, 256);\n    rowsPerImage ??= heightInBlocks;\n\n    if (copyExtent.depth > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depth - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depth > 0) {\n      if (heightInBlocks > 1) requiredBytesInCopy += bytesPerRow * (heightInBlocks - 1);\n      if (heightInBlocks > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSize: offset + requiredBytesInCopy, valid };\n}\n"],"file":"image_copy.js"}