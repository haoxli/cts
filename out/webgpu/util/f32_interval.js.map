{"version":3,"file":"f32_interval.js","names":["assert","unreachable","Float16Array","kValue","f32","reinterpretF32AsU32","reinterpretU32AsF32","calculatePermutations","cartesianProduct","correctlyRoundedF16","correctlyRoundedF32","flatten2DArray","flushSubnormalNumberF32","isFiniteF16","isFiniteF32","isSubnormalNumberF16","isSubnormalNumberF32","map2DArray","oneULPF32","unflatten2DArray","F32Interval","constructor","bounds","begin","end","length","Number","isNaN","isPoint","contains","n","NEGATIVE_INFINITY","POSITIVE_INFINITY","i","toF32Interval","containsZeroOrSubnormals","subnormal","negative","min","positive","max","isFinite","span","intervals","forEach","Math","toString","map","any","_any","undefined","serializeF32Interval","deserializeF32Interval","data","Array","kNegPiToPiInterval","pi","whole","kGreaterThanZeroInterval","isF32Vector","v","toF32Vector","f","kZeroVector","kAnyVector","spanF32Vector","vectors","vector_length","every","e","result","multiplyVectorByScalar","c","x","multiplicationInterval","isF32Matrix","m","num_rows","toF32Matrix","kAnyF32Matrix","spanF32Matrix","matrices","ms","num_cols","r","_","j","addFlushedIfNeededF32","values","some","concat","addFlushedIfNeededF16","limitPointToIntervalDomain","domain","impl","limitBinaryToIntervalDomain","y","d","roundAndFlushPointToInterval","op","inputs","results","Set","roundAndFlushBinaryToInterval","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","roundAndFlushVectorToInterval","x_rounded","x_flushed","roundAndFlushVectorPairToInterval","y_rounded","y_flushed","roundAndFlushVectorToVector","interval_vectors","roundAndFlushVectorPairToVector","roundAndFlushMatrixToMatrix","m_flat","m_rounded","m_flushed","m_options","m_inputs","interval_matrices","inner_m","runPointToIntervalOp","extrema","b","runBinaryToIntervalOp","outputs","runTernaryToIntervalOp","runVectorToIntervalOp","runVectorPairToIntervalOp","runVectorToVectorOp","runPointToIntervalOpComponentWise","runVectorPairToVectorOp","runBinaryToIntervalOpVectorComponentWise","idx","runMatrixToMatrixOp","m_values","unflat_m","result_cols","result_rows","runBinaryToIntervalOpMatrixComponentWise","cols","rows","flat_x","flat_y","CorrectlyRoundedIntervalOp","correctlyRoundedInterval","correctlyRoundedMatrix","AbsoluteErrorIntervalOp","error_range","absoluteErrorInterval","abs","ULPIntervalOp","numULP","ulp","ulpInterval","AbsIntervalOp","absInterval","AcosIntervalOp","sqrtInterval","subtractionInterval","atan2Interval","acos","acosInterval","acoshIntervals","acoshAlternativeInterval","acoshPrimaryInterval","AcoshAlternativeIntervalOp","inner_value","additionInterval","sqrt_value","logInterval","AcoshPrimaryIntervalOp","AdditionIntervalOp","additionMatrixInterval","AsinIntervalOp","asin","asinInterval","AsinhIntervalOp","asinhInterval","AtanIntervalOp","atan","atanInterval","Atan2IntervalOp","atan_yx","AtanhIntervalOp","numerator","denominator","log_interval","divisionInterval","atanhInterval","CeilIntervalOp","ceil","ceilInterval","ClampMedianIntervalOp","sort","a","clampIntervals","clampMinMaxInterval","clampMedianInterval","ClampMinMaxIntervalOp","low","high","minInterval","maxInterval","CosIntervalOp","cos","cosInterval","CoshIntervalOp","minus_n","negationInterval","expInterval","coshInterval","CrossIntervalOp","r0","r1","r2","crossInterval","DegreesIntervalOp","degreesInterval","minorNxN","col","row","dim","col_indices","keys","filter","row_indices","determinant2x2Interval","determinant3x3Interval","A","B","C","permutations","p","reduce","prev","cur","determinant4x4Interval","D","determinantInterval","DistanceIntervalScalarOp","lengthInterval","DistanceIntervalVectorOp","SubtractionIntervalOp","distanceInterval","DivisionIntervalOp","DotIntervalOp","multiplications","MultiplicationIntervalOp","dotInterval","ExpIntervalOp","exp","Exp2IntervalOp","pow","exp2Interval","faceForwardIntervals","x_vec","positive_x","negative_x","NegationIntervalOp","dot_interval","push","FloorIntervalOp","floor","floorInterval","FmaIntervalOp","fmaInterval","FractIntervalOp","less_than_one","fractInterval","InverseSqrtIntervalOp","sqrt","inverseSqrtInterval","LdexpIntervalOp","e1","e2","ldexpInterval","LengthIntervalScalarOp","LengthIntervalVectorOp","LogIntervalOp","log","Log2IntervalOp","log2","log2Interval","MaxIntervalOp","MinIntervalOp","MixImpreciseIntervalOp","t","mixIntervals","mixImpreciseInterval","mixPreciseInterval","MixPreciseIntervalOp","s","modfInterval","fract","MultiplicationInnerOp","multiplicationMatrixScalarInterval","mat","scalar","multiplicationScalarMatrixInterval","multiplicationMatrixMatrixInterval","mat_x","mat_y","x_cols","x_rows","y_cols","y_rows","x_transposed","transposeInterval","multiplicationMatrixVectorInterval","multiplicationVectorMatrixInterval","NormalizeIntervalOp","normalizeInterval","PowIntervalOp","powInterval","QuantizeToF16IntervalOp","rounded","flushed","quantizeToF16Interval","RadiansIntervalOp","radiansInterval","ReflectIntervalOp","rhs","reflectInterval","refractInterval","r_squared","dot","dot_squared","one_minus_dot_squared","k","dot_times_r","k_sqrt","RemainderIntervalOp","truncInterval","remainderInterval","RoundIntervalOp","diff_before","diff_after","roundInterval","saturateInterval","SignIntervalOp","signInterval","SinIntervalOp","sin","sinInterval","SinhIntervalOp","sinhInterval","SmoothStepOp","smoothStepInterval","SqrtIntervalOp","StepIntervalOp","edge","stepInterval","subtractionMatrixInterval","TanIntervalOp","tanInterval","TanhIntervalOp","tanhInterval","TransposeIntervalOp","TruncIntervalOp","trunc","unpackData","ArrayBuffer","unpackDataU32","Uint32Array","unpackDataU16","Uint16Array","unpackDataU8","Uint8Array","unpackDataI16","Int16Array","unpackDataI8","Int8Array","unpackDataF16","unpack2x16floatInterval","u32","Unpack2x16snormIntervalOp","unpack2x16snormInterval","Unpack2x16unormIntervalOp","unpack2x16unormInterval","Unpack4x8snormIntervalOp","unpack4x8snormInterval","Unpack4x8unormIntervalOp","unpack4x8unormInterval"],"sources":["../../../src/webgpu/util/f32_interval.ts"],"sourcesContent":["import { assert, unreachable } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kValue } from './constants.js';\nimport { f32, reinterpretF32AsU32, reinterpretU32AsF32 } from './conversion.js';\nimport {\n  calculatePermutations,\n  cartesianProduct,\n  correctlyRoundedF16,\n  correctlyRoundedF32,\n  flatten2DArray,\n  flushSubnormalNumberF32,\n  isFiniteF16,\n  isFiniteF32,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  map2DArray,\n  oneULPF32,\n  unflatten2DArray,\n} from './math.js';\n\n/**\n * Representation of bounds for an interval as an array with either one or two\n * elements. Single element indicates that the interval is a single point. For\n * two elements, the first is the lower bound of the interval and the second is\n * the upper bound.\n */\nexport type IntervalBounds = [number] | [number, number];\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _any: F32Interval;\n\n  /** Constructor\n   *\n   * `toF32Interval` is the preferred way to create F32Intervals\n   *\n   * @param bounds either a pair of numbers indicating the beginning then the\n   *               end of the interval, or a single element array indicating the\n   *               interval is a point\n   */\n  public constructor(...bounds: IntervalBounds) {\n    const [begin, end] = bounds.length === 2 ? bounds : [bounds[0], bounds[0]];\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `bounds[0] (${begin}) must be less than or equal to bounds[1]  (${end})`);\n\n    this.begin = begin;\n    this.end = end;\n  }\n\n  /** @returns begin and end if non-point interval, otherwise just begin */\n  public bounds(): IntervalBounds {\n    return this.isPoint() ? [this.begin] : [this.begin, this.end];\n  }\n\n  /** @returns if a point or interval is completely contained by this interval */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the any interval indicates that accuracy is not defined for this\n      // test, so the test is just checking that this input doesn't cause the\n      // implementation to misbehave, so NaN is accepted.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toF32Interval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if any values in the interval may be flushed to zero, this\n   *           includes any subnormals and zero itself.\n   */\n  public containsZeroOrSubnormals(): boolean {\n    return !(\n      this.end < kValue.f32.subnormal.negative.min || this.begin > kValue.f32.subnormal.positive.max\n    );\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns if this interval only contains f32 finite values */\n  public isFinite(): boolean {\n    return isFiniteF32(this.begin) && isFiniteF32(this.end);\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.bounds().map(f32)}]`;\n  }\n\n  /** @returns a singleton for interval of all possible values\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static any(): F32Interval {\n    if (this._any === undefined) {\n      this._any = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._any;\n  }\n}\n\n/**\n * SerializedF32Interval holds the serialized form of a F32Interval.\n * This form can be safely encoded to JSON.\n */\nexport type SerializedF32Interval = { begin: number; end: number } | 'any';\n\n/** serializeF32Interval() converts a F32Interval to a SerializedF32Interval */\nexport function serializeF32Interval(i: F32Interval): SerializedF32Interval {\n  return i === F32Interval.any()\n    ? 'any'\n    : { begin: reinterpretF32AsU32(i.begin), end: reinterpretF32AsU32(i.end) };\n}\n\n/** serializeF32Interval() converts a SerializedF32Interval to a F32Interval */\nexport function deserializeF32Interval(data: SerializedF32Interval): F32Interval {\n  return data === 'any'\n    ? F32Interval.any()\n    : toF32Interval([reinterpretU32AsF32(data.begin), reinterpretU32AsF32(data.end)]);\n}\n\n/** @returns an interval containing the point or the original interval */\nexport function toF32Interval(n: number | IntervalBounds | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n\n  if (n instanceof Array) {\n    return new F32Interval(...n);\n  }\n\n  return new F32Interval(n, n);\n}\n\n/** F32Interval of [-π, π] */\nconst kNegPiToPiInterval = toF32Interval([\n  kValue.f32.negative.pi.whole,\n  kValue.f32.positive.pi.whole,\n]);\n\n/** F32Interval of values greater than 0 and less than or equal to f32 max */\nconst kGreaterThanZeroInterval = toF32Interval([\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.positive.max,\n]);\n\n/**\n * Representation of a vec2/3/4 of floating point intervals as an array of F32Intervals.\n * */\nexport type F32Vector =\n  | [F32Interval, F32Interval]\n  | [F32Interval, F32Interval, F32Interval]\n  | [F32Interval, F32Interval, F32Interval, F32Interval];\n\n/** Coerce F32Interval[] to F32Vector if possible */\nfunction isF32Vector(v: number[] | IntervalBounds[] | F32Interval[] | F32Vector): v is F32Vector {\n  if (v[0] instanceof F32Interval) {\n    return v.length === 2 || v.length === 3 || v.length === 4;\n  }\n  return false;\n}\n\n/** @returns an F32Vector representation of an array fo F32Intervals if possible */\nexport function toF32Vector(v: number[] | IntervalBounds[] | F32Interval[] | F32Vector): F32Vector {\n  if (isF32Vector(v)) {\n    return v;\n  }\n\n  const f = v.map(toF32Interval);\n  if (isF32Vector(f)) {\n    return f;\n  }\n  unreachable(`Cannot convert [${v}] to F32Vector`);\n}\n\n/** F32Vector with all zero elements */\nconst kZeroVector = {\n  2: toF32Vector([0, 0]),\n  3: toF32Vector([0, 0, 0]),\n  4: toF32Vector([0, 0, 0, 0]),\n};\n\n/** F32Vector with all F32Interval.any() elements */\nconst kAnyVector = {\n  2: toF32Vector([F32Interval.any(), F32Interval.any()]),\n  3: toF32Vector([F32Interval.any(), F32Interval.any(), F32Interval.any()]),\n  4: toF32Vector([F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()]),\n};\n\n/**\n * @returns a F32Vector where each element is the span for corresponding\n *          elements at the same index in the input vectors\n */\nfunction spanF32Vector(...vectors: F32Vector[]): F32Vector {\n  assert(isF32Vector(vectors[0]), '');\n  const vector_length = vectors[0].length;\n  assert(\n    vectors.every(e => e.length === vector_length),\n    `Vector span is not defined for vectors of differing lengths`\n  );\n\n  const result: F32Interval[] = new Array<F32Interval>(vector_length);\n\n  for (let i = 0; i < vector_length; i++) {\n    result[i] = F32Interval.span(...vectors.map(v => v[i]));\n  }\n  return toF32Vector(result);\n}\n\n/**\n * @retuns the vector result of multiplying the given vector by the given scalar\n */\nfunction multiplyVectorByScalar(v: number[], c: number | F32Interval): F32Vector {\n  return toF32Vector(v.map(x => multiplicationInterval(x, c)));\n}\n\n/**\n * Short hand for an Array of Arrays that contains a column-major matrix\n *\n * This isn't exported outside of this file to avoid colliding with the Matrix\n * container for going in/out of a shader that the test runner uses.\n */\ntype Matrix<T> = T[][];\n\n/** Representation of a matCxR of floating point intervals as an array of arrays of F32Intervals. This maps onto the WGSL concept of matrix. Internally  */\n// prettier-ignore;\nexport type F32Matrix =\n  | [[F32Interval, F32Interval], [F32Interval, F32Interval]]\n  | [[F32Interval, F32Interval], [F32Interval, F32Interval], [F32Interval, F32Interval]]\n  | [\n      [F32Interval, F32Interval],\n      [F32Interval, F32Interval],\n      [F32Interval, F32Interval],\n      [F32Interval, F32Interval]\n    ]\n  | [[F32Interval, F32Interval, F32Interval], [F32Interval, F32Interval, F32Interval]]\n  | [\n      [F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval]\n    ]\n  | [\n      [F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval]\n    ]\n  | [\n      [F32Interval, F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval, F32Interval]\n    ]\n  | [\n      [F32Interval, F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval, F32Interval]\n    ]\n  | [\n      [F32Interval, F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval, F32Interval],\n      [F32Interval, F32Interval, F32Interval, F32Interval]\n    ];\n\n/** Coerce F32Interval[] to F32Matrix if possible */\nfunction isF32Matrix(\n  m: Matrix<number> | Matrix<IntervalBounds> | Matrix<F32Interval> | F32Vector[] | F32Matrix\n): m is F32Matrix {\n  if (!(m[0][0] instanceof F32Interval)) {\n    return false;\n  }\n  // At this point m guaranteed to be a F32Interval[][] | F32Vector[]\n  // | F32Matrix.\n\n  // Coercing the type since F32Vector[] and F32Matrix are functionally\n  // equivalent to F32Interval[][] for .length and .every, but they are not\n  // generally compatible, since tuples are not equivalent to arrays, so TS\n  // considers c in .every to be unresolvable, even though our usage is safe.\n  m = m as F32Interval[][];\n\n  if (m.length > 4 || m.length < 2) {\n    return false;\n  }\n\n  const num_rows = m[0].length;\n  if (num_rows > 4 || num_rows < 2) {\n    return false;\n  }\n\n  return m.every(c => c.length === num_rows);\n}\n\n/** @returns an F32Matrix representation of an array fo F32Intervals if possible */\nexport function toF32Matrix(\n  m: Matrix<number> | Matrix<IntervalBounds> | Matrix<F32Interval> | F32Vector[] | F32Matrix\n): F32Matrix {\n  if (isF32Matrix(m)) {\n    return m;\n  }\n\n  const result = m.map(c => c.map(toF32Interval));\n\n  if (isF32Matrix(result)) {\n    return result;\n  }\n  unreachable(`Cannot convert ${m} to F32Matrix`);\n}\n\n/** F32Matrix with all F32Interval.any() elements */\nconst kAnyF32Matrix = {\n  2: {\n    2: toF32Matrix([\n      [F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any()],\n    ]),\n    3: toF32Matrix([\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n    ]),\n    4: toF32Matrix([\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n    ]),\n  },\n  3: {\n    2: toF32Matrix([\n      [F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any()],\n    ]),\n    3: toF32Matrix([\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n    ]),\n    4: toF32Matrix([\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n    ]),\n  },\n  4: {\n    2: toF32Matrix([\n      [F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any()],\n    ]),\n    3: toF32Matrix([\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any()],\n    ]),\n    4: toF32Matrix([\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n      [F32Interval.any(), F32Interval.any(), F32Interval.any(), F32Interval.any()],\n    ]),\n  },\n};\n\n/**\n * @returns a F32Matrix where each element is the span for corresponding\n *          elements at the same index in the input matrices\n */\nfunction spanF32Matrix(...matrices: F32Matrix[]): F32Matrix {\n  // Coercing the type of matrices, since tuples are not generally compatible\n  // with Arrays, but they are functionally equivalent for the usages in this\n  // function.\n  const ms = matrices as Matrix<F32Interval>[];\n  const num_cols = ms[0].length;\n  const num_rows = ms[0][0].length;\n  assert(\n    ms.every(m => m.length === num_cols && m.every(r => r.length === num_rows)),\n    `Matrix span is not defined for Matrices of differing dimensions`\n  );\n\n  const result: Matrix<F32Interval> = [...Array(num_cols)].map(_ => [...Array(num_rows)]);\n  for (let i = 0; i < num_cols; i++) {\n    for (let j = 0; j < num_rows; j++) {\n      result[i][j] = F32Interval.span(...ms.map(m => m[i][j]));\n    }\n  }\n\n  return toF32Matrix(result);\n}\n\n/**\n * @returns the input plus zero if any of the entries are f32 subnormal,\n * otherwise returns the input.\n */\nfunction addFlushedIfNeededF32(values: number[]): number[] {\n  return values.some(v => v !== 0 && isSubnormalNumberF32(v)) ? values.concat(0) : values;\n}\n\n/**\n * @returns the input plus zero if any of the entries are f16 subnormal,\n * otherwise returns the input\n */\nfunction addFlushedIfNeededF16(values: number[]): number[] {\n  return values.some(v => v !== 0 && isSubnormalNumberF16(v)) ? values.concat(0) : values;\n}\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\nexport interface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: PointToInterval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * Used by runPointToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for operations that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * Restrict the inputs to an PointToInterval operation\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain interval to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a PointToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitPointToIntervalDomain(domain: F32Interval, impl: PointToInterval): PointToInterval {\n  return (n: number): F32Interval => {\n    return domain.contains(n) ? impl(n) : F32Interval.any();\n  };\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: BinaryToInterval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * Used by runBinaryToIntervalOp before invoking impl.\n   * If not defined, the bounds of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/** Domain for a BinaryToInterval implementation */\ninterface BinaryToIntervalDomain {\n  // Arrays to support discrete valid domain intervals\n  x: F32Interval[];\n  y: F32Interval[];\n}\n\n/**\n * Restrict the inputs to a BinaryToInterval\n *\n * Only used for operations that have tighter domain requirements than 'must be\n * f32 finite'.\n *\n * @param domain set of intervals to restrict inputs to\n * @param impl operation implementation to run if input is within the required domain\n * @returns a BinaryToInterval that calls impl if domain contains the input,\n *          otherwise it returns the any() interval */\nfunction limitBinaryToIntervalDomain(\n  domain: BinaryToIntervalDomain,\n  impl: BinaryToInterval\n): BinaryToInterval {\n  return (x: number, y: number): F32Interval => {\n    if (!domain.x.some(d => d.contains(x)) || !domain.y.some(d => d.contains(y))) {\n      return F32Interval.any();\n    }\n\n    return impl(x, y);\n  };\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: TernaryToInterval;\n}\n\n// Currently PointToVector is not integrated with the rest of the floating point\n// framework, because the only builtins that use it are actually\n// u32 -> [f32, f32, f32, f32] functions, so the whole rounding and interval\n// process doesn't get applied to the inputs.\n// They do use the framework internally by invoking divisionInterval on segments\n// of the input.\n/**\n * A function that converts a point to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToVector {\n  (n: number): F32Vector;\n}\n\n/**\n * A function that converts a vector to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToInterval {\n  (x: number[]): F32Interval;\n}\n\n/** Operation used to implement a VectorToInterval */\ninterface VectorToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vector x */\n  impl: VectorToInterval;\n}\n\n/**\n * A function that converts a pair of vectors to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToInterval {\n  (x: number[], y: number[]): F32Interval;\n}\n\n/** Operation used to implement a VectorPairToInterval */\ninterface VectorPairToIntervalOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns acceptance interval for a function on vectors (x, y) */\n  impl: VectorPairToInterval;\n}\n\n/**\n * A function that converts a vector to a vector of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorToVector {\n  (x: number[]): F32Vector;\n}\n\n/** Operation used to implement a VectorToVector */\ninterface VectorToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vector x */\n  impl: VectorToVector;\n}\n\n/**\n * A function that converts a pair of vectors to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorPairToVector {\n  (x: number[], y: number[]): F32Vector;\n}\n\n/** Operation used to implement a VectorPairToVector */\ninterface VectorPairToVectorOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a vector of acceptance intervals for a function on vectors (x, y) */\n  impl: VectorPairToVector;\n}\n\n/**\n * A function that converts a vector and a scalar to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorScalarToVector {\n  (x: number[], y: number): F32Vector;\n}\n\n/**\n * A function that converts a scalar and a vector  to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarVectorToVector {\n  (x: number, y: number[]): F32Vector;\n}\n\n/**\n * A function that converts a matrix to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixToScalar {\n  (m: Matrix<number>): F32Interval;\n}\n\n/** Operation used to implement a MatrixToMatrix */\ninterface MatrixToMatrixOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a matrix of acceptance intervals for a function on matrix x */\n  impl: MatrixToMatrix;\n}\n\n/**\n * A function that converts a matrix to a matrix of acceptance intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixToMatrix {\n  (m: Matrix<number>): F32Matrix;\n}\n\n/** Operation used to implement a MatrixToMatrix */\ninterface MatrixToMatrixOp {\n  // Re-using the *Op interface pattern for symmetry with the other operations.\n  /** @returns a matrix of acceptance intervals for a function on matrix x */\n  impl: MatrixToMatrix;\n}\n\n/**\n * A function that converts a pair of matrices to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixPairToMatrix {\n  (x: Matrix<number>, y: Matrix<number>): F32Matrix;\n}\n\n/**\n * A function that converts a matrix and a scalar to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixScalarToMatrix {\n  (x: Matrix<number>, y: number): F32Matrix;\n}\n\n/**\n * A function that converts a matrix and a vector to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface MatrixVectorToVector {\n  (x: Matrix<number>, y: number[]): F32Vector;\n}\n\n/**\n * A function that converts a vector and a matrix to a vector of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface VectorMatrixToVector {\n  (x: number[], y: Matrix<number>): F32Vector;\n}\n\n/**\n * A function that converts a scalar and a matrix to a matrix of acceptance\n * intervals.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface ScalarMatrixToMatrix {\n  (x: number, y: Matrix<number>): F32Matrix;\n}\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = addFlushedIfNeededF32(values);\n  const results = new Set<F32Interval>(inputs.map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n * op.domain is tested before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = addFlushedIfNeededF32(x_values);\n  const y_inputs = addFlushedIfNeededF32(y_values);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = addFlushedIfNeededF32(x_values);\n  const y_inputs = addFlushedIfNeededF32(y_values);\n  const z_inputs = addFlushedIfNeededF32(z_values);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a vector to an acceptance interval using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param x param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushVectorToInterval(x: number[], op: VectorToIntervalOp): F32Interval {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    intervals.add(op.impl(inner_x));\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a pair of vectors to an acceptance interval using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushVectorPairToInterval(\n  x: number[],\n  y: number[],\n  op: VectorPairToIntervalOp\n): F32Interval {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n  assert(\n    y.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const y_rounded: number[][] = y.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const y_flushed: number[][] = y_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n  const y_inputs = cartesianProduct<number>(...y_flushed);\n\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a vector to a vector of acceptance intervals using a specific\n * function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param x param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a vector of spans for each outputs of op.impl\n */\nfunction roundAndFlushVectorToVector(x: number[], op: VectorToVectorOp): F32Vector {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n\n  const interval_vectors = new Set<F32Vector>();\n  x_inputs.forEach(inner_x => {\n    interval_vectors.add(op.impl(inner_x));\n  });\n\n  return spanF32Vector(...interval_vectors);\n}\n\n/**\n * Converts a pair of vectors to a vector of acceptance intervals using a\n * specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param x second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a vector of spans for each output of op.impl\n */\nfunction roundAndFlushVectorPairToVector(\n  x: number[],\n  y: number[],\n  op: VectorPairToVectorOp\n): F32Vector {\n  assert(\n    x.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n  assert(\n    y.every(e => !Number.isNaN(e)),\n    `flush not defined for NaN`\n  );\n\n  const x_rounded: number[][] = x.map(correctlyRoundedF32);\n  const y_rounded: number[][] = y.map(correctlyRoundedF32);\n  const x_flushed: number[][] = x_rounded.map(addFlushedIfNeededF32);\n  const y_flushed: number[][] = y_rounded.map(addFlushedIfNeededF32);\n  const x_inputs = cartesianProduct<number>(...x_flushed);\n  const y_inputs = cartesianProduct<number>(...y_flushed);\n\n  const interval_vectors = new Set<F32Vector>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      interval_vectors.add(op.impl(inner_x, inner_y));\n    });\n  });\n\n  return spanF32Vector(...interval_vectors);\n}\n\n/** Converts a matrix to a matrix of acceptance intervals using a specific\n * function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n *\n * @param m param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a matrix of spans for each outputs of op.impl\n */\nfunction roundAndFlushMatrixToMatrix(m: Matrix<number>, op: MatrixToMatrixOp): F32Matrix {\n  const num_cols = m.length;\n  const num_rows = m[0].length;\n  assert(\n    m.every(c => c.every(r => !Number.isNaN(r))),\n    `flush not defined for NaN`\n  );\n\n  const m_flat = flatten2DArray(m);\n  const m_rounded: number[][] = m_flat.map(correctlyRoundedF32);\n  const m_flushed: number[][] = m_rounded.map(e => addFlushedIfNeededF32(e));\n  const m_options: number[][] = cartesianProduct<number>(...m_flushed);\n  const m_inputs: Matrix<number>[] = m_options.map(e => unflatten2DArray(e, num_cols, num_rows));\n\n  const interval_matrices = new Set<F32Matrix>();\n  m_inputs.forEach(inner_m => {\n    interval_matrices.add(op.impl(inner_m));\n  });\n\n  return spanF32Matrix(...interval_matrices);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointToIntervalOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (!x.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n\n  const result = F32Interval.span(...x.bounds().map(b => roundAndFlushPointToInterval(b, op)));\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runBinaryToIntervalOp(\n  x: F32Interval,\n  y: F32Interval,\n  op: BinaryToIntervalOp\n): F32Interval {\n  if (!x.isFinite() || !y.isFinite()) {\n    return F32Interval.any();\n  }\n\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n\n  const outputs = new Set<F32Interval>();\n  x.bounds().forEach(inner_x => {\n    y.bounds().forEach(inner_y => {\n      outputs.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runTernaryToIntervalOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  if (!x.isFinite() || !y.isFinite() || !z.isFinite()) {\n    return F32Interval.any();\n  }\n\n  const outputs = new Set<F32Interval>();\n  x.bounds().forEach(inner_x => {\n    y.bounds().forEach(inner_y => {\n      z.bounds().forEach(inner_z => {\n        outputs.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a vector function over given intervals\n *\n * @param x input domain intervals vector\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runVectorToIntervalOp(x: F32Vector, op: VectorToIntervalOp): F32Interval {\n  if (x.some(e => !e.isFinite())) {\n    return F32Interval.any();\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    outputs.add(roundAndFlushVectorToInterval(inner_x, op));\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the acceptance interval for a vector pair function over given intervals\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runVectorPairToIntervalOp(\n  x: F32Vector,\n  y: F32Vector,\n  op: VectorPairToIntervalOp\n): F32Interval {\n  if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n    return F32Interval.any();\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n  const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n  const outputs = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      outputs.add(roundAndFlushVectorPairToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  const result = F32Interval.span(...outputs);\n  return result.isFinite() ? result : F32Interval.any();\n}\n\n/** Calculate the vector of acceptance intervals for a pair of vector function over\n * given intervals\n *\n * @param x input domain intervals vector\n * @param op operation defining the function being run\n * @returns a vector of spans over all of the outputs of op.impl\n */\nfunction runVectorToVectorOp(x: F32Vector, op: VectorToVectorOp): F32Vector {\n  if (x.some(e => !e.isFinite())) {\n    return kAnyVector[x.length];\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n\n  const outputs = new Set<F32Vector>();\n  x_values.forEach(inner_x => {\n    outputs.add(roundAndFlushVectorToVector(inner_x, op));\n  });\n\n  const result = spanF32Vector(...outputs);\n  return result.every(e => e.isFinite()) ? result : toF32Vector(x.map(_ => F32Interval.any()));\n}\n\n/**\n * Calculate the vector of acceptance intervals by running a scalar operation\n * component-wise over a vector.\n *\n * This is used for situations where a component-wise operation, like vector\n * negation, is needed as part of a inherited accuracy, but the top-level\n * operation test don't require an explicit vector definition of the function,\n * due to the generated vectorize tests being sufficient.\n *\n * @param x input domain intervals vector\n * @param op scalar operation to be run component-wise\n * @returns a vector of intervals with the outputs of op.impl\n */\nfunction runPointToIntervalOpComponentWise(x: F32Vector, op: PointToIntervalOp): F32Vector {\n  return toF32Vector(\n    x.map(i => {\n      return runPointToIntervalOp(i, op);\n    })\n  );\n}\n\n/** Calculate the vector of acceptance intervals for a vector function over\n * given intervals\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op operation defining the function being run\n * @returns a vector of spans over all of the outputs of op.impl\n */\nfunction runVectorPairToVectorOp(x: F32Vector, y: F32Vector, op: VectorPairToVectorOp): F32Vector {\n  if (x.some(e => !e.isFinite()) || y.some(e => !e.isFinite())) {\n    return kAnyVector[x.length];\n  }\n\n  const x_values = cartesianProduct<number>(...x.map(e => e.bounds()));\n  const y_values = cartesianProduct<number>(...y.map(e => e.bounds()));\n\n  const outputs = new Set<F32Vector>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      outputs.add(roundAndFlushVectorPairToVector(inner_x, inner_y, op));\n    });\n  });\n\n  const result = spanF32Vector(...outputs);\n  return result.every(e => e.isFinite()) ? result : toF32Vector(x.map(_ => F32Interval.any()));\n}\n\n/**\n * Calculate the vector of acceptance intervals by running a scalar operation\n * component-wise over a pair vectors.\n *\n * This is used for situations where a component-wise operation, like vector\n * subtraction, is needed as part of a inherited accuracy, but the top-level\n * operation test don't require an explicit vector definition of the function,\n * due to the generated vectorize tests being sufficient.\n *\n * @param x first input domain intervals vector\n * @param y second input domain intervals vector\n * @param op scalar operation to be run component-wise\n * @returns a vector of intervals with the outputs of op.impl\n */\nfunction runBinaryToIntervalOpVectorComponentWise(\n  x: F32Vector,\n  y: F32Vector,\n  op: BinaryToIntervalOp\n): F32Vector {\n  assert(\n    x.length === y.length,\n    `runBinaryToIntervalOpVectorComponentWise requires vectors of the same length`\n  );\n  return toF32Vector(\n    x.map((i, idx) => {\n      return runBinaryToIntervalOp(i, y[idx], op);\n    })\n  );\n}\n\n/** Calculate the matrix of acceptance intervals for a pair of matrix function over\n * given intervals\n *\n * @param x input domain intervals matrix\n * @param x input domain intervals matrix\n * @param op operation defining the function being run\n * @returns a matrix of spans over all of the outputs of op.impl\n */\nfunction runMatrixToMatrixOp(m: F32Matrix, op: MatrixToMatrixOp): F32Matrix {\n  const num_cols = m.length;\n  const num_rows = m[0].length;\n  if (m.some(c => c.some(r => !r.isFinite()))) {\n    return kAnyF32Matrix[num_cols][num_rows];\n  }\n\n  const m_flat: F32Interval[] = flatten2DArray(m);\n  const m_values: number[][] = cartesianProduct<number>(...m_flat.map(e => e.bounds()));\n\n  const outputs = new Set<F32Matrix>();\n  m_values.forEach(inner_m => {\n    const unflat_m = unflatten2DArray(inner_m, num_cols, num_rows);\n    outputs.add(roundAndFlushMatrixToMatrix(unflat_m, op));\n  });\n\n  const result = spanF32Matrix(...outputs);\n  const result_cols = result.length;\n  const result_rows = result[0].length;\n\n  // F32Matrix has to be coerced to F32Interval[][] to use .every\n  return (result as F32Interval[][]).every(c => c.every(r => r.isFinite()))\n    ? result\n    : kAnyF32Matrix[result_cols][result_rows];\n}\n\n/**\n * Calculate the Matrix of acceptance intervals by running a scalar operation\n * component-wise over a pair of matrices.\n *\n * An example of this is performing matrix addition.\n *\n * @param x first input domain intervals matrix\n * @param y second input domain intervals matrix\n * @param op scalar operation to be run component-wise\n * @returns a matrix of intervals with the outputs of op.impl\n */\nfunction runBinaryToIntervalOpMatrixComponentWise(\n  x: F32Matrix,\n  y: F32Matrix,\n  op: BinaryToIntervalOp\n): F32Matrix {\n  assert(\n    x.length === y.length && x[0].length === y[0].length,\n    `runBinaryToIntervalOpMatrixComponentWise requires matrices of the same dimensions`\n  );\n\n  const cols = x.length;\n  const rows = x[0].length;\n  const flat_x = flatten2DArray(x);\n  const flat_y = flatten2DArray(y);\n\n  return toF32Matrix(\n    unflatten2DArray(\n      flat_x.map((i, idx) => {\n        return runBinaryToIntervalOp(i, flat_y[idx], op);\n      }),\n      cols,\n      rows\n    )\n  );\n}\n\n/** Defines a PointToIntervalOp for an interval of the correctly rounded values around the point */\nconst CorrectlyRoundedIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    assert(!Number.isNaN(n), `absolute not defined for NaN`);\n    return toF32Interval(n);\n  },\n};\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CorrectlyRoundedIntervalOp);\n}\n\n/** @returns a matrix of correctly rounded intervals for the provided matrix */\nexport function correctlyRoundedMatrix(m: Matrix<number>): F32Matrix {\n  return toF32Matrix(map2DArray(m, correctlyRoundedInterval));\n}\n\n/** @returns a PointToIntervalOp for [n - error_range, n + error_range] */\nfunction AbsoluteErrorIntervalOp(error_range: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isFiniteF32(error_range)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `absolute error not defined for NaN`);\n      return toF32Interval([n - error_range, n + error_range]);\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  error_range = Math.abs(error_range);\n  return runPointToIntervalOp(toF32Interval(n), AbsoluteErrorIntervalOp(error_range));\n}\n\n/** @returns a PointToIntervalOp for [n - numULP * ULP(n), n + numULP * ULP(n)] */\nfunction ULPIntervalOp(numULP: number): PointToIntervalOp {\n  const op: PointToIntervalOp = {\n    impl: (_: number) => {\n      return F32Interval.any();\n    },\n  };\n\n  if (isFiniteF32(numULP)) {\n    op.impl = (n: number) => {\n      assert(!Number.isNaN(n), `ULP error not defined for NaN`);\n\n      const ulp = oneULPF32(n);\n      const begin = n - numULP * ulp;\n      const end = n + numULP * ulp;\n\n      return toF32Interval([\n        Math.min(begin, flushSubnormalNumberF32(begin)),\n        Math.max(end, flushSubnormalNumberF32(end)),\n      ]);\n    };\n  }\n\n  return op;\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return runPointToIntervalOp(toF32Interval(n), ULPIntervalOp(numULP));\n}\n\nconst AbsIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    return correctlyRoundedInterval(Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AbsIntervalOp);\n}\n\nconst AcosIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(toF32Interval([-1.0, 1.0]), (n: number) => {\n    // acos(n) = atan2(sqrt(1.0 - n * n), n) or a polynomial approximation with absolute error\n    const y = sqrtInterval(subtractionInterval(1, multiplicationInterval(n, n)));\n    return F32Interval.span(atan2Interval(y, n), absoluteErrorInterval(Math.acos(n), 6.77e-5));\n  }),\n};\n\n/** Calculate an acceptance interval for acos(n) */\nexport function acosInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AcosIntervalOp);\n}\n\n/** All acceptance interval functions for acosh(x) */\nexport const acoshIntervals: PointToInterval[] = [acoshAlternativeInterval, acoshPrimaryInterval];\n\nconst AcoshAlternativeIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // acosh(x) = log(x + sqrt((x + 1.0f) * (x - 1.0)))\n    const inner_value = multiplicationInterval(\n      additionInterval(x, 1.0),\n      subtractionInterval(x, 1.0)\n    );\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of acosh(x) using log(x + sqrt((x + 1.0f) * (x - 1.0))) */\nexport function acoshAlternativeInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), AcoshAlternativeIntervalOp);\n}\n\nconst AcoshPrimaryIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // acosh(x) = log(x + sqrt(x * x - 1.0))\n    const inner_value = subtractionInterval(multiplicationInterval(x, x), 1.0);\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of acosh(x) using log(x + sqrt(x * x - 1.0)) */\nexport function acoshPrimaryInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), AcoshPrimaryIntervalOp);\n}\n\nconst AdditionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x + y);\n  },\n};\n\n/** Calculate an acceptance interval of x + y */\nexport function additionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), AdditionIntervalOp);\n}\n\n/** Calculate an acceptance interval of x + y, when x and y are matrices */\nexport function additionMatrixInterval(x: Matrix<number>, y: Matrix<number>): F32Matrix {\n  return runBinaryToIntervalOpMatrixComponentWise(\n    toF32Matrix(x),\n    toF32Matrix(y),\n    AdditionIntervalOp\n  );\n}\n\nconst AsinIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(toF32Interval([-1.0, 1.0]), (n: number) => {\n    // asin(n) = atan2(n, sqrt(1.0 - n * n)) or a polynomial approximation with absolute error\n    const x = sqrtInterval(subtractionInterval(1, multiplicationInterval(n, n)));\n    return F32Interval.span(atan2Interval(n, x), absoluteErrorInterval(Math.asin(n), 6.77e-5));\n  }),\n};\n\n/** Calculate an acceptance interval for asin(n) */\nexport function asinInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AsinIntervalOp);\n}\n\nconst AsinhIntervalOp: PointToIntervalOp = {\n  impl: (x: number): F32Interval => {\n    // asinh(x) = log(x + sqrt(x * x + 1.0))\n    const inner_value = additionInterval(multiplicationInterval(x, x), 1.0);\n    const sqrt_value = sqrtInterval(inner_value);\n    return logInterval(additionInterval(x, sqrt_value));\n  },\n};\n\n/** Calculate an acceptance interval of asinh(x) */\nexport function asinhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AsinhIntervalOp);\n}\n\nconst AtanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.atan(n), 4096);\n  },\n};\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AtanIntervalOp);\n}\n\nconst Atan2IntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    {\n      // For atan2, there params are labelled (y, x), not (x, y), so domain.x is first parameter (y), and domain.y is\n      // the second parameter (x)\n      x: [\n        toF32Interval([kValue.f32.negative.min, kValue.f32.negative.max]),\n        toF32Interval([kValue.f32.positive.min, kValue.f32.positive.max]),\n      ], // first param must be finite and normal\n      y: [toF32Interval([-(2 ** 126), -(2 ** -126)]), toF32Interval([2 ** -126, 2 ** 126])], // inherited from division\n    },\n    (y: number, x: number): F32Interval => {\n      const atan_yx = Math.atan(y / x);\n      // x > 0, atan(y/x)\n      if (x > 0) {\n        return ulpInterval(atan_yx, 4096);\n      }\n\n      // x < 0, y > 0, atan(y/x) + π\n      if (y > 0) {\n        return ulpInterval(atan_yx + kValue.f32.positive.pi.whole, 4096);\n      }\n\n      // x < 0, y < 0, atan(y/x) - π\n      return ulpInterval(atan_yx - kValue.f32.positive.pi.whole, 4096);\n    }\n  ),\n  extrema: (y: F32Interval, x: F32Interval): [F32Interval, F32Interval] => {\n    // There is discontinuity + undefined behaviour at y/x = 0 that will dominate the accuracy\n    if (y.contains(0)) {\n      if (x.contains(0)) {\n        return [toF32Interval(0), toF32Interval(0)];\n      }\n      return [toF32Interval(0), x];\n    }\n    return [y, x];\n  },\n};\n\n/** Calculate an acceptance interval of atan2(y, x) */\nexport function atan2Interval(y: number | F32Interval, x: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(y), toF32Interval(x), Atan2IntervalOp);\n}\n\nconst AtanhIntervalOp: PointToIntervalOp = {\n  impl: (n: number) => {\n    // atanh(x) = log((1.0 + x) / (1.0 - x)) * 0.5\n    const numerator = additionInterval(1.0, n);\n    const denominator = subtractionInterval(1.0, n);\n    const log_interval = logInterval(divisionInterval(numerator, denominator));\n    return multiplicationInterval(log_interval, 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of atanh(x) */\nexport function atanhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), AtanhIntervalOp);\n}\n\nconst CeilIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.ceil(n));\n  },\n};\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CeilIntervalOp);\n}\n\nconst ClampMedianIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return correctlyRoundedInterval(\n      // Default sort is string sort, so have to implement numeric comparison.\n      // Cannot use the b-a one liner, because that assumes no infinities.\n      [x, y, z].sort((a, b) => {\n        if (a < b) {\n          return -1;\n        }\n        if (a > b) {\n          return 1;\n        }\n        return 0;\n      })[1]\n    );\n  },\n};\n\n/** All acceptance interval functions for clamp(x, y, z) */\nexport const clampIntervals: TernaryToInterval[] = [clampMinMaxInterval, clampMedianInterval];\n\n/** Calculate an acceptance interval of clamp(x, y, z) via median(x, y, z) */\nexport function clampMedianInterval(\n  x: number | F32Interval,\n  y: number | F32Interval,\n  z: number | F32Interval\n): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    ClampMedianIntervalOp\n  );\n}\n\nconst ClampMinMaxIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, low: number, high: number): F32Interval => {\n    return minInterval(maxInterval(x, low), high);\n  },\n};\n\n/** Calculate an acceptance interval of clamp(x, high, low) via min(max(x, low), high) */\nexport function clampMinMaxInterval(\n  x: number | F32Interval,\n  low: number | F32Interval,\n  high: number | F32Interval\n): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(low),\n    toF32Interval(high),\n    ClampMinMaxIntervalOp\n  );\n}\n\nconst CosIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.cos(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CosIntervalOp);\n}\n\nconst CoshIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // cosh(x) = (exp(x) + exp(-x)) * 0.5\n    const minus_n = negationInterval(n);\n    return multiplicationInterval(additionInterval(expInterval(n), expInterval(minus_n)), 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of cosh(x) */\nexport function coshInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), CoshIntervalOp);\n}\n\nconst CrossIntervalOp: VectorPairToVectorOp = {\n  impl: (x: number[], y: number[]): F32Vector => {\n    assert(x.length === 3, `CrossIntervalOp received x with ${x.length} instead of 3`);\n    assert(y.length === 3, `CrossIntervalOp received y with ${y.length} instead of 3`);\n\n    // cross(x, y) = r, where\n    //   r[0] = x[1] * y[2] - x[2] * y[1]\n    //   r[1] = x[2] * y[0] - x[0] * y[2]\n    //   r[2] = x[0] * y[1] - x[1] * y[0]\n\n    const r0 = subtractionInterval(\n      multiplicationInterval(x[1], y[2]),\n      multiplicationInterval(x[2], y[1])\n    );\n    const r1 = subtractionInterval(\n      multiplicationInterval(x[2], y[0]),\n      multiplicationInterval(x[0], y[2])\n    );\n    const r2 = subtractionInterval(\n      multiplicationInterval(x[0], y[1]),\n      multiplicationInterval(x[1], y[0])\n    );\n    return [r0, r1, r2];\n  },\n};\n\nexport function crossInterval(x: number[], y: number[]): F32Vector {\n  assert(x.length === 3, `Cross is only defined for vec3`);\n  assert(y.length === 3, `Cross is only defined for vec3`);\n  return runVectorPairToVectorOp(toF32Vector(x), toF32Vector(y), CrossIntervalOp);\n}\n\nconst DegreesIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 57.295779513082322865);\n  },\n};\n\n/** Calculate an acceptance interval of degrees(x) */\nexport function degreesInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), DegreesIntervalOp);\n}\n\n/**\n * Calculate the minor of a NxN matrix.\n *\n * The ijth minor of a square matrix, is the N-1xN-1 matrix created by removing\n * the ith column and jth row from the original matrix.\n */\nfunction minorNxN(m: Matrix<number>, col: number, row: number): Matrix<number> {\n  const dim = m.length;\n  assert(m.length === m[0].length, `minorMatrix is only defined for square matrices`);\n  assert(col >= 0 && col < dim, `col ${col} needs be in [0, # of columns '${dim}')`);\n  assert(row >= 0 && row < dim, `row ${row} needs be in [0, # of rows '${dim}')`);\n\n  const result: Matrix<number> = [...Array(dim - 1)].map(_ => [...Array(dim - 1)]);\n\n  const col_indices: number[] = [...Array(dim).keys()].filter(e => e !== col);\n  const row_indices: number[] = [...Array(dim).keys()].filter(e => e !== row);\n\n  col_indices.forEach((c, i) => {\n    row_indices.forEach((r, j) => {\n      result[i][j] = m[c][r];\n    });\n  });\n  return result;\n}\n\n/** Calculate an acceptance interval for determinant(m), where m is a 2x2 matrix */\nfunction determinant2x2Interval(m: Matrix<number>): F32Interval {\n  assert(\n    m.length === m[0].length && m.length === 2,\n    `determinant2x2Interval called on non-2x2 matrix`\n  );\n  return subtractionInterval(\n    multiplicationInterval(m[0][0], m[1][1]),\n    multiplicationInterval(m[0][1], m[1][0])\n  );\n}\n\n/** Calculate an acceptance interval for determinant(m), where m is a 3x3 matrix */\nfunction determinant3x3Interval(m: Matrix<number>): F32Interval {\n  assert(\n    m.length === m[0].length && m.length === 3,\n    `determinant3x3Interval called on non-3x3 matrix`\n  );\n\n  // M is a 3x3 matrix\n  // det(M) is A + B + C, where A, B, C are three elements in a row/column times\n  // their own co-factor.\n  // (The co-factor is the determinant of the minor of that position with the\n  // appropriate +/-)\n  // For simplicity sake A, B, C are calculated as the elements of the first\n  // column\n  const A = multiplicationInterval(m[0][0], determinant2x2Interval(minorNxN(m, 0, 0)));\n  const B = multiplicationInterval(-m[0][1], determinant2x2Interval(minorNxN(m, 0, 1)));\n  const C = multiplicationInterval(m[0][2], determinant2x2Interval(minorNxN(m, 0, 2)));\n\n  // Need to calculate permutations, since for fp addition is not associative,\n  // so A + B + C is not guaranteed to equal B + C + A, etc.\n  const permutations: F32Interval[][] = calculatePermutations([A, B, C]);\n  return F32Interval.span(\n    ...permutations.map(p =>\n      p.reduce((prev: F32Interval, cur: F32Interval) => additionInterval(prev, cur))\n    )\n  );\n}\n\n/** Calculate an acceptance interval for determinant(m), where m is a 4x4 matrix */\nfunction determinant4x4Interval(m: Matrix<number>): F32Interval {\n  assert(\n    m.length === m[0].length && m.length === 4,\n    `determinant3x3Interval called on non-4x4 matrix`\n  );\n\n  // M is a 4x4 matrix\n  // det(M) is A + B + C + D, where A, B, C, D are four elements in a row/column\n  // times their own co-factor.\n  // (The co-factor is the determinant of the minor of that position with the\n  // appropriate +/-)\n  // For simplicity sake A, B, C, D are calculated as the elements of the\n  // first column\n  const A = multiplicationInterval(m[0][0], determinant3x3Interval(minorNxN(m, 0, 0)));\n  const B = multiplicationInterval(-m[0][1], determinant3x3Interval(minorNxN(m, 0, 1)));\n  const C = multiplicationInterval(m[0][2], determinant3x3Interval(minorNxN(m, 0, 2)));\n  const D = multiplicationInterval(-m[0][3], determinant3x3Interval(minorNxN(m, 0, 3)));\n\n  // Need to calculate permutations, since for fp addition is not associative\n  // so A + B + C + D is not guaranteed to equal B + C + A + D, etc.\n  const permutations: F32Interval[][] = calculatePermutations([A, B, C, D]);\n  return F32Interval.span(\n    ...permutations.map(p =>\n      p.reduce((prev: F32Interval, cur: F32Interval) => additionInterval(prev, cur))\n    )\n  );\n}\n\n/**\n * Calculate an acceptance interval for determinant(x)\n *\n * This code calculates 3x3 and 4x4 determinants using the textbook co-factor\n * method, using the first column for the co-factor selection.\n *\n * For matrices composed of integer elements, e, with |e|^4 < 2**21, this\n * should be fine.\n *\n * For e, where e is subnormal or 4*(e^4) might not be precisely expressible as\n * a f32 values, this approach breaks down, because the rule of all co-factor\n * definitions of determinant being equal doesn't hold in these cases.\n *\n * The general solution for this is to calculate all of the permutations of the\n * operations in the worked out formula for determinant.\n * For 3x3 this is tractable, but for 4x4 this works out to ~23! permutations\n * that need to be calculated.\n * Thus CTS testing, and the spec definition of accuracy is restricted to the\n * space that the simple implementation is valid.\n */\nexport function determinantInterval(x: Matrix<number>): F32Interval {\n  const dim = x.length;\n  assert(\n    x[0].length === dim && (dim === 2 || dim === 3 || dim === 4),\n    `determinantInterval only defined for 2x2, 3x3 and 4x4 matrices`\n  );\n  switch (dim) {\n    case 2:\n      return determinant2x2Interval(x);\n    case 3:\n      return determinant3x3Interval(x);\n    case 4:\n      return determinant4x4Interval(x);\n  }\n  unreachable(\n    \"determinantInterval called on x, where which has an unexpected dimension of '${dim}'\"\n  );\n}\n\nconst DistanceIntervalScalarOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return lengthInterval(subtractionInterval(x, y));\n  },\n};\n\nconst DistanceIntervalVectorOp: VectorPairToIntervalOp = {\n  impl: (x: number[], y: number[]): F32Interval => {\n    return lengthInterval(\n      runBinaryToIntervalOpVectorComponentWise(\n        toF32Vector(x),\n        toF32Vector(y),\n        SubtractionIntervalOp\n      )\n    );\n  },\n};\n\n/** Calculate an acceptance interval of distance(x, y) */\nexport function distanceInterval(x: number | number[], y: number | number[]): F32Interval {\n  if (x instanceof Array && y instanceof Array) {\n    assert(\n      x.length === y.length,\n      `distanceInterval requires both params to have the same number of elements`\n    );\n    return runVectorPairToIntervalOp(toF32Vector(x), toF32Vector(y), DistanceIntervalVectorOp);\n  } else if (!(x instanceof Array) && !(y instanceof Array)) {\n    return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), DistanceIntervalScalarOp);\n  }\n  unreachable(\n    `distanceInterval requires both params to both the same type, either scalars or vectors`\n  );\n}\n\nconst DivisionIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    {\n      x: [toF32Interval([kValue.f32.negative.min, kValue.f32.positive.max])],\n      y: [toF32Interval([-(2 ** 126), -(2 ** -126)]), toF32Interval([2 ** -126, 2 ** 126])],\n    },\n    (x: number, y: number): F32Interval => {\n      if (y === 0) {\n        return F32Interval.any();\n      }\n      return ulpInterval(x / y, 2.5);\n    }\n  ),\n  extrema: (x: F32Interval, y: F32Interval): [F32Interval, F32Interval] => {\n    // division has a discontinuity at y = 0.\n    if (y.contains(0)) {\n      y = toF32Interval(0);\n    }\n    return [x, y];\n  },\n};\n\n/** Calculate an acceptance interval of x / y */\nexport function divisionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), DivisionIntervalOp);\n}\n\nconst DotIntervalOp: VectorPairToIntervalOp = {\n  impl: (x: number[], y: number[]): F32Interval => {\n    // dot(x, y) = sum of x[i] * y[i]\n    const multiplications = runBinaryToIntervalOpVectorComponentWise(\n      toF32Vector(x),\n      toF32Vector(y),\n      MultiplicationIntervalOp\n    );\n\n    // vec2 doesn't require permutations, since a + b = b + a for floats\n    if (multiplications.length === 2) {\n      return additionInterval(multiplications[0], multiplications[1]);\n    }\n\n    // The spec does not state the ordering of summation, so all of the permutations are calculated and their results\n    // spanned, since addition of more then two floats is not transitive, i.e. a + b + c is not guaranteed to equal\n    // b + a + c\n    const permutations: F32Interval[][] = calculatePermutations(multiplications);\n    return F32Interval.span(\n      ...permutations.map(p => p.reduce((prev, cur) => additionInterval(prev, cur)))\n    );\n  },\n};\n\nexport function dotInterval(x: number[] | F32Interval[], y: number[] | F32Interval[]): F32Interval {\n  assert(x.length === y.length, `dot not defined for vectors with different lengths`);\n  return runVectorPairToIntervalOp(toF32Vector(x), toF32Vector(y), DotIntervalOp);\n}\n\nconst ExpIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.exp(n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp(x) */\nexport function expInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), ExpIntervalOp);\n}\n\nconst Exp2IntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return ulpInterval(Math.pow(2, n), 3 + 2 * Math.abs(n));\n  },\n};\n\n/** Calculate an acceptance interval for exp2(x) */\nexport function exp2Interval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), Exp2IntervalOp);\n}\n\n/**\n * Calculate the acceptance intervals for faceForward(x, y, z)\n *\n * faceForward(x, y, z) = select(-x, x, dot(z, y) < 0.0)\n *\n * This builtin selects from two discrete results (delta rounding/flushing), so\n * the majority of the framework code is not appropriate, since the framework\n * attempts to span results.\n *\n * Thus a bespoke implementation is used instead of\n * defining a Op and running that through the framework.\n */\nexport function faceForwardIntervals(\n  x: number[],\n  y: number[],\n  z: number[]\n): (F32Vector | undefined)[] {\n  const x_vec = toF32Vector(x);\n  // Running vector through runPointToIntervalOpComponentWise to make sure that flushing/rounding is handled, since\n  // toF32Vector does not perform those operations.\n  const positive_x = runPointToIntervalOpComponentWise(x_vec, { impl: toF32Interval });\n  const negative_x = runPointToIntervalOpComponentWise(x_vec, NegationIntervalOp);\n\n  const dot_interval = dotInterval(z, y);\n\n  const results: (F32Vector | undefined)[] = [];\n\n  if (!dot_interval.isFinite()) {\n    // dot calculation went out of bounds\n    // Inserting undefine in the result, so that the test running framework is aware\n    // of this potential OOB.\n    // For const-eval tests, it means that the test case should be skipped,\n    // since the shader will fail to compile.\n    // For non-const-eval the undefined should be stripped out of the possible\n    // results.\n\n    results.push(undefined);\n  }\n\n  // Because the result of dot can be an interval, it might span across 0, thus\n  // it is possible that both -x and x are valid responses.\n  if (dot_interval.begin < 0 || dot_interval.end < 0) {\n    results.push(positive_x);\n  }\n\n  if (dot_interval.begin >= 0 || dot_interval.end >= 0) {\n    results.push(negative_x);\n  }\n\n  assert(\n    results.length > 0 || results.every(r => r === undefined),\n    `faceForwardInterval selected neither positive x or negative x for the result, this shouldn't be possible`\n  );\n  return results;\n}\n\nconst FloorIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.floor(n));\n  },\n};\n\n/** Calculate an acceptance interval of floor(x) */\nexport function floorInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), FloorIntervalOp);\n}\n\nconst FmaIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    return additionInterval(multiplicationInterval(x, y), z);\n  },\n};\n\n/** Calculate an acceptance interval for fma(x, y, z) */\nexport function fmaInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    FmaIntervalOp\n  );\n}\n\nconst FractIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // fract(x) = x - floor(x) is defined in the spec.\n    // For people coming from a non-graphics background this will cause some unintuitive results. For example,\n    // fract(-1.1) is not 0.1 or -0.1, but instead 0.9.\n    // This is how other shading languages operate and allows for a desirable wrap around in graphics programming.\n    const result = subtractionInterval(n, floorInterval(n));\n    if (result.contains(1)) {\n      // Very small negative numbers can lead to catastrophic cancellation, thus calculating a fract of 1.0, which is\n      // technically not a fractional part, so some implementations clamp the result to next nearest number.\n      return F32Interval.span(result, toF32Interval(kValue.f32.positive.less_than_one));\n    }\n    return result;\n  },\n};\n\n/** Calculate an acceptance interval of fract(x) */\nexport function fractInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), FractIntervalOp);\n}\n\nconst InverseSqrtIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      return ulpInterval(1 / Math.sqrt(n), 2);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of inverseSqrt(x) */\nexport function inverseSqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), InverseSqrtIntervalOp);\n}\n\nconst LdexpIntervalOp: BinaryToIntervalOp = {\n  impl: limitBinaryToIntervalDomain(\n    // Implementing SPIR-V's more restrictive domain until\n    // https://github.com/gpuweb/gpuweb/issues/3134 is resolved\n    {\n      x: [toF32Interval([kValue.f32.negative.min, kValue.f32.positive.max])],\n      y: [toF32Interval([-126, 128])],\n    },\n    (e1: number, e2: number): F32Interval => {\n      // Though the spec says the result of ldexp(e1, e2) = e1 * 2 ^ e2, the\n      // accuracy is listed as correctly rounded to the true value, so the\n      // inheritance framework does not need to be invoked to determine bounds.\n      // Instead the value at a higher precision is calculated and passed to\n      // correctlyRoundedInterval.\n      const result = e1 * 2 ** e2;\n      if (Number.isNaN(result)) {\n        // Overflowed TS's number type, so definitely out of bounds for f32\n        return F32Interval.any();\n      }\n      return correctlyRoundedInterval(result);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of ldexp(e1, e2) */\nexport function ldexpInterval(e1: number, e2: number): F32Interval {\n  return roundAndFlushBinaryToInterval(e1, e2, LdexpIntervalOp);\n}\n\nconst LengthIntervalScalarOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return sqrtInterval(multiplicationInterval(n, n));\n  },\n};\n\nconst LengthIntervalVectorOp: VectorToIntervalOp = {\n  impl: (n: number[]): F32Interval => {\n    return sqrtInterval(dotInterval(n, n));\n  },\n};\n\n/** Calculate an acceptance interval of length(x) */\nexport function lengthInterval(n: number | F32Interval | number[] | F32Vector): F32Interval {\n  if (n instanceof Array) {\n    return runVectorToIntervalOp(toF32Vector(n), LengthIntervalVectorOp);\n  } else {\n    return runPointToIntervalOp(toF32Interval(n), LengthIntervalScalarOp);\n  }\n}\n\nconst LogIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log(x) */\nexport function logInterval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), LogIntervalOp);\n}\n\nconst Log2IntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kGreaterThanZeroInterval,\n    (n: number): F32Interval => {\n      if (n >= 0.5 && n <= 2.0) {\n        return absoluteErrorInterval(Math.log2(n), 2 ** -21);\n      }\n      return ulpInterval(Math.log2(n), 3);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of log2(x) */\nexport function log2Interval(x: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(x), Log2IntervalOp);\n}\n\nconst MaxIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    // If both of he inputs are subnormal, then either of the inputs can be returned\n    if (isSubnormalNumberF32(x) && isSubnormalNumberF32(y)) {\n      return correctlyRoundedInterval(F32Interval.span(toF32Interval(x), toF32Interval(y)));\n    }\n\n    return correctlyRoundedInterval(Math.max(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of max(x, y) */\nexport function maxInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), MaxIntervalOp);\n}\n\nconst MinIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    // If both of he inputs are subnormal, then either of the inputs can be returned\n    if (isSubnormalNumberF32(x) && isSubnormalNumberF32(y)) {\n      return correctlyRoundedInterval(F32Interval.span(toF32Interval(x), toF32Interval(y)));\n    }\n\n    return correctlyRoundedInterval(Math.min(x, y));\n  },\n};\n\n/** Calculate an acceptance interval of min(x, y) */\nexport function minInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), MinIntervalOp);\n}\n\nconst MixImpreciseIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    // x + (y - x) * z =\n    //  x + t, where t = (y - x) * z\n    const t = multiplicationInterval(subtractionInterval(y, x), z);\n    return additionInterval(x, t);\n  },\n};\n\n/** All acceptance interval functions for mix(x, y, z) */\nexport const mixIntervals: TernaryToInterval[] = [mixImpreciseInterval, mixPreciseInterval];\n\n/** Calculate an acceptance interval of mix(x, y, z) using x + (y - x) * z */\nexport function mixImpreciseInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    MixImpreciseIntervalOp\n  );\n}\n\nconst MixPreciseIntervalOp: TernaryToIntervalOp = {\n  impl: (x: number, y: number, z: number): F32Interval => {\n    // x * (1.0 - z) + y * z =\n    //   t + s, where t = x * (1.0 - z), s = y * z\n    const t = multiplicationInterval(x, subtractionInterval(1.0, z));\n    const s = multiplicationInterval(y, z);\n    return additionInterval(t, s);\n  },\n};\n\n/** Calculate an acceptance interval of mix(x, y, z) using x * (1.0 - z) + y * z */\nexport function mixPreciseInterval(x: number, y: number, z: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(x),\n    toF32Interval(y),\n    toF32Interval(z),\n    MixPreciseIntervalOp\n  );\n}\n\n/** Calculate an acceptance interval of modf(x) */\nexport function modfInterval(n: number): { fract: F32Interval; whole: F32Interval } {\n  const fract = correctlyRoundedInterval(n % 1.0);\n  const whole = correctlyRoundedInterval(n - (n % 1.0));\n  return { fract, whole };\n}\n\nconst MultiplicationInnerOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x * y);\n  },\n};\n\nconst MultiplicationIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return roundAndFlushBinaryToInterval(x, y, MultiplicationInnerOp);\n  },\n};\n\n/** Calculate an acceptance interval of x * y */\nexport function multiplicationInterval(\n  x: number | F32Interval,\n  y: number | F32Interval\n): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), MultiplicationIntervalOp);\n}\n\n/** Calculate an acceptance interval of x * y, when x is a matrix and y is a scalar */\nexport function multiplicationMatrixScalarInterval(mat: Matrix<number>, scalar: number): F32Matrix {\n  const cols = mat.length;\n  const rows = mat[0].length;\n  return toF32Matrix(\n    unflatten2DArray(\n      flatten2DArray(mat).map(e => MultiplicationIntervalOp.impl(e, scalar)),\n      cols,\n      rows\n    )\n  );\n}\n\n/** Calculate an acceptance interval of x * y, when x is a scalar and y is a matrix */\nexport function multiplicationScalarMatrixInterval(scalar: number, mat: Matrix<number>): F32Matrix {\n  return multiplicationMatrixScalarInterval(mat, scalar);\n}\n\n/** Calculate an acceptance interval of x * y, when x is a matrix and y is a matrix */\nexport function multiplicationMatrixMatrixInterval(\n  mat_x: Matrix<number>,\n  mat_y: Matrix<number>\n): F32Matrix {\n  const x_cols = mat_x.length;\n  const x_rows = mat_x[0].length;\n  const y_cols = mat_y.length;\n  const y_rows = mat_y[0].length;\n  assert(x_cols === y_rows, `'mat${x_cols}x${x_rows} * mat${y_cols}x${y_rows}' is not defined`);\n\n  const x_transposed = transposeInterval(mat_x);\n\n  const result: Matrix<F32Interval> = [...Array(y_cols)].map(_ => [...Array(x_rows)]);\n  mat_y.forEach((y, i) => {\n    x_transposed.forEach((x, j) => {\n      result[i][j] = dotInterval(x, y);\n    });\n  });\n\n  return result as F32Matrix;\n}\n\n/** Calculate an acceptance interval of x * y, when x is a matrix and y is a vector */\nexport function multiplicationMatrixVectorInterval(x: Matrix<number>, y: number[]): F32Vector {\n  const cols = x.length;\n  const rows = x[0].length;\n  assert(y.length === cols, `'mat${cols}x${rows} * vec${y.length}' is not defined`);\n\n  return transposeInterval(x).map(e => dotInterval(e, y)) as F32Vector;\n}\n\n/** Calculate an acceptance interval of x * y, when x is a vector and y is a matrix */\nexport function multiplicationVectorMatrixInterval(x: number[], y: Matrix<number>): F32Vector {\n  const cols = y.length;\n  const rows = y[0].length;\n  assert(x.length === rows, `'vec${x.length} * mat${cols}x${rows}' is not defined`);\n\n  return y.map(e => dotInterval(x, e)) as F32Vector;\n}\n\nconst NegationIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(-n);\n  },\n};\n\n/** Calculate an acceptance interval of -x */\nexport function negationInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), NegationIntervalOp);\n}\n\nconst NormalizeIntervalOp: VectorToVectorOp = {\n  impl: (n: number[]): F32Vector => {\n    const length = lengthInterval(n);\n    return toF32Vector(n.map(e => divisionInterval(e, length)));\n  },\n};\n\n/** Calculate an acceptance interval of normalize(x) */\nexport function normalizeInterval(n: number[]): F32Vector {\n  return runVectorToVectorOp(toF32Vector(n), NormalizeIntervalOp);\n}\n\nconst PowIntervalOp: BinaryToIntervalOp = {\n  // pow(x, y) has no explicit domain restrictions, but inherits the x <= 0\n  // domain restriction from log2(x). Invoking log2Interval(x) in impl will\n  // enforce this, so there is no need to wrap the impl call here.\n  impl: (x: number, y: number): F32Interval => {\n    return exp2Interval(multiplicationInterval(y, log2Interval(x)));\n  },\n};\n\n/** Calculate an acceptance interval of pow(x, y) */\nexport function powInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), PowIntervalOp);\n}\n\n// Once a full implementation of F16Interval exists, the correctlyRounded for\n// that can potentially be used instead of having a bespoke operation\n// implementation.\nconst QuantizeToF16IntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    const rounded = correctlyRoundedF16(n);\n    const flushed = addFlushedIfNeededF16(rounded);\n    return F32Interval.span(...flushed.map(toF32Interval));\n  },\n};\n\n/** Calculate an acceptance interval of quanitizeToF16(x) */\nexport function quantizeToF16Interval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), QuantizeToF16IntervalOp);\n}\n\nconst RadiansIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return multiplicationInterval(n, 0.017453292519943295474);\n  },\n};\n\n/** Calculate an acceptance interval of radians(x) */\nexport function radiansInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), RadiansIntervalOp);\n}\n\nconst ReflectIntervalOp: VectorPairToVectorOp = {\n  impl: (x: number[], y: number[]): F32Vector => {\n    assert(\n      x.length === y.length,\n      `ReflectIntervalOp received x (${x}) and y (${y}) with different numbers of elements`\n    );\n\n    // reflect(x, y) = x - 2.0 * dot(x, y) * y\n    //               = x - t * y, t = 2.0 * dot(x, y)\n    // x = incident vector\n    // y = normal of reflecting surface\n    const t = multiplicationInterval(2.0, dotInterval(x, y));\n    const rhs = multiplyVectorByScalar(y, t);\n    return runBinaryToIntervalOpVectorComponentWise(toF32Vector(x), rhs, SubtractionIntervalOp);\n  },\n};\n\n/** Calculate an acceptance interval of reflect(x, y) */\nexport function reflectInterval(x: number[], y: number[]): F32Vector {\n  assert(\n    x.length === y.length,\n    `reflect is only defined for vectors with the same number of elements`\n  );\n  return runVectorPairToVectorOp(toF32Vector(x), toF32Vector(y), ReflectIntervalOp);\n}\n\n/**\n * Calculate acceptance interval vectors of reflect(i, s, r)\n *\n * refract is a singular function in the sense that it is the only builtin that\n * takes in (F32Vector, F32Vector, F32) and returns F32Vector and is basically\n * defined in terms of other functions.\n *\n * Instead of implementing all of the framework code to integrate it with its\n * own operation type/etc, it instead has a bespoke implementation that is a\n * composition of other builtin functions that use the framework.\n */\nexport function refractInterval(i: number[], s: number[], r: number): F32Vector {\n  assert(\n    i.length === s.length,\n    `refract is only defined for vectors with the same number of elements`\n  );\n\n  const r_squared = multiplicationInterval(r, r);\n  const dot = dotInterval(s, i);\n  const dot_squared = multiplicationInterval(dot, dot);\n  const one_minus_dot_squared = subtractionInterval(1, dot_squared);\n  const k = subtractionInterval(1.0, multiplicationInterval(r_squared, one_minus_dot_squared));\n\n  if (!k.isFinite() || k.containsZeroOrSubnormals()) {\n    // There is a discontinuity at k == 0, due to sqrt(k) being calculated, so exiting early\n    return kAnyVector[toF32Vector(i).length];\n  }\n\n  if (k.end < 0.0) {\n    // if k is negative, then the zero vector is the valid response\n    return kZeroVector[toF32Vector(i).length];\n  }\n\n  const dot_times_r = multiplicationInterval(dot, r);\n  const k_sqrt = sqrtInterval(k);\n  const t = additionInterval(dot_times_r, k_sqrt); // t = r * dot(i, s) + sqrt(k)\n\n  const result = runBinaryToIntervalOpVectorComponentWise(\n    multiplyVectorByScalar(i, r),\n    multiplyVectorByScalar(s, t),\n    SubtractionIntervalOp\n  ); // (i * r) - (s * t)\n  return result;\n}\n\nconst RemainderIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    // x % y = x - y * trunc(x/y)\n    return subtractionInterval(x, multiplicationInterval(y, truncInterval(divisionInterval(x, y))));\n  },\n};\n\n/** Calculate an acceptance interval for x % y */\nexport function remainderInterval(x: number, y: number): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), RemainderIntervalOp);\n}\n\nconst RoundIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    const k = Math.floor(n);\n    const diff_before = n - k;\n    const diff_after = k + 1 - n;\n    if (diff_before < diff_after) {\n      return correctlyRoundedInterval(k);\n    } else if (diff_before > diff_after) {\n      return correctlyRoundedInterval(k + 1);\n    }\n\n    // n is in the middle of two integers.\n    // The tie breaking rule is 'k if k is even, k + 1 if k is odd'\n    if (k % 2 === 0) {\n      return correctlyRoundedInterval(k);\n    }\n    return correctlyRoundedInterval(k + 1);\n  },\n};\n\n/** Calculate an acceptance interval of round(x) */\nexport function roundInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), RoundIntervalOp);\n}\n\n/**\n * Calculate an acceptance interval of saturate(n) as clamp(n, 0.0, 1.0)\n *\n * The definition of saturate does not specify which version of clamp to use.\n * Using min-max here, since it has wider acceptance intervals, that include\n * all of median's.\n */\nexport function saturateInterval(n: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(n),\n    toF32Interval(0.0),\n    toF32Interval(1.0),\n    ClampMinMaxIntervalOp\n  );\n}\n\nconst SignIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    if (n > 0.0) {\n      return correctlyRoundedInterval(1.0);\n    }\n    if (n < 0.0) {\n      return correctlyRoundedInterval(-1.0);\n    }\n\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function signInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SignIntervalOp);\n}\n\nconst SinIntervalOp: PointToIntervalOp = {\n  impl: limitPointToIntervalDomain(\n    kNegPiToPiInterval,\n    (n: number): F32Interval => {\n      return absoluteErrorInterval(Math.sin(n), 2 ** -11);\n    }\n  ),\n};\n\n/** Calculate an acceptance interval of sin(x) */\nexport function sinInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SinIntervalOp);\n}\n\nconst SinhIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    // sinh(x) = (exp(x) - exp(-x)) * 0.5\n    const minus_n = negationInterval(n);\n    return multiplicationInterval(subtractionInterval(expInterval(n), expInterval(minus_n)), 0.5);\n  },\n};\n\n/** Calculate an acceptance interval of sinh(x) */\nexport function sinhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SinhIntervalOp);\n}\n\nconst SmoothStepOp: TernaryToIntervalOp = {\n  impl: (low: number, high: number, x: number): F32Interval => {\n    // For clamp(foo, 0.0, 1.0) the different implementations of clamp provide\n    // the same value, so arbitrarily picking the minmax version to use.\n    // t = clamp((x - low) / (high - low), 0.0, 1.0)\n    // prettier-ignore\n    const t = clampMedianInterval(\n      divisionInterval(\n        subtractionInterval(x, low),\n        subtractionInterval(high, low)),\n      0.0,\n      1.0);\n    // Inherited from t * t * (3.0 - 2.0 * t)\n    // prettier-ignore\n    return multiplicationInterval(\n      t,\n      multiplicationInterval(t,\n        subtractionInterval(3.0,\n          multiplicationInterval(2.0, t))));\n  },\n};\n\n/** Calculate an acceptance interval of smoothStep(low, high, x) */\nexport function smoothStepInterval(low: number, high: number, x: number): F32Interval {\n  return runTernaryToIntervalOp(\n    toF32Interval(low),\n    toF32Interval(high),\n    toF32Interval(x),\n    SmoothStepOp\n  );\n}\n\nconst SqrtIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(1.0, inverseSqrtInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of sqrt(x) */\nexport function sqrtInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), SqrtIntervalOp);\n}\n\nconst StepIntervalOp: BinaryToIntervalOp = {\n  impl: (edge: number, x: number): F32Interval => {\n    if (edge <= x) {\n      return correctlyRoundedInterval(1.0);\n    }\n    return correctlyRoundedInterval(0.0);\n  },\n};\n\n/** Calculate an acceptance 'interval' for step(edge, x)\n *\n * step only returns two possible values, so its interval requires special\n * interpretation in CTS tests.\n * This interval will be one of four values: [0, 0], [0, 1], [1, 1] & [-∞, +∞].\n * [0, 0] and [1, 1] indicate that the correct answer in point they encapsulate.\n * [0, 1] should not be treated as a span, i.e. 0.1 is acceptable, but instead\n * indicate either 0.0 or 1.0 are acceptable answers.\n * [-∞, +∞] is treated as the any interval, since an undefined or infinite value was passed in.\n */\nexport function stepInterval(edge: number, x: number): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(edge), toF32Interval(x), StepIntervalOp);\n}\n\nconst SubtractionIntervalOp: BinaryToIntervalOp = {\n  impl: (x: number, y: number): F32Interval => {\n    return correctlyRoundedInterval(x - y);\n  },\n};\n\n/** Calculate an acceptance interval of x - y */\nexport function subtractionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  return runBinaryToIntervalOp(toF32Interval(x), toF32Interval(y), SubtractionIntervalOp);\n}\n\n/** Calculate an acceptance interval of x - y, when x and y are matrices */\nexport function subtractionMatrixInterval(x: Matrix<number>, y: Matrix<number>): F32Matrix {\n  return runBinaryToIntervalOpMatrixComponentWise(\n    toF32Matrix(x),\n    toF32Matrix(y),\n    SubtractionIntervalOp\n  );\n}\n\nconst TanIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinInterval(n), cosInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tan(x) */\nexport function tanInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), TanIntervalOp);\n}\n\nconst TanhIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return divisionInterval(sinhInterval(n), coshInterval(n));\n  },\n};\n\n/** Calculate an acceptance interval of tanh(x) */\nexport function tanhInterval(n: number): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), TanhIntervalOp);\n}\n\nconst TransposeIntervalOp: MatrixToMatrixOp = {\n  impl: (m: Matrix<number>): F32Matrix => {\n    const num_cols = m.length;\n    const num_rows = m[0].length;\n    const result: Matrix<F32Interval> = [...Array(num_rows)].map(_ => [...Array(num_cols)]);\n\n    for (let i = 0; i < num_cols; i++) {\n      for (let j = 0; j < num_rows; j++) {\n        result[j][i] = correctlyRoundedInterval(m[i][j]);\n      }\n    }\n    return toF32Matrix(result);\n  },\n};\n\n/** Calculate an acceptance interval of transpose(m) */\nexport function transposeInterval(m: number[][]): F32Matrix {\n  return runMatrixToMatrixOp(toF32Matrix(m), TransposeIntervalOp);\n}\n\nconst TruncIntervalOp: PointToIntervalOp = {\n  impl: (n: number): F32Interval => {\n    return correctlyRoundedInterval(Math.trunc(n));\n  },\n};\n\n/** Calculate an acceptance interval of trunc(x) */\nexport function truncInterval(n: number | F32Interval): F32Interval {\n  return runPointToIntervalOp(toF32Interval(n), TruncIntervalOp);\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when converting between numeric formats\n *\n * unpackData* is shared between all of the unpack*Interval functions, so to avoid re-entrancy problems, they should\n * not call each other or themselves directly or indirectly.\n */\nconst unpackData = new ArrayBuffer(4);\nconst unpackDataU32 = new Uint32Array(unpackData);\nconst unpackDataU16 = new Uint16Array(unpackData);\nconst unpackDataU8 = new Uint8Array(unpackData);\nconst unpackDataI16 = new Int16Array(unpackData);\nconst unpackDataI8 = new Int8Array(unpackData);\nconst unpackDataF16 = new Float16Array(unpackData);\n\n/** Calculate an acceptance interval vector for unpack2x16float(x) */\nexport function unpack2x16floatInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack2x16floatInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  if (unpackDataF16.some(f => !isFiniteF16(f))) {\n    return [F32Interval.any(), F32Interval.any()];\n  }\n\n  const result: F32Vector = [\n    quantizeToF16Interval(unpackDataF16[0]),\n    quantizeToF16Interval(unpackDataF16[1]),\n  ];\n\n  if (result.some(r => !r.isFinite())) {\n    return [F32Interval.any(), F32Interval.any()];\n  }\n  return result;\n}\n\nconst Unpack2x16snormIntervalOp = (n: number): F32Interval => {\n  return maxInterval(divisionInterval(n, 32767), -1);\n};\n\n/** Calculate an acceptance interval vector for unpack2x16snorm(x) */\nexport function unpack2x16snormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack2x16snormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [Unpack2x16snormIntervalOp(unpackDataI16[0]), Unpack2x16snormIntervalOp(unpackDataI16[1])];\n}\n\nconst Unpack2x16unormIntervalOp = (n: number): F32Interval => {\n  return divisionInterval(n, 65535);\n};\n\n/** Calculate an acceptance interval vector for unpack2x16unorm(x) */\nexport function unpack2x16unormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack2x16unormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [Unpack2x16unormIntervalOp(unpackDataU16[0]), Unpack2x16unormIntervalOp(unpackDataU16[1])];\n}\n\nconst Unpack4x8snormIntervalOp = (n: number): F32Interval => {\n  return maxInterval(divisionInterval(n, 127), -1);\n};\n\n/** Calculate an acceptance interval vector for unpack4x8snorm(x) */\nexport function unpack4x8snormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack4x8snormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [\n    Unpack4x8snormIntervalOp(unpackDataI8[0]),\n    Unpack4x8snormIntervalOp(unpackDataI8[1]),\n    Unpack4x8snormIntervalOp(unpackDataI8[2]),\n    Unpack4x8snormIntervalOp(unpackDataI8[3]),\n  ];\n}\n\nconst Unpack4x8unormIntervalOp = (n: number): F32Interval => {\n  return divisionInterval(n, 255);\n};\n\n/** Calculate an acceptance interval vector for unpack4x8unorm(x) */\nexport function unpack4x8unormInterval(n: number): F32Vector {\n  assert(\n    n >= kValue.u32.min && n <= kValue.u32.max,\n    'unpack4x8unormInterval only accepts values on the bounds of u32'\n  );\n  unpackDataU32[0] = n;\n  return [\n    Unpack4x8unormIntervalOp(unpackDataU8[0]),\n    Unpack4x8unormIntervalOp(unpackDataU8[1]),\n    Unpack4x8unormIntervalOp(unpackDataU8[2]),\n    Unpack4x8unormIntervalOp(unpackDataU8[3]),\n  ];\n}\n"],"mappings":"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"}