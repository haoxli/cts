{"version":3,"file":"texture_utils.js","names":["keysOf","assert","range","unreachable","isCompressedTextureFormat","kEncodableTextureFormats","kTextureFormatInfo","GPUTest","float32ToUint32","align","clamp","dotProduct","hashU32","lcm","lerp","quantizeToF32","effectiveViewDimensionForDimension","physicalMipSizeFromTexture","virtualMipSize","kTexelRepresentationInfo","TexelView","createTextureFromTexelViews","reifyExtent3D","kSampleTypeInfo","f32","format","i32","u32","WGSLTextureQueryTest","executeAndExpectResult","code","view","expected","device","module","createShaderModule","pipeline","createComputePipeline","layout","compute","resultBuffer","createBufferTracked","size","usage","GPUBufferUsage","STORAGE","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","e","Uint32Array","set","expectGPUBufferValuesEqual","getLimitValue","v","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getValueBetweenMinAndMaxTexelValueInclusive","rep","normalized","numericRange","min","max","getTexelViewFormatForTextureFormat","endsWith","createRandomTexelView","info","generator","coords","texel","component","componentOrder","rnd","x","y","z","charCodeAt","quantize","fromTexelsAsColors","createRandomTexelViewMipmap","mipLevelCount","dimension","i","kTextureCallArgNames","toArray","Array","repl","bitsToNumber","unpackBits","Uint8Array","pack","encode","apply","a","b","op","length","map","getUnusedCubeCornerSampleIndex","textureSize","u","add","softwareTextureReadMipLevel","call","texture","sampler","mipLevel","texels","descriptor","addressMode","addressModeU","addressModeV","addressModeW","load","at","color","Math","floor","isCube","viewDescriptor","builtin","convertCubeCoordToNormalized3DTextureCoord","offset","undefined","samples","filter","minFilter","p0","p1","p1W","p0W","push","weight","ndx","p","w","round","out","ss","sample","c","wrapFaceCoordToCubeFaceAtEdgeBoundaries","applyAddressModesToCoords","softwareTextureRead","ddx","ddy","texSize","width","height","scaledDdx","scaledDdy","dotDDX","dotDDY","deltaMax","log2","maxLevel","mipmapFilter","clampedMipLevel","baseMipLevel","nextMipLevel","ceil","t0","t1","mix","values","checkCallResults","t","textureType","calls","results","errs","maxFractionalDiff","getMaxFractionalDiffForTextureFormat","callIdx","got","expect","gULP","bitsToULPFromZero","numberToBits","eULP","g","absDiff","abs","ulpDiff","relDiff","desc","describeTextureCall","toFixed","expectedSamplePoints","identifySamplePoints","Promise","resolve","gotSamplePoints","gpuTexture","result","doTextureCalls","destroy","layoutTwoColumns","join","Error","softwareRasterize","targetSize","options","uvwStart","screenSpaceUMult","screenSpaceVMult","expData","Float32Array","fragY","fragX","coordType","rgba","R","G","B","A","asRgba32Float","fromTextureDataByReference","bytesPerRow","rowsPerImage","subrectOrigin","subrectSize","drawTexture","samplerDesc","renderTarget","createTextureTracked","GPUTextureUsage","RENDER_ATTACHMENT","uMult","vMult","offsetWGSL","shaderModule","createRenderPipeline","vertex","fragment","targets","primitive","topology","createSampler","createView","renderPass","beginRenderPass","colorAttachments","loadOp","storeOp","draw","includes","checkTextureMatchesExpectedTexelView","actualTexture","expectedTexelView","expectTexelViewComparisonIsOkInTexture","putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer","createTextureWithRandomDataAndGetTexels","sumOfCharCodesOfString","s","String","split","reduce","sum","makeAstcBlockFiller","bytesPerBlock","bytes","data","hashBase","makeRandomBytesBlockFiller","getBlockFiller","startsWith","fillTextureWithRandomData","depthOrArrayLayers","fillBlock","blocksAcross","blockWidth","blocksDown","blockHeight","bytesNeeded","writeTexture","s_readTextureToRGBA32DeviceToPipeline","WeakMap","getEffectiveViewDimension","textureBindingViewDimension","readTextureToTexelViews","viewDimensionToPipelineMap","get","Map","viewDimension","textureWGSL","loadWGSL","readBuffers","uniformValues","uniformBuffer","byteLength","UNIFORM","COPY_DST","writeBuffer","storageBuffer","readBuffer","MAP_READ","copyBufferToBuffer","texelViews","mapAsync","GPUMapMode","READ","getMappedRange","slice","unmap","coord","kFaceNames","run","numTexels","texelsPerRow","texelsPerSlice","sampledTexelWeights","unclassifiedStack","Set","unclassified","pop","setA","setB","keys","forEach","isCandidate","has","some","letter","idx","fromCharCode","orderedTexelIndices","lines","line","toString","padEnd","texelIdx","pad2","n","padStart","weights","columnA","columnB","widthA","l","repeat","chooseTextureSize","minSize","minBlocks","kSamplePointMethods","kCubeSamplePointMethods","generateSamplePointsImpl","makeValue","nearest","args","method","textureWidth","textureHeight","textureDepthOrArrayLayers","r","radius","loops","f","PI","cos","sin","kSubdivisionsPerTexel","q","v1","v2","generateSamplePoints1D","generateSamplePoints2D","generateSamplePoints3D","kFaceUVMatrices","transformMat3","m","normalize","sqrt","uvw","layer","absR","negX","negY","negZ","convertNormalized3DTexCoordToCubeCoord","uvLayer","faceLayer","kFaceConversions","faceCoord","u+t","u-t","v+t","v-t","t-v","1+u","1+v","-v-1","t-u-1","t-v-1","2t-u-1","2t-v-1","kFaceConversionEnums","kFaceToFaceRemap","to","getFaceWrapIndex","applyFaceWrap","generateSamplePointsCube","face","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","halfTexel","quantizedUVW","wgslTypeFor","type","isArray","wgslExpr","binKey","name","value","buildBinnedCalls","fields","prototype","bitcastToU32","expr","binCalls","bins","key","binIdx","s_deviceToPipelines","structs","body","dataFields","callCount","binned","dataBuffer","rtWidth","pipelines","gpuSampler","copyTextureToBuffer","outIdx","bin"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.ts"],"sourcesContent":["import { keysOf } from '../../../../../../common/util/data_tables.js';\nimport { assert, range, unreachable } from '../../../../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  isCompressedTextureFormat,\n  kEncodableTextureFormats,\n  kTextureFormatInfo,\n} from '../../../../../format_info.js';\nimport { GPUTest, TextureTestMixinType } from '../../../../../gpu_test.js';\nimport { float32ToUint32 } from '../../../../../util/conversion.js';\nimport {\n  align,\n  clamp,\n  dotProduct,\n  hashU32,\n  lcm,\n  lerp,\n  quantizeToF32,\n} from '../../../../../util/math.js';\nimport {\n  effectiveViewDimensionForDimension,\n  physicalMipSizeFromTexture,\n  virtualMipSize,\n} from '../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n  PerTexelComponent,\n  TexelRepresentationInfo,\n} from '../../../../../util/texture/texel_data.js';\nimport { TexelView } from '../../../../../util/texture/texel_view.js';\nimport { createTextureFromTexelViews } from '../../../../../util/texture.js';\nimport { reifyExtent3D } from '../../../../../util/unions.js';\n\nexport type SampledType = 'f32' | 'i32' | 'u32';\n\nexport const kSampleTypeInfo = {\n  f32: {\n    format: 'rgba8unorm',\n  },\n  i32: {\n    format: 'rgba32sint',\n  },\n  u32: {\n    format: 'rgba32uint',\n  },\n} as const;\n\n/**\n * Used for textureDimension, textureNumLevels, textureNumLayers\n */\nexport class WGSLTextureQueryTest extends GPUTest {\n  executeAndExpectResult(code: string, view: GPUTextureView, expected: number[]) {\n    const { device } = this;\n    const module = device.createShaderModule({ code });\n    const pipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module,\n      },\n    });\n\n    const resultBuffer = this.createBufferTracked({\n      size: 16,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: view },\n        { binding: 1, resource: { buffer: resultBuffer } },\n      ],\n    });\n\n    const encoder = device.createCommandEncoder();\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(1);\n    pass.end();\n    device.queue.submit([encoder.finish()]);\n\n    const e = new Uint32Array(4);\n    e.set(expected);\n    this.expectGPUBufferValuesEqual(resultBuffer, e);\n  }\n}\n\nfunction getLimitValue(v: number) {\n  switch (v) {\n    case Number.POSITIVE_INFINITY:\n      return 1000;\n    case Number.NEGATIVE_INFINITY:\n      return -1000;\n    default:\n      return v;\n  }\n}\n\nfunction getValueBetweenMinAndMaxTexelValueInclusive(\n  rep: TexelRepresentationInfo,\n  normalized: number\n) {\n  return lerp(\n    getLimitValue(rep.numericRange!.min),\n    getLimitValue(rep.numericRange!.max),\n    normalized\n  );\n}\n\n/**\n * We need the software rendering to do the same interpolation as the hardware\n * rendered so for -srgb formats we set the TexelView to an -srgb format as\n * TexelView handles this case. Note: It might be nice to add rgba32float-srgb\n * or something similar to TexelView.\n */\nexport function getTexelViewFormatForTextureFormat(format: GPUTextureFormat) {\n  return format.endsWith('-srgb') ? 'rgba8unorm-srgb' : 'rgba32float';\n}\n\n/**\n * Creates a TexelView filled with random values.\n */\nexport function createRandomTexelView(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n}): TexelView {\n  const rep = kTexelRepresentationInfo[info.format as EncodableTextureFormat];\n  const generator = (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n    const texel: PerTexelComponent<number> = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(coords.x, coords.y, coords.z, component.charCodeAt(0));\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      texel[component] = getValueBetweenMinAndMaxTexelValueInclusive(rep, normalized);\n    }\n    return quantize(texel, rep);\n  };\n  return TexelView.fromTexelsAsColors(info.format as EncodableTextureFormat, generator);\n}\n\n/**\n * Creates a mip chain of TexelViews filled with random values\n */\nexport function createRandomTexelViewMipmap(info: {\n  format: GPUTextureFormat;\n  size: GPUExtent3D;\n  mipLevelCount?: number;\n  dimension?: GPUTextureDimension;\n}): TexelView[] {\n  const mipLevelCount = info.mipLevelCount ?? 1;\n  const dimension = info.dimension ?? '2d';\n  return range(mipLevelCount, i =>\n    createRandomTexelView({\n      format: info.format,\n      size: virtualMipSize(dimension, info.size, i),\n    })\n  );\n}\n\nexport type vec1 = [number]; // Because it's easy to deal with if these types are all array of number\nexport type vec2 = [number, number];\nexport type vec3 = [number, number, number];\nexport type vec4 = [number, number, number, number];\nexport type Dimensionality = vec1 | vec2 | vec3;\n\ntype TextureCallArgKeys = keyof TextureCallArgs<vec1>;\nconst kTextureCallArgNames: TextureCallArgKeys[] = [\n  'coords',\n  'mipLevel',\n  'arrayIndex',\n  'ddx',\n  'ddy',\n  'offset',\n];\n\nexport interface TextureCallArgs<T extends Dimensionality> {\n  coords?: T;\n  mipLevel?: number;\n  arrayIndex?: number;\n  ddx?: T;\n  ddy?: T;\n  offset?: T;\n}\n\nexport interface TextureCall<T extends Dimensionality> extends TextureCallArgs<T> {\n  builtin: 'textureSample' | 'textureLoad';\n  coordType: 'f';\n}\n\nfunction toArray(coords: Dimensionality): number[] {\n  if (coords instanceof Array) {\n    return coords;\n  }\n  return [coords];\n}\n\nfunction quantize(texel: PerTexelComponent<number>, repl: TexelRepresentationInfo) {\n  return repl.bitsToNumber(repl.unpackBits(new Uint8Array(repl.pack(repl.encode(texel)))));\n}\n\nfunction apply(a: number[], b: number[], op: (x: number, y: number) => number) {\n  assert(a.length === b.length, `apply(${a}, ${b}): arrays must have same length`);\n  return a.map((v, i) => op(v, b[i]));\n}\n\n/**\n * At the corner of a cubemap we need to sample just 3 texels, not 4.\n * The texels are in\n *\n *   0:  (u,v)\n *   1:  (u + 1, v)\n *   2:  (u, v + 1)\n *   3:  (u + 1, v + 1)\n *\n * We pass in the original 2d (converted from cubemap) texture coordinate.\n * If it's within half a pixel of the edge in both directions then it's\n * a corner so we return the index of the one texel that's not needed.\n * Otherwise we return -1.\n */\nfunction getUnusedCubeCornerSampleIndex(textureSize: number, coords: vec3) {\n  const u = coords[0] * textureSize;\n  const v = coords[1] * textureSize;\n  if (v < 0.5) {\n    if (u < 0.5) {\n      return 0;\n    } else if (u >= textureSize - 0.5) {\n      return 1;\n    }\n  } else if (v >= textureSize - 0.5) {\n    if (u < 0.5) {\n      return 2;\n    } else if (u >= textureSize - 0.5) {\n      return 3;\n    }\n  }\n  return -1;\n}\n\nconst add = (a: number[], b: number[]) => apply(a, b, (x, y) => x + y);\n\nexport interface Texture {\n  texels: TexelView[];\n  descriptor: GPUTextureDescriptor;\n  viewDescriptor: GPUTextureViewDescriptor;\n}\n\n/**\n * Returns the expect value for a WGSL builtin texture function for a single\n * mip level\n */\nexport function softwareTextureReadMipLevel<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  mipLevel: number\n): PerTexelComponent<number> {\n  const rep = kTexelRepresentationInfo[texture.texels[mipLevel].format];\n  const textureSize = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    texture.descriptor.size,\n    mipLevel\n  );\n  const addressMode = [\n    sampler.addressModeU ?? 'clamp-to-edge',\n    sampler.addressModeV ?? 'clamp-to-edge',\n    sampler.addressModeW ?? 'clamp-to-edge',\n  ];\n\n  const load = (at: number[]) =>\n    texture.texels[mipLevel].color({\n      x: Math.floor(at[0]),\n      y: Math.floor(at[1] ?? 0),\n      z: Math.floor(at[2] ?? 0),\n    });\n\n  const isCube = texture.viewDescriptor.dimension === 'cube';\n\n  switch (call.builtin) {\n    case 'textureSample': {\n      let coords = toArray(call.coords!);\n\n      if (isCube) {\n        coords = convertCubeCoordToNormalized3DTextureCoord(coords as vec3);\n      }\n\n      // convert normalized to absolute texel coordinate\n      // ┌───┬───┬───┬───┐\n      // │ a │   │   │   │  norm: a = 1/8, b = 7/8\n      // ├───┼───┼───┼───┤   abs: a = 0,   b = 3\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │   │\n      // ├───┼───┼───┼───┤\n      // │   │   │   │ b │\n      // └───┴───┴───┴───┘\n      let at = coords.map((v, i) => v * textureSize[i] - 0.5);\n\n      // Apply offset in whole texel units\n      // This means the offset is added at each mip level in texels. There's no\n      // scaling for each level.\n      if (call.offset !== undefined) {\n        at = add(at, toArray(call.offset));\n      }\n\n      const samples: { at: number[]; weight: number }[] = [];\n\n      const filter = sampler.minFilter;\n      switch (filter) {\n        case 'linear': {\n          // 'p0' is the lower texel for 'at'\n          const p0 = at.map(v => Math.floor(v));\n          // 'p1' is the higher texel for 'at'\n          // If it's cube then don't advance Z.\n          const p1 = p0.map((v, i) => v + (isCube ? (i === 2 ? 0 : 1) : 1));\n\n          // interpolation weights for p0 and p1\n          const p1W = at.map((v, i) => v - p0[i]);\n          const p0W = p1W.map(v => 1 - v);\n\n          switch (coords.length) {\n            case 1:\n              samples.push({ at: p0, weight: p0W[0] });\n              samples.push({ at: p1, weight: p1W[0] });\n              break;\n            case 2: {\n              samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n              samples.push({ at: [p1[0], p0[1]], weight: p1W[0] * p0W[1] });\n              samples.push({ at: [p0[0], p1[1]], weight: p0W[0] * p1W[1] });\n              samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n              break;\n            }\n            case 3: {\n              // cube sampling, here in the software renderer, is the same\n              // as 2d sampling. We'll sample at most 4 texels. The weights are\n              // the same as if it was just one plane. If the points fall outside\n              // the slice they'll be wrapped by wrapFaceCoordToCubeFaceAtEdgeBoundaries\n              // below.\n              if (isCube) {\n                samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n                samples.push({ at: [p1[0], p0[1], p0[2]], weight: p1W[0] * p0W[1] });\n                samples.push({ at: [p0[0], p1[1], p0[2]], weight: p0W[0] * p1W[1] });\n                samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n                const ndx = getUnusedCubeCornerSampleIndex(textureSize[0], coords as vec3);\n                if (ndx >= 0) {\n                  // # Issues with corners of cubemaps\n                  //\n                  // note: I tried multiple things here\n                  //\n                  // 1. distribute 1/3 of the weight of the removed sample to each of the remaining samples\n                  // 2. distribute 1/2 of the weight of the removed sample to the 2 samples that are not the \"main\" sample.\n                  // 3. normalize the weights of the remaining 3 samples.\n                  //\n                  // none of them matched the M1 in all cases. Checking the dEQP I found this comment\n                  //\n                  // > If any of samples is out of both edges, implementations can do pretty much anything according to spec.\n                  // https://github.com/KhronosGroup/VK-GL-CTS/blob/d2d6aa65607383bb29c8398fe6562c6b08b4de57/framework/common/tcuTexCompareVerifier.cpp#L882\n                  //\n                  // If I understand this correctly it matches the OpenGL ES 3.1 spec it says\n                  // it's implementation defined.\n                  //\n                  // > OpenGL ES 3.1 section 8.12.1 Seamless Cubemap Filtering\n                  // >\n                  // > -  If a texture sample location would lie in the texture\n                  // >    border in both u and v (in one of the corners of the\n                  // >    cube), there is no unique neighboring face from which to\n                  // >    extract one texel. The recommended method to generate this\n                  // >    texel is to average the values of the three available\n                  // >    samples. However, implementations are free to construct\n                  // >    this fourth texel in another way, so long as, when the\n                  // >    three available samples have the same value, this texel\n                  // >    also has that value.\n                  //\n                  // I'm not sure what \"average the values of the three available samples\"\n                  // means. To me that would be (a+b+c)/3 or in other words, set all the\n                  // weights to 0.33333 but that's not what the M1 is doing.\n                  unreachable('corners of cubemaps are not testable');\n                }\n              } else {\n                const p = [p0, p1];\n                const w = [p0W, p1W];\n                for (let z = 0; z < 2; ++z) {\n                  for (let y = 0; y < 2; ++y) {\n                    for (let x = 0; x < 2; ++x) {\n                      samples.push({\n                        at: [p[x][0], p[y][1], p[z][2]],\n                        weight: w[x][0] * w[y][1] * w[z][2],\n                      });\n                    }\n                  }\n                }\n              }\n              break;\n            }\n          }\n          break;\n        }\n        case 'nearest': {\n          const p = at.map(v => Math.round(quantizeToF32(v)));\n          samples.push({ at: p, weight: 1 });\n          break;\n        }\n        default:\n          unreachable();\n      }\n\n      const out: PerTexelComponent<number> = {};\n      const ss = [];\n      for (const sample of samples) {\n        const c = isCube\n          ? wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize[0], sample.at as vec3)\n          : applyAddressModesToCoords(addressMode, textureSize, sample.at);\n        const v = load(c);\n        ss.push(v);\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + v[component]! * sample.weight;\n        }\n      }\n\n      return out;\n    }\n    case 'textureLoad': {\n      return load(toArray(call.coords!));\n    }\n  }\n}\n\n/**\n * The software version of a texture builtin (eg: textureSample)\n * Note that this is not a complete implementation. Rather it's only\n * what's needed to generate the correct expected value for the tests.\n */\nexport function softwareTextureRead<T extends Dimensionality>(\n  call: TextureCall<T>,\n  texture: Texture,\n  sampler: GPUSamplerDescriptor\n): PerTexelComponent<number> {\n  assert(call.ddx !== undefined);\n  assert(call.ddy !== undefined);\n  const rep = kTexelRepresentationInfo[texture.texels[0].format];\n  const texSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = [texSize.width, texSize.height];\n\n  // ddx and ddy are the values that would be passed to textureSampleGrad\n  // If we're emulating textureSample then they're the computed derivatives\n  // such that if we passed them to textureSampleGrad they'd produce the\n  // same result.\n  const ddx: readonly number[] = typeof call.ddx === 'number' ? [call.ddx] : call.ddx;\n  const ddy: readonly number[] = typeof call.ddy === 'number' ? [call.ddy] : call.ddy;\n\n  // Compute the mip level the same way textureSampleGrad does\n  const scaledDdx = ddx.map((v, i) => v * textureSize[i]);\n  const scaledDdy = ddy.map((v, i) => v * textureSize[i]);\n  const dotDDX = dotProduct(scaledDdx, scaledDdx);\n  const dotDDY = dotProduct(scaledDdy, scaledDdy);\n  const deltaMax = Math.max(dotDDX, dotDDY);\n  // MAINTENANCE_TODO: handle texture view baseMipLevel and mipLevelCount?\n  const mipLevel = 0.5 * Math.log2(deltaMax);\n\n  const mipLevelCount = texture.texels.length;\n  const maxLevel = mipLevelCount - 1;\n\n  switch (sampler.mipmapFilter) {\n    case 'linear': {\n      const clampedMipLevel = clamp(mipLevel, { min: 0, max: maxLevel });\n      const baseMipLevel = Math.floor(clampedMipLevel);\n      const nextMipLevel = Math.ceil(clampedMipLevel);\n      const t0 = softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n      const t1 = softwareTextureReadMipLevel<T>(call, texture, sampler, nextMipLevel);\n      const mix = mipLevel % 1;\n      const values = [\n        { v: t0, weight: 1 - mix },\n        { v: t1, weight: mix },\n      ];\n      const out: PerTexelComponent<number> = {};\n      for (const { v, weight } of values) {\n        for (const component of rep.componentOrder) {\n          out[component] = (out[component] ?? 0) + v[component]! * weight;\n        }\n      }\n      return out;\n    }\n    default: {\n      const baseMipLevel = Math.floor(\n        clamp(mipLevel + 0.5, { min: 0, max: texture.texels.length - 1 })\n      );\n      return softwareTextureReadMipLevel<T>(call, texture, sampler, baseMipLevel);\n    }\n  }\n}\n\nexport type TextureTestOptions = {\n  ddx?: number; // the derivative we want at sample time\n  ddy?: number;\n  uvwStart?: readonly [number, number]; // the starting uv value (these are used make the coordinates negative as it uncovered issues on some hardware)\n  offset?: readonly [number, number]; // a constant offset\n};\n\n/**\n * Checks the result of each call matches the expected result.\n */\nexport async function checkCallResults<T extends Dimensionality>(\n  t: GPUTest,\n  texture: Texture,\n  textureType: string,\n  sampler: GPUSamplerDescriptor,\n  calls: TextureCall<T>[],\n  results: PerTexelComponent<number>[]\n) {\n  const errs: string[] = [];\n  const rep = kTexelRepresentationInfo[texture.texels[0].format];\n  const maxFractionalDiff = getMaxFractionalDiffForTextureFormat(texture.descriptor.format);\n  for (let callIdx = 0; callIdx < calls.length; callIdx++) {\n    const call = calls[callIdx];\n    const got = results[callIdx];\n    const expect = softwareTextureReadMipLevel(call, texture, sampler, 0);\n\n    const gULP = rep.bitsToULPFromZero(rep.numberToBits(got));\n    const eULP = rep.bitsToULPFromZero(rep.numberToBits(expect));\n    for (const component of rep.componentOrder) {\n      const g = got[component]!;\n      const e = expect[component]!;\n      const absDiff = Math.abs(g - e);\n      const ulpDiff = Math.abs(gULP[component]! - eULP[component]!);\n      const relDiff = absDiff / Math.max(Math.abs(g), Math.abs(e));\n      if (ulpDiff > 3 && absDiff > maxFractionalDiff) {\n        const desc = describeTextureCall(call);\n        errs.push(`component was not as expected:\n      call: ${desc}  // #${callIdx}\n component: ${component}\n       got: ${g}\n  expected: ${e}\n  abs diff: ${absDiff.toFixed(4)}\n  rel diff: ${(relDiff * 100).toFixed(2)}%\n  ulp diff: ${ulpDiff}\n  sample points:\n`);\n        const expectedSamplePoints = [\n          'expected:',\n          ...(await identifySamplePoints(texture, (texels: TexelView) => {\n            return Promise.resolve(\n              softwareTextureReadMipLevel(\n                call,\n                {\n                  texels: [texels],\n                  descriptor: texture.descriptor,\n                  viewDescriptor: texture.viewDescriptor,\n                },\n                sampler,\n                0\n              )\n            );\n          })),\n        ];\n        const gotSamplePoints = [\n          'got:',\n          ...(await identifySamplePoints(texture, async (texels: TexelView) => {\n            const gpuTexture = createTextureFromTexelViews(t, [texels], texture.descriptor);\n            const result = (\n              await doTextureCalls(t, gpuTexture, texture.viewDescriptor, textureType, sampler, [\n                call,\n              ])\n            )[0];\n            gpuTexture.destroy();\n            return result;\n          })),\n        ];\n        errs.push(layoutTwoColumns(expectedSamplePoints, gotSamplePoints).join('\\n'));\n        errs.push('', '');\n      }\n    }\n  }\n\n  return errs.length > 0 ? new Error(errs.join('\\n')) : undefined;\n}\n\n/**\n * \"Renders a quad\" to a TexelView with the given parameters,\n * sampling from the given Texture.\n */\nexport function softwareRasterize<T extends Dimensionality>(\n  texture: Texture,\n  sampler: GPUSamplerDescriptor,\n  targetSize: [number, number],\n  options: TextureTestOptions\n) {\n  const [width, height] = targetSize;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0] } = options;\n  const format = 'rgba32float';\n\n  const textureSize = reifyExtent3D(texture.descriptor.size);\n\n  // MAINTENANCE_TODO: Consider passing these in as a similar computation\n  // happens in putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer.\n  // The issue is there, the calculation is \"what do we need to multiply the unitQuad\n  // by to get the derivatives we want\". The calculation here is \"what coordinate\n  // will we get for a given frag coordinate\". It turns out to be the same calculation\n  // but needs rephrasing them so they are more obviously the same would help\n  // consolidate them into one calculation.\n  const screenSpaceUMult = (ddx * width) / textureSize.width;\n  const screenSpaceVMult = (ddy * height) / textureSize.height;\n\n  const rep = kTexelRepresentationInfo[format];\n\n  const expData = new Float32Array(width * height * 4);\n  for (let y = 0; y < height; ++y) {\n    const fragY = height - y - 1 + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const fragX = x + 0.5;\n      // This code calculates the same value that will be passed to\n      // `textureSample` in the fragment shader for a given frag coord (see the\n      // WGSL code which uses the same formula, but using interpolation). That\n      // shader renders a clip space quad and includes a inter-stage \"uv\"\n      // coordinates that start with a unit quad (0,0) to (1,1) and is\n      // multiplied by ddx,ddy and as added in uStart and vStart\n      //\n      // uv = unitQuad * vec2(ddx, ddy) + vec2(vStart, uStart);\n      //\n      // softwareTextureRead<T> simulates a single call to `textureSample` so\n      // here we're computing the `uv` value that will be passed for a\n      // particular fragment coordinate. fragX / width, fragY / height provides\n      // the unitQuad value.\n      //\n      // ddx and ddy in this case are the derivative values we want to test. We\n      // pass those into the softwareTextureRead<T> as they would normally be\n      // derived from the change in coord.\n      const coords = [\n        (fragX / width) * screenSpaceUMult + uvwStart[0],\n        (fragY / height) * screenSpaceVMult + uvwStart[1],\n      ] as T;\n      const call: TextureCall<T> = {\n        builtin: 'textureSample',\n        coordType: 'f',\n        coords,\n        ddx: [ddx / textureSize.width, 0] as T,\n        ddy: [0, ddy / textureSize.height] as T,\n        offset: options.offset as T,\n      };\n      const sample = softwareTextureRead<T>(call, texture, sampler);\n      const rgba = { R: 0, G: 0, B: 0, A: 1, ...sample };\n      const asRgba32Float = new Float32Array(rep.pack(rgba));\n      expData.set(asRgba32Float, (y * width + x) * 4);\n    }\n  }\n\n  return TexelView.fromTextureDataByReference(format, new Uint8Array(expData.buffer), {\n    bytesPerRow: width * 4 * 4,\n    rowsPerImage: height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: targetSize,\n  });\n}\n\n/**\n * Render textured quad to an rgba32float texture.\n */\nexport function drawTexture(\n  t: GPUTest & TextureTestMixinType,\n  texture: GPUTexture,\n  samplerDesc: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const device = t.device;\n  const { ddx = 1, ddy = 1, uvwStart = [0, 0, 0], offset } = options;\n\n  const format = 'rgba32float';\n  const renderTarget = t.createTextureTracked({\n    format,\n    size: [32, 32],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  // Compute the amount we need to multiply the unitQuad by get the\n  // derivatives we want.\n  const uMult = (ddx * renderTarget.width) / texture.width;\n  const vMult = (ddy * renderTarget.height) / texture.height;\n\n  const offsetWGSL = offset ? `, vec2i(${offset[0]},${offset[1]})` : '';\n\n  const code = `\nstruct InOut {\n  @builtin(position) pos: vec4f,\n  @location(0) uv: vec2f,\n};\n\n@vertex fn vs(@builtin(vertex_index) vertex_index : u32) -> InOut {\n  let positions = array(\n    vec2f(-1,  1), vec2f( 1,  1),\n    vec2f(-1, -1), vec2f( 1, -1),\n  );\n  let pos = positions[vertex_index];\n  return InOut(\n    vec4f(pos, 0, 1),\n    (pos * 0.5 + 0.5) * vec2f(${uMult}, ${vMult}) + vec2f(${uvwStart[0]}, ${uvwStart[1]}),\n  );\n}\n\n@group(0) @binding(0) var          T    : texture_2d<f32>;\n@group(0) @binding(1) var          S    : sampler;\n\n@fragment fn fs(v: InOut) -> @location(0) vec4f {\n  return textureSample(T, S, v.uv${offsetWGSL});\n}\n`;\n\n  const shaderModule = device.createShaderModule({ code });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module: shaderModule },\n    fragment: {\n      module: shaderModule,\n      targets: [{ format }],\n    },\n    primitive: { topology: 'triangle-strip' },\n  });\n\n  const sampler = device.createSampler(samplerDesc);\n\n  const bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: texture.createView() },\n      { binding: 1, resource: sampler },\n    ],\n  });\n\n  const encoder = device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{ view: renderTarget.createView(), loadOp: 'clear', storeOp: 'store' }],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  device.queue.submit([encoder.finish()]);\n\n  return renderTarget;\n}\n\nfunction getMaxFractionalDiffForTextureFormat(format: GPUTextureFormat) {\n  // Note: I'm not sure what we should do here. My assumption is, given texels\n  // have random values, the difference between 2 texels can be very large. In\n  // the current version, for a float texture they can be +/- 1000 difference.\n  // Sampling is very GPU dependent. So if one pixel gets a random value of\n  // -1000 and the neighboring pixel gets +1000 then any slight variation in how\n  // sampling is applied will generate a large difference when interpolating\n  // between -1000 and +1000.\n  //\n  // We could make some entry for every format but for now I just put the\n  // tolerances here based on format texture suffix.\n  //\n  // It's possible the math in the software rasterizer is just bad but the\n  // results certainly seem close.\n  //\n  // These tolerances started from the OpenGL ES dEQP tests.\n  // Those tests always render to an rgba8unorm texture. The shaders do effectively\n  //\n  //   result = textureSample(...) * scale + bias\n  //\n  // to get the results in a 0.0 to 1.0 range. After reading the values back they\n  // expand them to their original ranges with\n  //\n  //   value = (result - bias) / scale;\n  //\n  // Tolerances from dEQP\n  // --------------------\n  // 8unorm: 3.9 / 255\n  // 8snorm: 7.9 / 128\n  // 2unorm: 7.9 / 512\n  // ufloat: 156.249\n  //  float: 31.2498\n  //\n  // The numbers below have been set empirically to get the tests to pass on all\n  // devices. The devices with the most divergence from the calculated expected\n  // values are MacOS Intel and AMD.\n  //\n  // MAINTENANCE_TODO: Double check the software rendering math and lower these\n  // tolerances if possible.\n\n  if (format.includes('8unorm')) {\n    return 7 / 255;\n  } else if (format.includes('2unorm')) {\n    return 9 / 512;\n  } else if (format.includes('unorm')) {\n    return 7 / 255;\n  } else if (format.includes('8snorm')) {\n    return 7.9 / 128;\n  } else if (format.includes('snorm')) {\n    return 7.9 / 128;\n  } else if (format.endsWith('ufloat')) {\n    return 156.249;\n  } else if (format.endsWith('float')) {\n    return 44;\n  } else {\n    unreachable();\n  }\n}\n\nexport function checkTextureMatchesExpectedTexelView(\n  t: GPUTest & TextureTestMixinType,\n  format: GPUTextureFormat,\n  actualTexture: GPUTexture,\n  expectedTexelView: TexelView\n) {\n  const maxFractionalDiff = getMaxFractionalDiffForTextureFormat(format);\n  t.expectTexelViewComparisonIsOkInTexture(\n    { texture: actualTexture },\n    expectedTexelView,\n    [actualTexture.width, actualTexture.height],\n    { maxFractionalDiff }\n  );\n}\n\n/**\n * Puts data in a texture. Renders a quad to a rgba32float. Then \"software renders\"\n * to a TexelView the expected result and compares the rendered texture to the\n * expected TexelView.\n */\nexport async function putDataInTextureThenDrawAndCheckResultsComparedToSoftwareRasterizer<\n  T extends Dimensionality,\n>(\n  t: GPUTest & TextureTestMixinType,\n  descriptor: GPUTextureDescriptor,\n  viewDescriptor: GPUTextureViewDescriptor,\n  samplerDesc: GPUSamplerDescriptor,\n  options: TextureTestOptions\n) {\n  const { texture, texels } = await createTextureWithRandomDataAndGetTexels(t, descriptor);\n\n  const actualTexture = drawTexture(t, texture, samplerDesc, options);\n  const expectedTexelView = softwareRasterize<T>(\n    { descriptor, texels, viewDescriptor },\n    samplerDesc,\n    [actualTexture.width, actualTexture.height],\n    options\n  );\n\n  checkTextureMatchesExpectedTexelView(t, texture.format, actualTexture, expectedTexelView);\n}\n\nconst sumOfCharCodesOfString = (s: unknown) =>\n  String(s)\n    .split('')\n    .reduce((sum, c) => sum + c.charCodeAt(0), 0);\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random valid data\n * for an astc block.\n *\n * The astc format is fairly complicated. For now we do the simplest thing.\n * which is to set the block as a \"void-extent\" block (a solid color).\n * This makes our test have far less precision.\n *\n * MAINTENANCE_TODO: generate other types of astc blocks. One option would\n * be to randomly select from set of pre-made blocks.\n *\n * See Spec:\n * https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n */\nfunction makeAstcBlockFiller(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color!.bytes;\n  return (data: Uint8Array, offset: number, hashBase: number) => {\n    // set the block to be a void-extent block\n    data.set(\n      [\n        0b1111_1100, // 0\n        0b1111_1101, // 1\n        0b1111_1111, // 2\n        0b1111_1111, // 3\n        0b1111_1111, // 4\n        0b1111_1111, // 5\n        0b1111_1111, // 6\n        0b1111_1111, // 7\n      ],\n      offset\n    );\n    // fill the rest of the block with random data\n    const end = offset + bytesPerBlock;\n    for (let i = offset + 8; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random bytes.\n */\nfunction makeRandomBytesBlockFiller(format: GPUTextureFormat) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color!.bytes;\n  return (data: Uint8Array, offset: number, hashBase: number) => {\n    const end = offset + bytesPerBlock;\n    for (let i = offset; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\nfunction getBlockFiller(format: GPUTextureFormat) {\n  if (format.startsWith('astc')) {\n    return makeAstcBlockFiller(format);\n  } else {\n    return makeRandomBytesBlockFiller(format);\n  }\n}\n\n/**\n * Fills a texture with random data.\n */\nexport function fillTextureWithRandomData(device: GPUDevice, texture: GPUTexture) {\n  const info = kTextureFormatInfo[texture.format];\n  const hashBase =\n    sumOfCharCodesOfString(texture.format) +\n    sumOfCharCodesOfString(texture.dimension) +\n    texture.width +\n    texture.height +\n    texture.depthOrArrayLayers +\n    texture.mipLevelCount;\n  const bytesPerBlock = info.color!.bytes;\n  const fillBlock = getBlockFiller(texture.format);\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = physicalMipSizeFromTexture(texture, mipLevel);\n    const blocksAcross = Math.ceil(size[0] / info.blockWidth);\n    const blocksDown = Math.ceil(size[1] / info.blockHeight);\n    const bytesPerRow = blocksAcross * bytesPerBlock;\n    const bytesNeeded = bytesPerRow * blocksDown * size[2];\n    const data = new Uint8Array(bytesNeeded);\n    for (let offset = 0; offset < bytesNeeded; offset += bytesPerBlock) {\n      fillBlock(data, offset, hashBase);\n    }\n    device.queue.writeTexture(\n      { texture, mipLevel },\n      data,\n      { bytesPerRow, rowsPerImage: blocksDown },\n      size\n    );\n  }\n}\n\nconst s_readTextureToRGBA32DeviceToPipeline = new WeakMap<\n  GPUDevice,\n  Map<GPUTextureViewDimension, GPUComputePipeline>\n>();\n\n// MAINTENANCE_TODO: remove cast once textureBindingViewDimension is added to IDL\nfunction getEffectiveViewDimension(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor\n): GPUTextureViewDimension {\n  const { textureBindingViewDimension } = descriptor as unknown as {\n    textureBindingViewDimension?: GPUTextureViewDimension;\n  };\n  const size = reifyExtent3D(descriptor.size);\n  return effectiveViewDimensionForDimension(\n    textureBindingViewDimension,\n    descriptor.dimension,\n    size.depthOrArrayLayers\n  );\n}\n\nexport async function readTextureToTexelViews(\n  t: GPUTest,\n  texture: GPUTexture,\n  descriptor: GPUTextureDescriptor,\n  format: EncodableTextureFormat\n) {\n  const device = t.device;\n  const viewDimensionToPipelineMap =\n    s_readTextureToRGBA32DeviceToPipeline.get(device) ??\n    new Map<GPUTextureViewDimension, GPUComputePipeline>();\n  s_readTextureToRGBA32DeviceToPipeline.set(device, viewDimensionToPipelineMap);\n\n  const viewDimension = getEffectiveViewDimension(t, descriptor);\n  let pipeline = viewDimensionToPipelineMap.get(viewDimension);\n  if (!pipeline) {\n    let textureWGSL;\n    let loadWGSL;\n    switch (viewDimension) {\n      case '2d':\n        textureWGSL = 'texture_2d<f32>';\n        loadWGSL = 'textureLoad(tex, global_invocation_id.xy, mipLevel)';\n        break;\n      case 'cube-array': // cube-array doesn't exist in compat so we can just use 2d_array for this\n      case '2d-array':\n        textureWGSL = 'texture_2d_array<f32>';\n        loadWGSL = `\n          textureLoad(\n              tex,\n              global_invocation_id.xy,\n              global_invocation_id.z,\n              mipLevel)`;\n        break;\n      case '3d':\n        textureWGSL = 'texture_3d<f32>';\n        loadWGSL = 'textureLoad(tex, global_invocation_id.xyz, mipLevel)';\n        break;\n      case 'cube':\n        textureWGSL = 'texture_cube<f32>';\n        loadWGSL = `\n          textureLoadCubeAs2DArray(tex, global_invocation_id.xy, global_invocation_id.z, mipLevel);\n        `;\n        break;\n      default:\n        unreachable(`unsupported view: ${viewDimension}`);\n    }\n    const module = device.createShaderModule({\n      code: `\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        // needed for compat mode.\n        fn textureLoadCubeAs2DArray(tex: texture_cube<f32>, coord: vec2u, layer: u32, mipLevel: u32) -> vec4f {\n          // convert texel coord normalized coord\n          let size = textureDimensions(tex, mipLevel);\n          let uv = (vec2f(coord) + 0.5) / vec2f(size.xy);\n\n          // convert uv + layer into cube coord\n          let cubeCoord = faceMat[layer] * vec3f(uv, 1.0);\n\n          return textureSampleLevel(tex, smp, cubeCoord, f32(mipLevel));\n        }\n\n        @group(0) @binding(0) var<uniform> mipLevel: u32;\n        @group(0) @binding(1) var tex: ${textureWGSL};\n        @group(0) @binding(2) var smp: sampler;\n        @group(0) @binding(3) var<storage, read_write> data: array<vec4f>;\n\n        @compute @workgroup_size(1) fn cs(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n          _ = smp;\n          let size = textureDimensions(tex, mipLevel);\n          let ndx = global_invocation_id.z * size.x * size.y +\n                    global_invocation_id.y * size.x +\n                    global_invocation_id.x;\n          data[ndx] = ${loadWGSL};\n        }\n      `,\n    });\n    pipeline = device.createComputePipeline({ layout: 'auto', compute: { module } });\n    viewDimensionToPipelineMap.set(viewDimension, pipeline);\n  }\n\n  const encoder = device.createCommandEncoder();\n\n  const readBuffers = [];\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = virtualMipSize(texture.dimension, texture, mipLevel);\n\n    const uniformValues = new Uint32Array([mipLevel, 0, 0, 0]); // min size is 16 bytes\n    const uniformBuffer = t.createBufferTracked({\n      size: uniformValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);\n\n    const storageBuffer = t.createBufferTracked({\n      size: size[0] * size[1] * size[2] * 4 * 4, // rgba32float\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    const readBuffer = t.createBufferTracked({\n      size: storageBuffer.size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    readBuffers.push({ size, readBuffer });\n\n    const sampler = device.createSampler();\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        { binding: 0, resource: { buffer: uniformBuffer } },\n        { binding: 1, resource: texture.createView({ dimension: viewDimension }) },\n        { binding: 2, resource: sampler },\n        { binding: 3, resource: { buffer: storageBuffer } },\n      ],\n    });\n\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(...size);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, readBuffer.size);\n  }\n\n  device.queue.submit([encoder.finish()]);\n\n  const texelViews: TexelView[] = [];\n\n  for (const { readBuffer, size } of readBuffers) {\n    await readBuffer.mapAsync(GPUMapMode.READ);\n\n    // need a copy of the data since unmapping will nullify the typedarray view.\n    const data = new Float32Array(readBuffer.getMappedRange()).slice();\n    readBuffer.unmap();\n\n    texelViews.push(\n      TexelView.fromTexelsAsColors(format, coord => {\n        const offset = (coord.z * size[0] * size[1] + coord.y * size[0] + coord.x) * 4;\n        return {\n          R: data[offset + 0],\n          G: data[offset + 1],\n          B: data[offset + 2],\n          A: data[offset + 3],\n        };\n      })\n    );\n  }\n\n  return texelViews;\n}\n\n/**\n * Fills a texture with random data and returns that data as\n * an array of TexelView.\n *\n * For compressed textures the texture is filled with random bytes\n * and then read back from the GPU by sampling so the GPU decompressed\n * the texture.\n *\n * For uncompressed textures the TexelViews are generated and then\n * copied to the texture.\n */\nexport async function createTextureWithRandomDataAndGetTexels(\n  t: GPUTest,\n  descriptor: GPUTextureDescriptor\n) {\n  if (isCompressedTextureFormat(descriptor.format)) {\n    const texture = t.createTextureTracked(descriptor);\n\n    fillTextureWithRandomData(t.device, texture);\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      descriptor,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    return { texture, texels };\n  } else {\n    const texels = createRandomTexelViewMipmap(descriptor);\n    const texture = createTextureFromTexelViews(t, texels, descriptor);\n    return { texture, texels };\n  }\n}\n\nconst kFaceNames = ['+x', '-x', '+y', '-y', '+z', '-z'] as const;\n\n/**\n * Generates a text art grid showing which texels were sampled\n * followed by a list of the samples and the weights used for each\n * component.\n *\n * It works by making an index for every pixel in the texture. Then,\n * for each index it generates texture data using TexelView.fromTexelsAsColor\n * with a single [1, 1, 1, 1] texel at the texel for the current index.\n *\n * In then calls 'run' which renders a single `call`. `run` uses either\n * the software renderer or WebGPU. The result ends up being the weights\n * used when sampling that pixel. 0 = that texel was not sampled. > 0 =\n * it was sampled.\n *\n * This lets you see if the weights from the software renderer match the\n * weights from WebGPU.\n *\n * Example:\n *\n *     0   1   2   3   4   5   6   7\n *   ┌───┬───┬───┬───┬───┬───┬───┬───┐\n * 0 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 1 │   │   │   │   │   │   │   │ a │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 2 │   │   │   │   │   │   │   │ b │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 3 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 4 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 5 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 6 │   │   │   │   │   │   │   │   │\n *   ├───┼───┼───┼───┼───┼───┼───┼───┤\n * 7 │   │   │   │   │   │   │   │   │\n *   └───┴───┴───┴───┴───┴───┴───┴───┘\n * a: at: [7, 1], weights: [R: 0.75000]\n * b: at: [7, 2], weights: [R: 0.25000]\n */\nasync function identifySamplePoints(\n  texture: Texture,\n  run: (texels: TexelView) => Promise<PerTexelComponent<number>>\n) {\n  const info = texture.descriptor;\n  const isCube = texture.viewDescriptor.dimension === 'cube';\n  const textureSize = reifyExtent3D(info.size);\n  const numTexels = textureSize.width * textureSize.height * textureSize.height;\n  const texelsPerRow = textureSize.width;\n  const texelsPerSlice = textureSize.width * textureSize.height;\n  // This isn't perfect. We already know there was an error. We're just\n  // generating info so it seems okay it's not perfect. This format will\n  // be used to generate weights by drawing with a texture of this format\n  // with a specific pixel set to [1, 1, 1, 1]. As such, if the result\n  // is > 0 then that pixel was sampled and the results are the weights.\n  //\n  // Ideally, this texture with a single pixel set to [1, 1, 1, 1] would\n  // be the same format we were originally testing, the one we already\n  // detected an error for. This way, whatever subtle issues there are\n  // from that format will affect the weight values we're computing. But,\n  // if that format is not encodable, for example if it's a compressed\n  // texture format, then we have no way to build a texture so we use\n  // rgba8unorm instead.\n  const format = (\n    kEncodableTextureFormats.includes(info.format as EncodableTextureFormat)\n      ? info.format\n      : 'rgba8unorm'\n  ) as EncodableTextureFormat;\n  const rep = kTexelRepresentationInfo[format];\n\n  // Identify all the texels that are sampled, and their weights.\n  const sampledTexelWeights = new Map<number, PerTexelComponent<number>>();\n  const unclassifiedStack = [new Set<number>(range(numTexels, v => v))];\n  while (unclassifiedStack.length > 0) {\n    // Pop the an unclassified texels stack\n    const unclassified = unclassifiedStack.pop()!;\n\n    // Split unclassified texels evenly into two new sets\n    const setA = new Set<number>();\n    const setB = new Set<number>();\n    [...unclassified.keys()].forEach((t, i) => ((i & 1) === 0 ? setA : setB).add(t));\n\n    // Push setB to the unclassified texels stack\n    if (setB.size > 0) {\n      unclassifiedStack.push(setB);\n    }\n\n    // See if any of the texels in setA were sampled.\n    const results = await run(\n      TexelView.fromTexelsAsColors(\n        format,\n        (coords: Required<GPUOrigin3DDict>): Readonly<PerTexelComponent<number>> => {\n          const isCandidate = setA.has(\n            coords.x + coords.y * texelsPerRow + coords.z * texelsPerSlice\n          );\n          const texel: PerTexelComponent<number> = {};\n          for (const component of rep.componentOrder) {\n            texel[component] = isCandidate ? 1 : 0;\n          }\n          return texel;\n        }\n      )\n    );\n    if (rep.componentOrder.some(c => results[c] !== 0)) {\n      // One or more texels of setA were sampled.\n      if (setA.size === 1) {\n        // We identified a specific texel was sampled.\n        // As there was only one texel in the set, results holds the sampling weights.\n        setA.forEach(texel => sampledTexelWeights.set(texel, results));\n      } else {\n        // More than one texel in the set. Needs splitting.\n        unclassifiedStack.push(setA);\n      }\n    }\n  }\n\n  // ┌───┬───┬───┬───┐\n  // │ a │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │   │\n  // ├───┼───┼───┼───┤\n  // │   │   │   │ b │\n  // └───┴───┴───┴───┘\n  const letter = (idx: number) => String.fromCharCode(97 + idx); // 97: 'a'\n  const orderedTexelIndices: number[] = [];\n  const lines: string[] = [];\n  for (let z = 0; z < textureSize.depthOrArrayLayers; ++z) {\n    lines.push(`slice: ${z}${isCube ? ` (${kFaceNames[z]})` : ''}`);\n    {\n      let line = '  ';\n      for (let x = 0; x < textureSize.width; x++) {\n        line += `  ${x.toString().padEnd(2)}`;\n      }\n      lines.push(line);\n    }\n    {\n      let line = '  ┌';\n      for (let x = 0; x < textureSize.width; x++) {\n        line += x === textureSize.width - 1 ? '───┐' : '───┬';\n      }\n      lines.push(line);\n    }\n    for (let y = 0; y < textureSize.height; y++) {\n      {\n        let line = `${y.toString().padEnd(2)}│`;\n        for (let x = 0; x < textureSize.width; x++) {\n          const texelIdx = x + y * texelsPerRow + z * texelsPerSlice;\n          const weight = sampledTexelWeights.get(texelIdx);\n          if (weight !== undefined) {\n            line += ` ${letter(orderedTexelIndices.length)} │`;\n            orderedTexelIndices.push(texelIdx);\n          } else {\n            line += '   │';\n          }\n        }\n        lines.push(line);\n      }\n      if (y < textureSize.height - 1) {\n        let line = '  ├';\n        for (let x = 0; x < textureSize.width; x++) {\n          line += x === textureSize.width - 1 ? '───┤' : '───┼';\n        }\n        lines.push(line);\n      }\n    }\n    {\n      let line = '  └';\n      for (let x = 0; x < textureSize.width; x++) {\n        line += x === textureSize.width - 1 ? '───┘' : '───┴';\n      }\n      lines.push(line);\n    }\n  }\n\n  const pad2 = (n: number) => n.toString().padStart(2);\n  orderedTexelIndices.forEach((texelIdx, i) => {\n    const weights = sampledTexelWeights.get(texelIdx)!;\n    const z = Math.floor(texelIdx / texelsPerSlice);\n    const y = Math.floor((texelIdx % texelsPerSlice) / texelsPerRow);\n    const x = texelIdx % texelsPerRow;\n    const w = rep.componentOrder.map(c => `${c}: ${weights[c]?.toFixed(5)}`).join(', ');\n    lines.push(`${letter(i)}: at: [${pad2(x)}, ${pad2(y)}, ${pad2(z)}], weights: [${w}]`);\n  });\n  return lines;\n}\n\nfunction layoutTwoColumns(columnA: string[], columnB: string[]) {\n  const widthA = Math.max(...columnA.map(l => l.length));\n  const lines = Math.max(columnA.length, columnB.length);\n  const out: string[] = new Array<string>(lines);\n  for (let line = 0; line < lines; line++) {\n    const a = columnA[line] ?? '';\n    const b = columnB[line] ?? '';\n    out[line] = `${a}${' '.repeat(widthA - a.length)} | ${b}`;\n  }\n  return out;\n}\n\n/**\n * Choose a texture size based on the given parameters.\n * The size will be in a multiple of blocks. If it's a cube\n * map the size will so be square.\n */\nexport function chooseTextureSize({\n  minSize,\n  minBlocks,\n  format,\n  viewDimension,\n}: {\n  minSize: number;\n  minBlocks: number;\n  format: GPUTextureFormat;\n  viewDimension?: GPUTextureViewDimension;\n}) {\n  const { blockWidth, blockHeight } = kTextureFormatInfo[format];\n  const width = align(Math.max(minSize, blockWidth * minBlocks), blockWidth);\n  const height = align(Math.max(minSize, blockHeight * minBlocks), blockHeight);\n  if (viewDimension === 'cube') {\n    const size = lcm(width, height);\n    return [size, size];\n  }\n  return [width, height];\n}\n\nexport const kSamplePointMethods = ['texel-centre', 'spiral'] as const;\nexport type SamplePointMethods = (typeof kSamplePointMethods)[number];\n\nexport const kCubeSamplePointMethods = ['cube-edges', 'texel-centre', 'spiral'] as const;\nexport type CubeSamplePointMethods = (typeof kSamplePointMethods)[number];\n\n/**\n * Generates an array of coordinates at which to sample a texture.\n */\nfunction generateSamplePointsImpl<T extends Dimensionality>(\n  makeValue: (x: number, y: number, z: number) => T,\n  n: number,\n  nearest: boolean,\n  args:\n    | {\n        method: 'texel-centre';\n        textureWidth: number;\n        textureHeight: number;\n        textureDepthOrArrayLayers?: number;\n      }\n    | {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n        textureWidth: number;\n        textureHeight: number;\n        textureDepthOrArrayLayers?: number;\n      }\n) {\n  const { method, textureWidth, textureHeight, textureDepthOrArrayLayers = 1 } = args;\n  const out: T[] = [];\n  switch (method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const x = Math.floor(lerp(0, textureWidth - 1, (r & 0xff) / 0xff)) + 0.5;\n        const y = Math.floor(lerp(0, textureHeight - 1, ((r >> 8) & 0xff) / 0xff)) + 0.5;\n        const z =\n          Math.floor(lerp(0, textureDepthOrArrayLayers - 1, ((r >> 16) & 0xff) / 0xff)) + 0.5;\n        out.push(makeValue(x / textureWidth, y / textureHeight, z / textureDepthOrArrayLayers));\n      }\n      break;\n    }\n    case 'spiral': {\n      const { radius = 1.5, loops = 2 } = args;\n      for (let i = 0; i < n; i++) {\n        const f = i / (Math.max(n, 2) - 1);\n        const r = radius * f;\n        const a = loops * 2 * Math.PI * f;\n        out.push(makeValue(0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a), 0));\n      }\n      break;\n    }\n  }\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n  const q = [\n    textureWidth * kSubdivisionsPerTexel,\n    textureHeight * kSubdivisionsPerTexel,\n    textureDepthOrArrayLayers * kSubdivisionsPerTexel,\n  ];\n  return out.map(\n    c =>\n      c.map((v, i) => {\n        // Quantize to kSubdivisionsPerPixel\n        const v1 = Math.floor(v * q[i]);\n        // If it's nearest and we're on the edge of a texel then move us off the edge\n        // since the edge could choose one texel or another in nearest mode\n        const v2 = nearest && v1 % kSubdivisionsPerTexel === 0 ? v1 + 1 : v1;\n        // Convert back to texture coords\n        return v2 / q[i];\n      }) as T\n  );\n}\n\n// Removes the first element from an array of types\ntype FilterFirstElement<T extends unknown[]> = T extends [unknown, ...infer R] ? R : [];\n\ntype GenerateSamplePointsImplArgs = FilterFirstElement<Parameters<typeof generateSamplePointsImpl>>;\n\nexport function generateSamplePoints1D(...args: GenerateSamplePointsImplArgs) {\n  return generateSamplePointsImpl<vec1>((x: number) => [x], ...args);\n}\n\nexport function generateSamplePoints2D(...args: GenerateSamplePointsImplArgs) {\n  return generateSamplePointsImpl<vec2>((x: number, y: number) => [x, y], ...args);\n}\n\nexport function generateSamplePoints3D(...args: GenerateSamplePointsImplArgs) {\n  return generateSamplePointsImpl<vec3>((x: number, y: number, z: number) => [x, y, z], ...args);\n}\n\ntype mat3 =\n  /* prettier-ignore */ [\n  number, number, number,\n  number, number, number,\n  number, number, number,\n];\n\nconst kFaceUVMatrices: mat3[] =\n  /* prettier-ignore */ [\n  [ 0,  0,  -2,  0, -2,   0,  1,  1,   1],   // pos-x\n  [ 0,  0,   2,  0, -2,   0, -1,  1,  -1],   // neg-x\n  [ 2,  0,   0,  0,  0,   2, -1,  1,  -1],   // pos-y\n  [ 2,  0,   0,  0,  0,  -2, -1, -1,   1],   // neg-y\n  [ 2,  0,   0,  0, -2,   0, -1,  1,   1],   // pos-z\n  [-2,  0,   0,  0, -2,   0,  1,  1,  -1],   // neg-z\n];\n\n/** multiply a vec3 by mat3 */\nfunction transformMat3(v: vec3, m: mat3): vec3 {\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n\n  return [\n    x * m[0] + y * m[3] + z * m[6],\n    x * m[1] + y * m[4] + z * m[7],\n    x * m[2] + y * m[5] + z * m[8],\n  ];\n}\n\n/** normalize a vec3 */\nfunction normalize(v: vec3): vec3 {\n  const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n  assert(length > 0);\n  return v.map(v => v / length) as vec3;\n}\n\n/**\n * Converts a cube map coordinate to a uv coordinate (0 to 1) and layer (0.5/6.0 to 5.5/6.0).\n * Also returns the length of the original coordinate.\n */\nfunction convertCubeCoordToNormalized3DTextureCoord(v: vec3): vec3 {\n  let uvw;\n  let layer;\n  // normalize the coord.\n  // MAINTENANCE_TODO: handle(0, 0, 0)\n  const r = normalize(v);\n  const absR = r.map(v => Math.abs(v));\n  if (absR[0] > absR[1] && absR[0] > absR[2]) {\n    // x major\n    const negX = r[0] < 0.0 ? 1 : 0;\n    uvw = [negX ? r[2] : -r[2], -r[1], absR[0]];\n    layer = negX;\n  } else if (absR[1] > absR[2]) {\n    // y major\n    const negY = r[1] < 0.0 ? 1 : 0;\n    uvw = [r[0], negY ? -r[2] : r[2], absR[1]];\n    layer = 2 + negY;\n  } else {\n    // z major\n    const negZ = r[2] < 0.0 ? 1 : 0;\n    uvw = [negZ ? -r[0] : r[0], -r[1], absR[2]];\n    layer = 4 + negZ;\n  }\n  return [(uvw[0] / uvw[2] + 1) * 0.5, (uvw[1] / uvw[2] + 1) * 0.5, (layer + 0.5) / 6];\n}\n\n/**\n * Convert a 3d texcoord into a cube map coordinate.\n */\nfunction convertNormalized3DTexCoordToCubeCoord(uvLayer: vec3) {\n  const [u, v, faceLayer] = uvLayer;\n  return normalize(transformMat3([u, v, 1], kFaceUVMatrices[Math.min(5, faceLayer * 6) | 0]));\n}\n\n/**\n * We have a face texture in texels coord where U/V choose a texel and W chooses the face.\n * If U/V are outside the size of the texture then, when normalized and converted\n * to a cube map coordinate, they'll end up pointing to a different face.\n *\n * addressMode is effectively ignored for cube\n *\n *             +-----------+\n *             |0->u       |\n *             |↓          |\n *             |v   +y     |\n *             |    (2)    |\n *             |           |\n * +-----------+-----------+-----------+-----------+\n * |0->u       |0->u       |0->u       |0->u       |\n * |↓          |↓          |↓          |↓          |\n * |v   -x     |v   +z     |v   +x     |v   -z     |\n * |    (1)    |    (4)    |    (0)    |    (5)    |\n * |           |           |           |           |\n * +-----------+-----------+-----------+-----------+\n *             |0->u       |\n *             |↓          |\n *             |v   -y     |\n *             |    (3)    |\n *             |           |\n *             +-----------+\n */\nconst kFaceConversions = {\n  u: (textureSize: number, faceCoord: vec3) => faceCoord[0],\n  v: (textureSize: number, faceCoord: vec3) => faceCoord[1],\n  'u+t': (textureSize: number, faceCoord: vec3) => faceCoord[0] + textureSize,\n  'u-t': (textureSize: number, faceCoord: vec3) => faceCoord[0] - textureSize,\n  'v+t': (textureSize: number, faceCoord: vec3) => faceCoord[1] + textureSize,\n  'v-t': (textureSize: number, faceCoord: vec3) => faceCoord[1] - textureSize,\n  't-v': (textureSize: number, faceCoord: vec3) => textureSize - faceCoord[1],\n  '1+u': (textureSize: number, faceCoord: vec3) => 1 + faceCoord[0],\n  '1+v': (textureSize: number, faceCoord: vec3) => 1 + faceCoord[1],\n  '-v-1': (textureSize: number, faceCoord: vec3) => -faceCoord[1] - 1,\n  't-u-1': (textureSize: number, faceCoord: vec3) => textureSize - faceCoord[0] - 1,\n  't-v-1': (textureSize: number, faceCoord: vec3) => textureSize - faceCoord[1] - 1,\n  '2t-u-1': (textureSize: number, faceCoord: vec3) => textureSize * 2 - faceCoord[0] - 1,\n  '2t-v-1': (textureSize: number, faceCoord: vec3) => textureSize * 2 - faceCoord[1] - 1,\n} as const;\nconst kFaceConversionEnums = keysOf(kFaceConversions);\ntype FaceCoordConversion = (typeof kFaceConversionEnums)[number];\n\n// For Each face\n//   face to go if u < 0\n//   face to go if u >= textureSize\n//   face to go if v < 0\n//   face to go if v >= textureSize\nconst kFaceToFaceRemap: { to: number; u: FaceCoordConversion; v: FaceCoordConversion }[][] = [\n  // 0\n  [\n    /* -u */ { to: 4, u: 'u+t', v: 'v' },\n    /* +u */ { to: 5, u: 'u-t', v: 'v' },\n    /* -v */ { to: 2, u: 'v+t', v: 't-u-1' },\n    /* +v */ { to: 3, u: '2t-v-1', v: 'u' },\n  ],\n  // 1\n  [\n    /* -u */ { to: 5, u: 'u+t', v: 'v' },\n    /* +u */ { to: 4, u: 'u-t', v: 'v' },\n    /* -v */ { to: 2, u: '-v-1', v: 'u' }, // -1->0, -2->1  -3->2\n    /* +v */ { to: 3, u: 't-v', v: 't-u-1' },\n  ],\n  // 2\n  [\n    /* -u */ { to: 1, u: 'v', v: '1+u' },\n    /* +u */ { to: 0, u: 't-v-1', v: 'u-t' },\n    /* -v */ { to: 5, u: 't-u-1', v: 't-v-1' },\n    /* +v */ { to: 4, u: 'u', v: 'v-t' },\n  ],\n  // 3\n  [\n    /* -u */ { to: 1, u: 't-v-1', v: 'u+t' },\n    /* +u */ { to: 0, u: 'v', v: '2t-u-1' },\n    /* -v */ { to: 4, u: 'u', v: 'v+t' },\n    /* +v */ { to: 5, u: 't-u-1', v: '2t-v-1' },\n  ],\n  // 4\n  [\n    /* -u */ { to: 1, u: 'u+t', v: 'v' },\n    /* +u */ { to: 0, u: 'u-t', v: 'v' },\n    /* -v */ { to: 2, u: 'u', v: 'v+t' },\n    /* +v */ { to: 3, u: 'u', v: 'v-t' },\n  ],\n  // 5\n  [\n    /* -u */ { to: 0, u: 'u+t', v: 'v' },\n    /* +u */ { to: 1, u: 'u-t', v: 'v' },\n    /* -v */ { to: 2, u: 't-u-1', v: '1+v' },\n    /* +v */ { to: 3, u: 't-u-1', v: '2t-v-1' },\n  ],\n];\n\nfunction getFaceWrapIndex(textureSize: number, faceCoord: vec3) {\n  if (faceCoord[0] < 0) {\n    return 0;\n  }\n  if (faceCoord[0] >= textureSize) {\n    return 1;\n  }\n  if (faceCoord[1] < 0) {\n    return 2;\n  }\n  if (faceCoord[1] >= textureSize) {\n    return 3;\n  }\n  return -1;\n}\n\nfunction applyFaceWrap(textureSize: number, faceCoord: vec3): vec3 {\n  const ndx = getFaceWrapIndex(textureSize, faceCoord);\n  if (ndx < 0) {\n    return faceCoord;\n  }\n  const { to, u, v } = kFaceToFaceRemap[faceCoord[2]][ndx];\n  return [\n    kFaceConversions[u](textureSize, faceCoord),\n    kFaceConversions[v](textureSize, faceCoord),\n    to,\n  ];\n}\n\nfunction wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize: number, faceCoord: vec3) {\n  // If we're off both edges we need to wrap twice, once for each edge.\n  faceCoord = applyFaceWrap(textureSize, faceCoord);\n  faceCoord = applyFaceWrap(textureSize, faceCoord);\n  return faceCoord;\n}\n\nfunction applyAddressModesToCoords(\n  addressMode: GPUAddressMode[],\n  textureSize: number[],\n  coord: number[]\n) {\n  return coord.map((v, i) => {\n    switch (addressMode[i]) {\n      case 'clamp-to-edge':\n        return clamp(v, { min: 0, max: textureSize[i] - 1 });\n      case 'mirror-repeat': {\n        const n = Math.floor(v / textureSize[i]);\n        v = v - n * textureSize[i];\n        return (n & 1) !== 0 ? textureSize[i] - v - 1 : v;\n      }\n      case 'repeat':\n        return v - Math.floor(v / textureSize[i]) * textureSize[i];\n      default:\n        unreachable();\n    }\n  });\n}\n\n/**\n * Generates an array of coordinates at which to sample a texture for a cubemap\n */\nexport function generateSamplePointsCube(\n  n: number,\n  nearest: boolean,\n  args:\n    | {\n        method: 'texel-centre';\n        textureWidth: number;\n        textureDepthOrArrayLayers?: number;\n      }\n    | {\n        method: 'spiral';\n        radius?: number;\n        loops?: number;\n        textureWidth: number;\n        textureDepthOrArrayLayers?: number;\n      }\n    | {\n        method: 'cube-edges';\n        textureWidth: number;\n        textureDepthOrArrayLayers?: number;\n      }\n) {\n  const { method, textureWidth } = args;\n  const out: vec3[] = [];\n  switch (method) {\n    case 'texel-centre': {\n      for (let i = 0; i < n; i++) {\n        const r = hashU32(i);\n        const u = (Math.floor(lerp(0, textureWidth - 1, (r & 0xff) / 0xff)) + 0.5) / textureWidth;\n        const v =\n          (Math.floor(lerp(0, textureWidth - 1, ((r >> 8) & 0xff) / 0xff)) + 0.5) / textureWidth;\n        const face = Math.floor(lerp(0, 6, ((r >> 16) & 0xff) / 0x100));\n        out.push(convertNormalized3DTexCoordToCubeCoord([u, v, face]));\n      }\n      break;\n    }\n    case 'spiral': {\n      const { radius = 1.5, loops = 2 } = args;\n      for (let i = 0; i < n; i++) {\n        const f = (i + 1) / (Math.max(n, 2) - 1);\n        const r = radius * f;\n        const theta = loops * 2 * Math.PI * f;\n        const phi = loops * 1.3 * Math.PI * f;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n        const ux = cosTheta * sinPhi;\n        const uy = cosPhi;\n        const uz = sinTheta * sinPhi;\n        out.push([ux * r, uy * r, uz * r]);\n      }\n      break;\n    }\n    case 'cube-edges': {\n      /* prettier-ignore */\n      out.push(\n        // between edges\n        [-1.01, -1.02,  0],\n        [ 1.01, -1.02,  0],\n        [-1.01,  1.02,  0],\n        [ 1.01,  1.02,  0],\n\n        [-1.01,  0, -1.02],\n        [ 1.01,  0, -1.02],\n        [-1.01,  0,  1.02],\n        [ 1.01,  0,  1.02],\n\n        [-1.01, -1.02,  0],\n        [ 1.01, -1.02,  0],\n        [-1.01,  1.02,  0],\n        [ 1.01,  1.02,  0],\n\n        // corners (see comment \"Issues with corners of cubemaps\")\n        // for why these are commented out.\n        // [-1.01, -1.02, -1.03],\n        // [ 1.01, -1.02, -1.03],\n        // [-1.01,  1.02, -1.03],\n        // [ 1.01,  1.02, -1.03],\n        // [-1.01, -1.02,  1.03],\n        // [ 1.01, -1.02,  1.03],\n        // [-1.01,  1.02,  1.03],\n        // [ 1.01,  1.02,  1.03],\n      );\n      break;\n    }\n  }\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n  const q = [\n    textureWidth * kSubdivisionsPerTexel,\n    textureWidth * kSubdivisionsPerTexel,\n    6 * kSubdivisionsPerTexel,\n  ];\n  return out.map(c => {\n    const uvw = convertCubeCoordToNormalized3DTextureCoord(c);\n\n    // If this is a corner, move to in so it's not\n    // (see comment \"Issues with corners of cubemaps\")\n    const ndx = getUnusedCubeCornerSampleIndex(textureWidth, uvw);\n    if (ndx >= 0) {\n      const halfTexel = 0.5 / textureWidth;\n      uvw[0] = clamp(uvw[0], { min: halfTexel, max: 1 - halfTexel });\n    }\n\n    const quantizedUVW = uvw.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another in nearest mode\n      const v2 = nearest && v1 % kSubdivisionsPerTexel === 0 ? v1 + 1 : v1;\n      // Convert back to texture coords\n      return v2 / q[i];\n    }) as vec3;\n    return convertNormalized3DTexCoordToCubeCoord(quantizedUVW);\n  });\n}\n\nfunction wgslTypeFor(data: number | Dimensionality, type: 'f' | 'i' | 'u'): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}32`;\n      case 2:\n        return `vec2${type}`;\n      case 3:\n        return `vec3${type}`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32`;\n}\n\nfunction wgslExpr(data: number | vec1 | vec2 | vec3 | vec4): string {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return data[0].toString();\n      case 2:\n        return `vec2(${data.map(v => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3(${data.map(v => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return data.toString();\n}\n\nfunction binKey<T extends Dimensionality>(call: TextureCall<T>): string {\n  const keys: string[] = [];\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        // offset must be a constant expression\n        keys.push(`${name}: ${wgslExpr(value)}`);\n      } else {\n        keys.push(`${name}: ${wgslTypeFor(value, call.coordType)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${keys.join(', ')})`;\n}\n\nfunction buildBinnedCalls<T extends Dimensionality>(calls: TextureCall<T>[]) {\n  const args: string[] = ['T']; // All texture builtins take the texture as the first argument\n  const fields: string[] = [];\n  const data: number[] = [];\n\n  const prototype = calls[0];\n  if (prototype.builtin.startsWith('textureSample')) {\n    // textureSample*() builtins take a sampler as the second argument\n    args.push('S');\n  }\n\n  for (const name of kTextureCallArgNames) {\n    const value = prototype[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        args.push(`/* offset */ ${wgslExpr(value)}`);\n      } else {\n        args.push(`args.${name}`);\n        fields.push(`@align(16) ${name} : ${wgslTypeFor(value, prototype.coordType)}`);\n      }\n    }\n  }\n\n  for (const call of calls) {\n    for (const name of kTextureCallArgNames) {\n      const value = call[name];\n      assert(\n        (prototype[name] === undefined) === (value === undefined),\n        'texture calls are not binned correctly'\n      );\n      if (value !== undefined && name !== 'offset') {\n        const bitcastToU32 = (value: number) => {\n          if (calls[0].coordType === 'f') {\n            return float32ToUint32(value);\n          }\n          return value;\n        };\n        if (value instanceof Array) {\n          for (const c of value) {\n            data.push(bitcastToU32(c));\n          }\n        } else {\n          data.push(bitcastToU32(value));\n        }\n        // All fields are aligned to 16 bytes.\n        while ((data.length & 3) !== 0) {\n          data.push(0);\n        }\n      }\n    }\n  }\n\n  const expr = `${prototype.builtin}(${args.join(', ')})`;\n\n  return { expr, fields, data };\n}\n\nfunction binCalls<T extends Dimensionality>(calls: TextureCall<T>[]): number[][] {\n  const map = new Map<string, number>(); // key to bin index\n  const bins: number[][] = [];\n  calls.forEach((call, callIdx) => {\n    const key = binKey(call);\n    const binIdx = map.get(key);\n    if (binIdx === undefined) {\n      map.set(key, bins.length);\n      bins.push([callIdx]);\n    } else {\n      bins[binIdx].push(callIdx);\n    }\n  });\n  return bins;\n}\n\nexport function describeTextureCall<T extends Dimensionality>(call: TextureCall<T>): string {\n  const args: string[] = ['texture: T'];\n  if (call.builtin.startsWith('textureSample')) {\n    args.push('sampler: S');\n  }\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      args.push(`${name}: ${wgslExpr(value)}`);\n    }\n  }\n  return `${call.builtin}(${args.join(', ')})`;\n}\n\nconst s_deviceToPipelines = new WeakMap<GPUDevice, Map<string, GPURenderPipeline>>();\n\n/**\n * Given a list of \"calls\", each one of which has a texture coordinate,\n * generates a fragment shader that uses the fragment position as an index\n * (position.y * 256 + position.x) That index is then used to look up a\n * coordinate from a storage buffer which is used to call the WGSL texture\n * function to read/sample the texture, and then write to an rgba32float\n * texture.  We then read the rgba32float texture for the per \"call\" results.\n *\n * Calls are \"binned\" by call parameters. Each bin has its own structure and\n * field in the storage buffer. This allows the calls to be non-homogenous and\n * each have their own data type for coordinates.\n */\nexport async function doTextureCalls<T extends Dimensionality>(\n  t: GPUTest,\n  gpuTexture: GPUTexture,\n  viewDescriptor: GPUTextureViewDescriptor,\n  textureType: string,\n  sampler: GPUSamplerDescriptor,\n  calls: TextureCall<T>[]\n) {\n  let structs = '';\n  let body = '';\n  let dataFields = '';\n  const data: number[] = [];\n  let callCount = 0;\n  const binned = binCalls(calls);\n  binned.forEach((binCalls, binIdx) => {\n    const b = buildBinnedCalls(binCalls.map(callIdx => calls[callIdx]));\n    structs += `struct Args${binIdx} {\n  ${b.fields.join(',  \\n')}\n}\n`;\n    dataFields += `  args${binIdx} : array<Args${binIdx}, ${binCalls.length}>,\n`;\n    body += `\n  {\n    let is_active = (frag_idx >= ${callCount}) & (frag_idx < ${callCount + binCalls.length});\n    let args = data.args${binIdx}[frag_idx - ${callCount}];\n    let call = ${b.expr};\n    result = select(result, call, is_active);\n  }\n`;\n    callCount += binCalls.length;\n    data.push(...b.data);\n  });\n\n  const dataBuffer = t.createBufferTracked({\n    size: data.length * 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n  t.device.queue.writeBuffer(dataBuffer, 0, new Uint32Array(data));\n\n  const rtWidth = 256;\n  const renderTarget = t.createTextureTracked({\n    format: 'rgba32float',\n    size: { width: rtWidth, height: Math.ceil(calls.length / rtWidth) },\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  const code = `\n${structs}\n\nstruct Data {\n${dataFields}\n}\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertex_index : u32) -> @builtin(position) vec4f {\n  let positions = array(\n    vec4f(-1,  1, 0, 1), vec4f( 1,  1, 0, 1),\n    vec4f(-1, -1, 0, 1), vec4f( 1, -1, 0, 1),\n  );\n  return positions[vertex_index];\n}\n\n@group(0) @binding(0) var          T    : ${textureType};\n@group(0) @binding(1) var          S    : sampler;\n@group(0) @binding(2) var<storage> data : Data;\n\n@fragment\nfn fs_main(@builtin(position) frag_pos : vec4f) -> @location(0) vec4f {\n  let frag_idx = u32(frag_pos.x) + u32(frag_pos.y) * ${renderTarget.width};\n  var result : vec4f;\n${body}\n  return result;\n}\n`;\n\n  const pipelines = s_deviceToPipelines.get(t.device) ?? new Map<string, GPURenderPipeline>();\n  s_deviceToPipelines.set(t.device, pipelines);\n\n  let pipeline = pipelines.get(code);\n  if (!pipeline) {\n    const shaderModule = t.device.createShaderModule({ code });\n\n    pipeline = t.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: { module: shaderModule },\n      fragment: {\n        module: shaderModule,\n        targets: [{ format: renderTarget.format }],\n      },\n      primitive: { topology: 'triangle-strip' },\n    });\n\n    pipelines.set(code, pipeline);\n  }\n\n  const gpuSampler = t.device.createSampler(sampler);\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: gpuTexture.createView(viewDescriptor) },\n      { binding: 1, resource: gpuSampler },\n      { binding: 2, resource: { buffer: dataBuffer } },\n    ],\n  });\n\n  const bytesPerRow = align(16 * renderTarget.width, 256);\n  const resultBuffer = t.createBufferTracked({\n    size: renderTarget.height * bytesPerRow,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n  });\n  const encoder = t.device.createCommandEncoder();\n\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [\n      {\n        view: renderTarget.createView(),\n        loadOp: 'clear',\n        storeOp: 'store',\n      },\n    ],\n  });\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setBindGroup(0, bindGroup);\n  renderPass.draw(4);\n  renderPass.end();\n  encoder.copyTextureToBuffer(\n    { texture: renderTarget },\n    { buffer: resultBuffer, bytesPerRow },\n    { width: renderTarget.width, height: renderTarget.height }\n  );\n  t.device.queue.submit([encoder.finish()]);\n\n  await resultBuffer.mapAsync(GPUMapMode.READ);\n\n  const view = TexelView.fromTextureDataByReference(\n    renderTarget.format as EncodableTextureFormat,\n    new Uint8Array(resultBuffer.getMappedRange()),\n    {\n      bytesPerRow,\n      rowsPerImage: renderTarget.height,\n      subrectOrigin: [0, 0, 0],\n      subrectSize: [renderTarget.width, renderTarget.height],\n    }\n  );\n\n  let outIdx = 0;\n  const out = new Array<PerTexelComponent<number>>(calls.length);\n  for (const bin of binned) {\n    for (const callIdx of bin) {\n      const x = outIdx % rtWidth;\n      const y = Math.floor(outIdx / rtWidth);\n      out[callIdx] = view.color({ x, y, z: 0 });\n      outIdx++;\n    }\n  }\n\n  renderTarget.destroy();\n  resultBuffer.destroy();\n\n  return out;\n}\n"],"mappings":"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"}