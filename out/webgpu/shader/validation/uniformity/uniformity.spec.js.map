{"version":3,"file":"uniformity.spec.js","names":["description","makeTestGroup","keysOf","unreachable","ShaderValidationTest","g","kCollectiveOps","op","stage","kConditions","cond","expectation","generateCondition","condition","generateOp","generateConditionalStatement","statement","code","test","desc","params","u","combineWithParams","combine","beginSubcases","fn","t","expectCompileResult","kFragmentBuiltinValues","builtin","type","kComputeBuiltinValues","uniform","generatePointerCheck","check","kPointerCases","address_uniform_literal","address_uniform_value","address_nonuniform_value","address_uniform_chain","address_nonuniform_chain1","address_nonuniform_chain2","wg_uniform_load_is_uniform","contents_scalar_uniform1","contents_scalar_uniform2","contents_scalar_uniform3","contents_scalar_nonuniform1","contents_scalar_nonuniform2","contents_scalar_alias_uniform","contents_scalar_alias_nonuniform1","contents_scalar_alias_nonuniform2","contents_scalar_alias_nonuniform3","contents_scalar_alias_nonuniform4","contents_scalar_alias_nonuniform5","contents_array_uniform_index","contents_array_nonuniform_index1","contents_array_nonuniform_index2","contents_array_nonuniform_index3","contents_struct_uniform","contents_struct_nonuniform1","contents_struct_nonuniform2","contents_struct_nonuniform3","contents_struct_chain_uniform","contents_struct_chain_nonuniform1","contents_struct_chain_nonuniform2","contents_struct_chain_nonuniform3","testcase","case","with_check","without_check","expectedUniformity","init","kFuncVarCases","no_assign","typename","typedecl","assignment","simple_uniform","simple_nonuniform","compound_assign_uniform","compound_assign_nonuniform","unreachable_uniform","unreachable_nonuniform","if_no_else_uniform","if_no_else_nonuniform","if_no_then_uniform","if_no_then_nonuniform","if_else_uniform","if_else_nonuniform","if_else_split","if_unreachable_else_none","if_unreachable_else_uniform","if_unreachable_else_nonuniform","if_unreachable_then_none","if_unreachable_then_uniform","if_unreachable_then_nonuniform","if_nonescaping_nonuniform","loop_body_depends_on_continuing_uniform","loop_body_depends_on_continuing_nonuniform","loop_body_uniform","loop_body_nonuniform","loop_body_nonuniform_cond","loop_unreachable_continuing","loop_continuing_from_body_uniform","loop_continuing_from_body_nonuniform","loop_continuing_from_body_split1","loop_continuing_from_body_split2","loop_continuing_from_body_split3","loop_continuing_from_body_split4","loop_continuing_from_body_split5","loop_in_loop_with_continue_uniform","loop_in_loop_with_continue_nonuniform","after_loop_with_uniform_break_uniform","after_loop_with_uniform_break_nonuniform","after_loop_with_nonuniform_break","after_loop_with_uniform_breaks","switch_uniform_case","switch_nonuniform_case","after_switch_all_uniform","after_switch_some_assign","after_switch_nonuniform","after_switch_with_break_nonuniform1","after_switch_with_break_nonuniform2","for_loop_uniform_body","for_loop_nonuniform_body","for_loop_uniform_body_no_condition","for_loop_nonuniform_body_no_condition","for_loop_uniform_increment","for_loop_nonuniform_increment","for_loop_uniform_init","for_loop_nonuniform_init","while_loop_uniform_body","while_loop_nonuniform_body","partial_assignment_uniform","partial_assignment_nonuniform","partial_assignment_all_members_uniform","partial_assignment_all_members_nonuniform","partial_assignment_single_element_struct_uniform","partial_assignment_single_element_struct_nonuniform","partial_assignment_single_element_array_uniform","partial_assignment_single_element_array_nonuniform","nested1","nested2","kVarInit","no_init","nonuniform","func_case","result","kShortCircuitExpressionCases","or_uniform_uniform","or_uniform_nonuniform","or_nonuniform_uniform","or_nonuniform_nonuniform","or_uniform_first_nonuniform","or_uniform_second_nonuniform","and_uniform_uniform","and_uniform_nonuniform","and_nonuniform_uniform","and_nonuniform_nonuniform","and_uniform_first_nonuniform","and_uniform_second_nonuniform","res","kExpressionCases","literal","uniform_index","nonuniform_index1","nonuniform_index2","uniform_struct","nonuniform_struct","kBinOps","plus","minus","times","div","rem","and","or","xor","shl","shr","less","lessequal","greater","greaterequal","equal","notequal","e1","e2","e"],"sources":["../../../../../src/webgpu/shader/validation/uniformity/uniformity.spec.ts"],"sourcesContent":["export const description = `Validation tests for uniformity analysis`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { unreachable } from '../../../../common/util/util.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kCollectiveOps = [\n  { op: 'textureSample', stage: 'fragment' },\n  { op: 'textureSampleBias', stage: 'fragment' },\n  { op: 'textureSampleCompare', stage: 'fragment' },\n  { op: 'dpdx', stage: 'fragment' },\n  { op: 'dpdxCoarse', stage: 'fragment' },\n  { op: 'dpdxFine', stage: 'fragment' },\n  { op: 'dpdy', stage: 'fragment' },\n  { op: 'dpdyCoarse', stage: 'fragment' },\n  { op: 'dpdyFine', stage: 'fragment' },\n  { op: 'fwidth', stage: 'fragment' },\n  { op: 'fwidthCoarse', stage: 'fragment' },\n  { op: 'fwidthFine', stage: 'fragment' },\n  { op: 'storageBarrier', stage: 'compute' },\n  { op: 'workgroupBarrier', stage: 'compute' },\n  { op: 'workgroupUniformLoad', stage: 'compute' },\n];\n\nconst kConditions = [\n  { cond: 'uniform_storage_ro', expectation: true },\n  { cond: 'nonuniform_storage_ro', expectation: false },\n  { cond: 'nonuniform_storage_rw', expectation: false },\n  { cond: 'nonuniform_builtin', expectation: false },\n  { cond: 'uniform_literal', expectation: true },\n  { cond: 'uniform_const', expectation: true },\n  { cond: 'uniform_override', expectation: true },\n  { cond: 'uniform_let', expectation: true },\n  { cond: 'nonuniform_let', expectation: false },\n  { cond: 'uniform_or', expectation: true },\n  { cond: 'nonuniform_or1', expectation: false },\n  { cond: 'nonuniform_or2', expectation: false },\n  { cond: 'uniform_and', expectation: true },\n  { cond: 'nonuniform_and1', expectation: false },\n  { cond: 'nonuniform_and2', expectation: false },\n  { cond: 'uniform_func_var', expectation: true },\n  { cond: 'nonuniform_func_var', expectation: false },\n];\n\nfunction generateCondition(condition: string): string {\n  switch (condition) {\n    case 'uniform_storage_ro': {\n      return `ro_buffer[0] == 0`;\n    }\n    case 'nonuniform_storage_ro': {\n      return `ro_buffer[priv_var[0]] == 0`;\n    }\n    case 'nonuniform_storage_rw': {\n      return `rw_buffer[0] == 0`;\n    }\n    case 'nonuniform_builtin': {\n      return `p.x == 0`;\n    }\n    case 'uniform_literal': {\n      return `false`;\n    }\n    case 'uniform_const': {\n      return `c`;\n    }\n    case 'uniform_override': {\n      return `o == 0`;\n    }\n    case 'uniform_let': {\n      return `u_let == 0`;\n    }\n    case 'nonuniform_let': {\n      return `n_let == 0`;\n    }\n    case 'uniform_or': {\n      return `u_let == 0 || uniform_buffer.y > 1`;\n    }\n    case 'nonuniform_or1': {\n      return `u_let == 0 || n_let == 0`;\n    }\n    case 'nonuniform_or2': {\n      return `n_let == 0 || u_let == 0`;\n    }\n    case 'uniform_and': {\n      return `u_let == 0 && uniform_buffer.y > 1`;\n    }\n    case 'nonuniform_and1': {\n      return `u_let == 0 && n_let == 0`;\n    }\n    case 'nonuniform_and2': {\n      return `n_let == 0 && u_let == 0`;\n    }\n    case 'uniform_func_var': {\n      return `u_f == 0`;\n    }\n    case 'nonuniform_func_var': {\n      return `n_f == 0`;\n    }\n    default: {\n      unreachable(`Unhandled condition`);\n    }\n  }\n}\n\nfunction generateOp(op: string): string {\n  switch (op) {\n    case 'textureSample': {\n      return `let x = ${op}(tex, s, vec2(0,0));\\n`;\n    }\n    case 'textureSampleBias': {\n      return `let x = ${op}(tex, s, vec2(0,0), 0);\\n`;\n    }\n    case 'textureSampleCompare': {\n      return `let x = ${op}(tex_depth, s_comp, vec2(0,0), 0);\\n`;\n    }\n    case 'storageBarrier':\n    case 'workgroupBarrier': {\n      return `${op}();\\n`;\n    }\n    case 'workgroupUniformLoad': {\n      return `let x = ${op}(&wg);`;\n    }\n    case 'dpdx':\n    case 'dpdxCoarse':\n    case 'dpdxFine':\n    case 'dpdy':\n    case 'dpdyCoarse':\n    case 'dpdyFine':\n    case 'fwidth':\n    case 'fwidthCoarse':\n    case 'fwidthFine': {\n      return `let x = ${op}(0);\\n`;\n    }\n    default: {\n      unreachable(`Unhandled op`);\n    }\n  }\n}\n\nfunction generateConditionalStatement(statement: string, condition: string, op: string): string {\n  const code = ``;\n  switch (statement) {\n    case 'if': {\n      return `if ${generateCondition(condition)} {\n        ${generateOp(op)};\n      }\n      `;\n    }\n    case 'for': {\n      return `for (; ${generateCondition(condition)};) {\n        ${generateOp(op)};\n      }\n      `;\n    }\n    case 'while': {\n      return `while ${generateCondition(condition)} {\n        ${generateOp(op)};\n      }\n      `;\n    }\n    case 'switch': {\n      return `switch u32(${generateCondition(condition)}) {\n        case 0: {\n          ${generateOp(op)};\n        }\n        default: { }\n      }\n      `;\n    }\n    default: {\n      unreachable(`Unhandled statement`);\n    }\n  }\n\n  return code;\n}\n\ng.test('basics')\n  .desc(`Test collective operations in simple uniform or non-uniform control flow.`)\n  .params(u =>\n    u\n      .combineWithParams(kCollectiveOps)\n      .combineWithParams(kConditions)\n      .combine('statement', ['if', 'for', 'while', 'switch'] as const)\n      .beginSubcases()\n  )\n  .fn(t => {\n    let code = `\n @group(0) @binding(0) var s : sampler;\n @group(0) @binding(1) var s_comp : sampler_comparison;\n @group(0) @binding(2) var tex : texture_2d<f32>;\n @group(0) @binding(3) var tex_depth : texture_depth_2d;\n\n @group(1) @binding(0) var<storage, read> ro_buffer : array<f32, 4>;\n @group(1) @binding(1) var<storage, read_write> rw_buffer : array<f32, 4>;\n @group(1) @binding(2) var<uniform> uniform_buffer : vec4<f32>;\n\n var<private> priv_var : array<f32, 4> = array(0,0,0,0);\n\n const c = false;\n override o : f32;\n`;\n\n    if (t.params.stage === 'compute') {\n      code += `var<workgroup> wg : f32;\\n`;\n      code += ` @workgroup_size(16, 1, 1)`;\n    }\n    code += `@${t.params.stage}`;\n    code += `\\nfn main(`;\n    if (t.params.stage === 'compute') {\n      code += `@builtin(global_invocation_id) p : vec3<u32>`;\n    } else {\n      code += `@builtin(position) p : vec4<f32>`;\n    }\n    code += `) {\n      let u_let = uniform_buffer.x;\n      let n_let = rw_buffer[0];\n      var u_f = uniform_buffer.z;\n      var n_f = rw_buffer[1];\n    `;\n\n    // Simple control statement containing the op.\n    code += generateConditionalStatement(t.params.statement, t.params.cond, t.params.op);\n\n    code += `\\n}\\n`;\n\n    t.expectCompileResult(t.params.expectation, code);\n  });\n\nconst kFragmentBuiltinValues = [\n  {\n    builtin: `position`,\n    type: `vec4<f32>`,\n  },\n  {\n    builtin: `front_facing`,\n    type: `bool`,\n  },\n  {\n    builtin: `sample_index`,\n    type: `u32`,\n  },\n  {\n    builtin: `sample_mask`,\n    type: `u32`,\n  },\n];\n\ng.test('fragment_builtin_values')\n  .desc(`Test uniformity of fragment built-in values`)\n  .params(u => u.combineWithParams(kFragmentBuiltinValues).beginSubcases())\n  .fn(t => {\n    let cond = ``;\n    switch (t.params.type) {\n      case `u32`:\n      case `i32`:\n      case `f32`: {\n        cond = `p > 0`;\n        break;\n      }\n      case `vec4<u32>`:\n      case `vec4<i32>`:\n      case `vec4<f32>`: {\n        cond = `p.x > 0`;\n        break;\n      }\n      case `bool`: {\n        cond = `p`;\n        break;\n      }\n      default: {\n        unreachable(`Unhandled type`);\n      }\n    }\n    const code = `\n@group(0) @binding(0) var s : sampler;\n@group(0) @binding(1) var tex : texture_2d<f32>;\n\n@fragment\nfn main(@builtin(${t.params.builtin}) p : ${t.params.type}) {\n  if ${cond} {\n    let texel = textureSample(tex, s, vec2<f32>(0,0));\n  }\n}\n`;\n\n    t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    t.expectCompileResult(false, code);\n  });\n\nconst kComputeBuiltinValues = [\n  {\n    builtin: `local_invocation_id`,\n    type: `vec3<f32>`,\n    uniform: false,\n  },\n  {\n    builtin: `local_invocation_index`,\n    type: `u32`,\n    uniform: false,\n  },\n  {\n    builtin: `global_invocation_id`,\n    type: `vec3<u32>`,\n    uniform: false,\n  },\n  {\n    builtin: `workgroup_id`,\n    type: `vec3<u32>`,\n    uniform: true,\n  },\n  {\n    builtin: `num_workgroups`,\n    type: `vec3<u32>`,\n    uniform: true,\n  },\n];\n\ng.test('compute_builtin_values')\n  .desc(`Test uniformity of compute built-in values`)\n  .params(u => u.combineWithParams(kComputeBuiltinValues).beginSubcases())\n  .fn(t => {\n    let cond = ``;\n    switch (t.params.type) {\n      case `u32`:\n      case `i32`:\n      case `f32`: {\n        cond = `p > 0`;\n        break;\n      }\n      case `vec3<u32>`:\n      case `vec3<i32>`:\n      case `vec3<f32>`: {\n        cond = `p.x > 0`;\n        break;\n      }\n      case `bool`: {\n        cond = `p`;\n        break;\n      }\n      default: {\n        unreachable(`Unhandled type`);\n      }\n    }\n    const code = `\n@compute @workgroup_size(16,1,1)\nfn main(@builtin(${t.params.builtin}) p : ${t.params.type}) {\n  if ${cond} {\n    workgroupBarrier();\n  }\n}\n`;\n\n    t.expectCompileResult(t.params.uniform, code);\n  });\n\nfunction generatePointerCheck(check: string): string {\n  if (check === `address`) {\n    return `let tmp = workgroupUniformLoad(ptr);`;\n  } else {\n    // check === `contents`\n    return `if test_val > 0 {\n      workgroupBarrier();\n    }`;\n  }\n}\n\nconst kPointerCases = {\n  address_uniform_literal: {\n    code: `let ptr = &wg_array[0];`,\n    check: `address`,\n    uniform: true,\n  },\n  address_uniform_value: {\n    code: `let ptr = &wg_array[uniform_value];`,\n    check: `address`,\n    uniform: true,\n  },\n  address_nonuniform_value: {\n    code: `let ptr = &wg_array[nonuniform_value];`,\n    check: `address`,\n    uniform: false,\n  },\n  address_uniform_chain: {\n    code: `let p1 = &wg_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let ptr = &(*p3)[uniform_value];`,\n    check: `address`,\n    uniform: true,\n  },\n  address_nonuniform_chain1: {\n    code: `let p1 = &wg_struct.x;\n    let p2 = &(*p1)[nonuniform_value];\n    let p3 = &(*p2).x;\n    let ptr = &(*p3)[uniform_value];`,\n    check: `address`,\n    uniform: false,\n  },\n  address_nonuniform_chain2: {\n    code: `let p1 = &wg_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let ptr = &(*p3)[nonuniform_value];`,\n    check: `address`,\n    uniform: false,\n  },\n  wg_uniform_load_is_uniform: {\n    code: `let test_val = workgroupUniformLoad(&wg_scalar);`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_uniform1: {\n    code: `let ptr = &func_scalar;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_uniform2: {\n    code: `func_scalar = nonuniform_value;\n    let ptr = &func_scalar;\n    func_scalar = 0;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_uniform3: {\n    code: `let ptr = &func_scalar;\n    func_scalar = nonuniform_value;\n    func_scalar = uniform_value;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_nonuniform1: {\n    code: `func_scalar = nonuniform_value;\n    let ptr = &func_scalar;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_nonuniform2: {\n    code: `let ptr = &func_scalar;\n    *ptr = nonuniform_value;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_uniform: {\n    code: `let p = &func_scalar;\n    let ptr = p;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_scalar_alias_nonuniform1: {\n    code: `func_scalar = nonuniform_value;\n    let p = &func_scalar;\n    let ptr = p;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform2: {\n    code: `let p = &func_scalar;\n    *p = nonuniform_value;\n    let ptr = p;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform3: {\n    code: `let p = &func_scalar;\n    let ptr = p;\n    *p = nonuniform_value;\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform4: {\n    code: `let p = &func_scalar;\n    func_scalar = nonuniform_value;\n    let test_val = *p;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_scalar_alias_nonuniform5: {\n    code: `let p = &func_scalar;\n    *p = nonuniform_value;\n    let test_val = func_scalar;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_array_uniform_index: {\n    code: `let ptr = &func_array[uniform_value];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_array_nonuniform_index1: {\n    code: `let ptr = &func_array[nonuniform_value];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_array_nonuniform_index2: {\n    code: `let ptr = &func_array[lid.x];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_array_nonuniform_index3: {\n    code: `let ptr = &func_array[gid.x];\n    let test_val = *ptr;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_uniform: {\n    code: `let p1 = &func_struct.x[uniform_value].x[uniform_value].x[uniform_value];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_struct_nonuniform1: {\n    code: `let p1 = &func_struct.x[nonuniform_value].x[uniform_value].x[uniform_value];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_nonuniform2: {\n    code: `let p1 = &func_struct.x[uniform_value].x[gid.x].x[uniform_value];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_nonuniform3: {\n    code: `let p1 = &func_struct.x[uniform_value].x[uniform_value].x[lid.y];\n    let test_val = *p1;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_chain_uniform: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[uniform_value];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[uniform_value];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: true,\n  },\n  contents_struct_chain_nonuniform1: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[nonuniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[uniform_value];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[uniform_value];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_chain_nonuniform2: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[gid.x];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[uniform_value];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: false,\n  },\n  contents_struct_chain_nonuniform3: {\n    code: `let p1 = &func_struct.x;\n    let p2 = &(*p1)[uniform_value];\n    let p3 = &(*p2).x;\n    let p4 = &(*p3)[uniform_value];\n    let p5 = &(*p4).x;\n    let p6 = &(*p5)[lid.y];\n    let test_val = *p6;`,\n    check: `contents`,\n    uniform: false,\n  },\n};\n\ng.test('pointers')\n  .desc(`Test pointer uniformity (contents and addresses)`)\n  .params(u => u.combine('case', keysOf(kPointerCases)).beginSubcases())\n  .fn(t => {\n    const testcase = kPointerCases[t.params.case];\n    const code = `\nvar<workgroup> wg_scalar : u32;\nvar<workgroup> wg_array : array<u32, 16>;\n\nstruct Inner {\n  x : array<u32, 4>\n}\nstruct Middle {\n  x : array<Inner, 4>\n}\nstruct Outer {\n  x : array<Middle, 4>\n}\nvar<workgroup> wg_struct : Outer;\n\n@group(0) @binding(0)\nvar<storage> uniform_value : u32;\n@group(0) @binding(1)\nvar<storage, read_write> nonuniform_value : u32;\n\n@compute @workgroup_size(16, 1, 1)\nfn main(@builtin(local_invocation_id) lid : vec3<u32>,\n        @builtin(global_invocation_id) gid : vec3<u32>) {\n  var func_scalar : u32;\n  var func_array : array<u32, 16>;\n  var func_struct : Outer;\n\n  ${testcase.code}\n`;\n\n    const with_check =\n      code +\n      `\n${generatePointerCheck(testcase.check)}\n}`;\n    if (!testcase.uniform) {\n      const without_check = code + `}\\n`;\n      t.expectCompileResult(true, without_check);\n    }\n    t.expectCompileResult(testcase.uniform, with_check);\n  });\n\nfunction expectedUniformity(uniform: string, init: string): boolean {\n  if (uniform === `always`) {\n    return true;\n  } else if (uniform === `init`) {\n    return init === `no_init` || init === `uniform`;\n  }\n\n  // uniform == `never` (or unknown values)\n  return false;\n}\n\nconst kFuncVarCases = {\n  no_assign: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: ``,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  simple_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x = uniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  simple_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x = nonuniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  compound_assign_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x += uniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  compound_assign_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `x -= nonuniform_value[0];`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  unreachable_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      break;\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  unreachable_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      break;\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_no_else_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_no_else_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_no_then_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n    } else {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_no_then_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n    } else {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_else_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    } else {\n      x = uniform_value[1];\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  if_else_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n    } else {\n      x = nonuniform_value[1];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_else_split: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    } else {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_unreachable_else_none: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n    } else {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_unreachable_else_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = uniform_value[0];\n    } else {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  if_unreachable_else_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n    } else {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_unreachable_then_none: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  if_unreachable_then_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      return;\n    } else {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  if_unreachable_then_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      return;\n    } else {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  if_nonescaping_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `if uniform_cond {\n      x = nonuniform_value[0];\n      return;\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  loop_body_depends_on_continuing_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if x > 0 {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n      continuing {\n        x = uniform_value[0];\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `init`,\n  },\n  loop_body_depends_on_continuing_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if x > 0 {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n      continuing {\n        x = nonuniform_value[0];\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_body_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = uniform_value[0];\n      continuing {\n        break if uniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  loop_body_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = nonuniform_value[0];\n      continuing {\n        break if uniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  loop_body_nonuniform_cond: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      // The analysis doesn't recognize the content of the value.\n      x = uniform_value[0];\n      continuing {\n        break if nonuniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  loop_unreachable_continuing: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      break;\n      continuing {\n        break if uniform_cond;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  loop_continuing_from_body_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = uniform_value[0];\n      continuing  {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `always`,\n  },\n  loop_continuing_from_body_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      x = nonuniform_value[0];\n      continuing  {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_continuing_from_body_split1: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `init`,\n  },\n  loop_continuing_from_body_split2: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = nonuniform_value[0];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_continuing_from_body_split3: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n      } else {\n        x = uniform_value[1];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `always`,\n  },\n  loop_continuing_from_body_split4: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if nonuniform_cond {\n        x = uniform_value[0];\n      } else {\n        x = uniform_value[1];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  loop_continuing_from_body_split5: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if nonuniform_cond {\n        x = uniform_value[0];\n      } else {\n        x = uniform_value[0];\n      }\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    // The analysis doesn't recognize that uniform_value[0] is assignment on all paths.\n    uniform: `never`,\n  },\n  loop_in_loop_with_continue_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      loop {\n        x = nonuniform_value[0];\n        if nonuniform_cond {\n          break;\n        }\n        continue;\n      }\n      x = uniform_value[0];\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `always`,\n  },\n  loop_in_loop_with_continue_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      loop {\n        x = uniform_value[0];\n        if uniform_cond {\n          break;\n        }\n        continue;\n      }\n      x = nonuniform_value[0];\n      continuing {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n        break if uniform_cond;\n      }\n    }`,\n    cond: `true`, // override the standard check\n    uniform: `never`,\n  },\n  after_loop_with_uniform_break_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  after_loop_with_uniform_break_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = nonuniform_value[0];\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_loop_with_nonuniform_break: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if nonuniform_cond {\n        x = uniform_value[0];\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_loop_with_uniform_breaks: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `loop {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n      } else {\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  switch_uniform_case: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n      }\n      default {\n      }\n    }`,\n    cond: `true`, // override default check\n    uniform: `init`,\n  },\n  switch_nonuniform_case: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch nonuniform_val {\n      case 0 {\n        if x > 0 {\n          let tmp = textureSample(t, s, vec2f(0,0));\n        }\n      }\n      default {\n      }\n    }`,\n    cond: `true`, // override default check\n    uniform: `never`,\n  },\n  after_switch_all_uniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        x = uniform_value[0];\n      }\n      case 1,2 {\n        x = uniform_value[1];\n      }\n      default {\n        x = uniform_value[2];\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  after_switch_some_assign: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        x = uniform_value[0];\n      }\n      case 1,2 {\n        x = uniform_value[1];\n      }\n      default {\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  after_switch_nonuniform: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      case 0 {\n        x = uniform_value[0];\n      }\n      case 1,2 {\n        x = uniform_value[1];\n      }\n      default {\n        x = nonuniform_value[0];\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_switch_with_break_nonuniform1: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      default {\n        if uniform_cond {\n          x = uniform_value[0];\n          break;\n        }\n        x = nonuniform_value[0];\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  after_switch_with_break_nonuniform2: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `switch uniform_val {\n      default {\n        x = uniform_value[0];\n        if uniform_cond {\n          x = nonuniform_value[0];\n          break;\n        }\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; i < 10; i += 1) {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  for_loop_nonuniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; i < 10; i += 1) {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_body_no_condition: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; ; i += 1) {\n      x = uniform_value[0];\n      if uniform_cond {\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  for_loop_nonuniform_body_no_condition: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (var i = 0; ; i += 1) {\n      x = nonuniform_value[0];\n      if uniform_cond {\n        break;\n      }\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_increment: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (; uniform_cond; x += uniform_value[0]) {\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  for_loop_nonuniform_increment: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (; uniform_cond; x += nonuniform_value[0]) {\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  for_loop_uniform_init: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (x = uniform_value[0]; uniform_cond; ) {\n    }`,\n    cond: `x > 0`,\n    uniform: `always`,\n  },\n  for_loop_nonuniform_init: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `for (x = nonuniform_value[0]; uniform_cond;) {\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  while_loop_uniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `while uniform_cond {\n      x = uniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `init`,\n  },\n  while_loop_nonuniform_body: {\n    typename: `u32`,\n    typedecl: ``,\n    assignment: `while uniform_cond {\n      x = nonuniform_value[0];\n    }`,\n    cond: `x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_uniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = uniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_nonuniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = nonuniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_all_members_uniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = uniform_value[0].x;\n    x.y = uniform_value[1].y;`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_all_members_nonuniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `x.x = nonuniform_value[0].x;\n    x.y = uniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_single_element_struct_uniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32\n    }`,\n    assignment: `x.x = uniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_single_element_struct_nonuniform: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32\n    }`,\n    assignment: `x.x = nonuniform_value[0].x;`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n  partial_assignment_single_element_array_uniform: {\n    typename: `array<u32, 1>`,\n    typedecl: ``,\n    assignment: `x[0] = uniform_value[0][0];`,\n    cond: `x[0] > 0`,\n    uniform: `init`,\n  },\n  partial_assignment_single_element_array_nonuniform: {\n    typename: `array<u32, 1>`,\n    typedecl: ``,\n    assignment: `x[0] = nonuniform_value[0][0];`,\n    cond: `x[0] > 0`,\n    uniform: `never`,\n  },\n  nested1: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `for (; uniform_cond; ) {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n        x.y = nonuniform_value[0].y;\n      } else {\n        if uniform_cond {\n          continue;\n        }\n        x = uniform_value[1];\n      }\n    }`,\n    cond: `x.x > 0`,\n    uniform: `init`,\n  },\n  nested2: {\n    typename: `block`,\n    typedecl: `struct block {\n      x : u32,\n      y : u32\n    }`,\n    assignment: `for (; uniform_cond; ) {\n      if uniform_cond {\n        x = uniform_value[0];\n        break;\n        x.y = nonuniform_value[0].y;\n      } else {\n        if nonuniform_cond {\n          continue;\n        }\n        x = uniform_value[1];\n      }\n    }`,\n    cond: `x.x > 0`,\n    uniform: `never`,\n  },\n};\n\nconst kVarInit = {\n  no_init: ``,\n  uniform: `= uniform_value[3];`,\n  nonuniform: `= nonuniform_value[3];`,\n};\n\ng.test('function_variables')\n  .desc(`Test uniformity of function variables`)\n  .params(u => u.combine('case', keysOf(kFuncVarCases)).combine('init', keysOf(kVarInit)))\n  .fn(t => {\n    const func_case = kFuncVarCases[t.params.case];\n    const code = `\n${func_case.typedecl}\n\n@group(0) @binding(0)\nvar<storage> uniform_value : array<${func_case.typename}, 4>;\n@group(0) @binding(1)\nvar<storage, read_write> nonuniform_value : array<${func_case.typename}, 4>;\n\n@group(1) @binding(0)\nvar t : texture_2d<f32>;\n@group(1) @binding(1)\nvar s : sampler;\n\nvar<private> nonuniform_cond : bool = true;\nconst uniform_cond : bool = true;\nvar<private> nonuniform_val : u32 = 0;\nconst uniform_val : u32 = 0;\n\n@fragment\nfn main() {\n  var x : ${func_case.typename} ${kVarInit[t.params.init]};\n\n  ${func_case.assignment}\n\n  if ${func_case.cond} {\n    let tmp = textureSample(t, s, vec2f(0,0));\n  }\n}\n`;\n\n    const result = expectedUniformity(func_case.uniform, t.params.init);\n    if (!result) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(result, code);\n  });\n\nconst kShortCircuitExpressionCases = {\n  or_uniform_uniform: {\n    code: `\n      let x = uniform_cond || uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: true,\n  },\n  or_uniform_nonuniform: {\n    code: `\n      let x = uniform_cond || nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  or_nonuniform_uniform: {\n    code: `\n      let x = nonuniform_cond || uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  or_nonuniform_nonuniform: {\n    code: `\n      let x = nonuniform_cond || nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  or_uniform_first_nonuniform: {\n    code: `\n      let x = textureSample(t, s, vec2f(0,0)).x == 0 || nonuniform_cond;\n    `,\n    uniform: true,\n  },\n  or_uniform_second_nonuniform: {\n    code: `\n      let x = nonuniform_cond || textureSample(t, s, vec2f(0,0)).x == 0;\n    `,\n    uniform: false,\n  },\n  and_uniform_uniform: {\n    code: `\n      let x = uniform_cond && uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: true,\n  },\n  and_uniform_nonuniform: {\n    code: `\n      let x = uniform_cond && nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  and_nonuniform_uniform: {\n    code: `\n      let x = nonuniform_cond && uniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  and_nonuniform_nonuniform: {\n    code: `\n      let x = nonuniform_cond && nonuniform_cond;\n      if x {\n        let tmp = textureSample(t, s, vec2f(0,0));\n      }\n    `,\n    uniform: false,\n  },\n  and_uniform_first_nonuniform: {\n    code: `\n      let x = textureSample(t, s, vec2f(0,0)).x == 0 && nonuniform_cond;\n    `,\n    uniform: true,\n  },\n  and_uniform_second_nonuniform: {\n    code: `\n      let x = nonuniform_cond && textureSample(t, s, vec2f(0,0)).x == 0;\n    `,\n    uniform: false,\n  },\n};\n\ng.test('short_circuit_expressions')\n  .desc(`Test uniformity of expressions`)\n  .params(u => u.combine('case', keysOf(kShortCircuitExpressionCases)))\n  .fn(t => {\n    const testcase = kShortCircuitExpressionCases[t.params.case];\n    const code = `\n@group(1) @binding(0)\nvar t : texture_2d<f32>;\n@group(1) @binding(1)\nvar s : sampler;\n\nconst uniform_cond = true;\nvar<private> nonuniform_cond = false;\n\n@fragment\nfn main() {\n  ${testcase.code}\n}\n`;\n\n    const res = testcase.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\nconst kExpressionCases = {\n  literal: {\n    code: `1u`,\n    uniform: true,\n  },\n  uniform: {\n    code: `uniform_val`,\n    uniform: true,\n  },\n  nonuniform: {\n    code: `nonuniform_val`,\n    uniform: false,\n  },\n  uniform_index: {\n    code: `uniform_value[uniform_val]`,\n    uniform: true,\n  },\n  nonuniform_index1: {\n    code: `uniform_value[nonuniform_val]`,\n    uniform: false,\n  },\n  nonuniform_index2: {\n    code: `nonuniform_value[uniform_val]`,\n    uniform: false,\n  },\n  uniform_struct: {\n    code: `uniform_struct.x`,\n    uniform: true,\n  },\n  nonuniform_struct: {\n    code: `nonuniform_struct.x`,\n    uniform: false,\n  },\n};\n\nconst kBinOps = {\n  plus: {\n    code: '+',\n    test: '> 0',\n  },\n  minus: {\n    code: '-',\n    test: '> 0',\n  },\n  times: {\n    code: '*',\n    test: '> 0',\n  },\n  div: {\n    code: '/',\n    test: '> 0',\n  },\n  rem: {\n    code: '%',\n    test: '> 0',\n  },\n  and: {\n    code: '&',\n    test: '> 0',\n  },\n  or: {\n    code: '|',\n    test: '> 0',\n  },\n  xor: {\n    code: '^',\n    test: '> 0',\n  },\n  shl: {\n    code: '<<',\n    test: '> 0',\n  },\n  shr: {\n    code: '>>',\n    test: '> 0',\n  },\n  less: {\n    code: '<',\n    test: '',\n  },\n  lessequal: {\n    code: '<=',\n    test: '',\n  },\n  greater: {\n    code: '>',\n    test: '',\n  },\n  greaterequal: {\n    code: '>=',\n    test: '',\n  },\n  equal: {\n    code: '==',\n    test: '',\n  },\n  notequal: {\n    code: '!=',\n    test: '',\n  },\n};\n\ng.test('binary_expressions')\n  .desc(`Test uniformity of binary expressions`)\n  .params(u =>\n    u\n      .combine('e1', keysOf(kExpressionCases))\n      .combine('e2', keysOf(kExpressionCases))\n      .combine('op', keysOf(kBinOps))\n  )\n  .fn(t => {\n    const e1 = kExpressionCases[t.params.e1];\n    const e2 = kExpressionCases[t.params.e2];\n    const op = kBinOps[t.params.op];\n    const code = `\n@group(0) @binding(0)\nvar t : texture_2d<f32>;\n@group(0) @binding(1)\nvar s : sampler;\n\nstruct S {\n  x : u32\n}\n\nconst uniform_struct = S(1);\nvar<private> nonuniform_struct = S(1);\n\nconst uniform_value : array<u32, 2> = array(1,1);\nvar<private> nonuniform_value : array<u32, 2> = array(1,1);\n\nconst uniform_val : u32 = 1;\nvar<private> nonuniform_val : u32 = 1;\n\n@fragment\nfn main() {\n  let tmp = ${e1.code} ${op.code} ${e2.code};\n  if tmp ${op.test} {\n    let res = textureSample(t, s, vec2f(0,0));\n  }\n}\n`;\n\n    const res = e1.uniform && e2.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n\ng.test('unary_expressions')\n  .desc(`Test uniformity of uniary expressions`)\n  .params(u =>\n    u\n      .combine('e', keysOf(kExpressionCases))\n      .combine('op', ['!b_tmp', '~i_tmp > 0', '-i32(i_tmp) > 0'] as const)\n  )\n  .fn(t => {\n    const e = kExpressionCases[t.params.e];\n    const code = `\n@group(0) @binding(0)\nvar t : texture_2d<f32>;\n@group(0) @binding(1)\nvar s : sampler;\n\nstruct S {\n  x : i32\n}\n\nconst uniform_struct = S(1);\nvar<private> nonuniform_struct = S(1);\n\nconst uniform_value : array<i32, 2> = array(1,1);\nvar<private> nonuniform_value : array<i32, 2> = array(1,1);\n\nconst uniform_val : i32 = 1;\nvar<private> nonuniform_val : i32 = 1;\n\n@fragment\nfn main() {\n  let i_tmp = ${e.code};\n  let b_tmp = bool(i_tmp);\n  let tmp = ${t.params.op};\n  if tmp {\n    let res = textureSample(t, s, vec2f(0,0));\n  }\n}\n`;\n\n    const res = e.uniform;\n    if (!res) {\n      t.expectCompileResult(true, `diagnostic(off, derivative_uniformity);\\n` + code);\n    }\n    t.expectCompileResult(res, code);\n  });\n"],"mappings":"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"}